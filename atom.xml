<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨同学的日常闲扯</title>
  
  <subtitle>杨同学的日常闲扯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imzry.github.io/"/>
  <updated>2019-07-26T08:32:52.218Z</updated>
  <id>https://imzry.github.io/</id>
  
  <author>
    <name>杨同学</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>配置本地访问远程Linux系统服务器的jupyter notebook</title>
    <link href="https://imzry.github.io/2019/07/23/%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8BLinux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84jupyter-notebook/"/>
    <id>https://imzry.github.io/2019/07/23/配置本地访问远程Linux系统服务器的jupyter-notebook/</id>
    <published>2019-07-23T11:22:28.000Z</published>
    <updated>2019-07-26T08:32:52.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境情况"><a href="#环境情况" class="headerlink" title="环境情况"></a>环境情况</h1><ul><li>远程服务器上配置了anaconda</li><li>本地主机没有安装anaconda（其实安不安装都无所谓，有浏览器就行）</li></ul><h1 id="配置步骤如下"><a href="#配置步骤如下" class="headerlink" title="配置步骤如下"></a>配置步骤如下</h1><ol><li><p>登录远程服务器</p></li><li><p>生成配置文件</p><p><code>jupyter notebook --generate-config</code></p></li><li><p>生成密码</p><p>输入<code>ipython</code>打开ipython生成密钥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'sha1:ce23d945972f:34769685a7ccd3d08c84a18c63968a41f1140274'</span>  <span class="comment">#这段是密钥</span></span><br></pre></td></tr></table></figure><p>把生成的密钥’sha1:ce2…’复制下来后面用，password是远程登录时需要输入的密码，要记住。</p></li><li><p>修改配置文件</p><p>使用vim打开配置文件</p><p><code>vim ~/.jupyter/jupyter_notebook_config.py</code></p><p>修改如下地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'*'</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha:ce...刚才复制的那个密文'</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8888</span>    <span class="comment">#随便指定一个端口，但是要记住</span></span><br><span class="line">c.NotebookApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">u'目录'</span>  <span class="comment">#这个是根目录，不想配置就不配置，默认是用户家目录</span></span><br></pre></td></tr></table></figure></li><li><p>启动jupyter notebook</p><p>正常启动：</p><p><code>jupyter notebook</code></p><p>但是我们可能通常想要在后台启动jupyter，然后关闭终端，在本地电脑上用浏览器访问：</p><p><code>nohup jupyter notebook &amp;</code></p></li><li><p>远程访问</p><p>在本地打开浏览器访问<code>http://address_of_remote:8888</code>就可以访问jupyter的登录界面了，输入密码就可以正常登录了。</p></li></ol><h1 id="意外情况"><a href="#意外情况" class="headerlink" title="意外情况"></a>意外情况</h1><p>有些服务器可能只开放一个对外的端口，但是我们通过终端访问服务器需要一个对外端口，开启jupyter服务又需要一个端口，这样就需要同时占用两个端口才行。举个栗子，服务器为了保证安全性只开放了一个对外的端口，22号端口，我们使用终端通过22号端口登录到服务器上打开jupyter，jupyter创建的端口是8888号，但是服务器没有对外开放8888号端口，所以即使打开了jupyter，外面也无法正常访问。如果把jupyter的端口号改为22号，由于我们登录终端的时候正在占用22号，所以jupyter就会提示端口已被占用，无法创建。网上有很多教程说可以通过修改防火墙设置来开放端口，修改防火墙设置一般都需要管理员权限，但是通常我们使用服务器的时候大多数情况下是不可能有管理员权限的，这时候我们可以使用端口映射来解决这个问题。</p><ol><li><p>首先登录终端打开jupyter，这是根据配置信息jupyter占用的是8888端口。</p></li><li><p>然后我们在本地上使用命令行输入：</p><p><code>ssh -N -f -L localhost:9999:localhost:8888 -p 端口号 username@远程地址</code></p><p>例如<code>ssh -N -f -L localhost:9999:localhost:8888 -p 22 yzr@202.48.29.23</code></p><p>这里说明一下：locahost:9999是指本地地址，localhost:8888是指远程地址，其中8888是jupyter notebook中设置的端口号，-p 22是指登录服务器的端口号 后面是用户名和服务器ip。</p></li><li><p>打开浏览器，输入localhost:9999就可以看到jupyter notebook的登录界面了。</p></li></ol><p>这里原理上就是将服务器上的8888端口映射到本机的9999端口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境情况&quot;&gt;&lt;a href=&quot;#环境情况&quot; class=&quot;headerlink&quot; title=&quot;环境情况&quot;&gt;&lt;/a&gt;环境情况&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;远程服务器上配置了anaconda&lt;/li&gt;
&lt;li&gt;本地主机没有安装anaconda（其实安不安装都无所谓，有
      
    
    </summary>
    
      <category term="Python" scheme="https://imzry.github.io/categories/Python/"/>
    
    
      <category term="DeepLearning" scheme="https://imzry.github.io/tags/DeepLearning/"/>
    
      <category term="jupyter" scheme="https://imzry.github.io/tags/jupyter/"/>
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>论文翻译：HetConv-Heterogeneous Kernel-Based Convolutions for Deep CNNs</title>
    <link href="https://imzry.github.io/2019/06/06/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%9AHetConv-Heterogeneous%20Kernel-Based%20Convolutions%20for%20Deep%20CNNs/"/>
    <id>https://imzry.github.io/2019/06/06/论文翻译：HetConv-Heterogeneous Kernel-Based Convolutions for Deep CNNs/</id>
    <published>2019-06-06T05:57:02.000Z</published>
    <updated>2019-07-27T02:42:17.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>我们提出了一种新颖的深度学习架构，其中卷积操作利用了异构内核。与标准卷积运算相比，所提出的HetConv（基于异构内核的卷积）减少了计算（FLOPs）和参数的数量，同时仍保持表示效率。为了证明我们提出的卷积的有效性，我们在标准卷积神经网络（CNN）架构上提供了广泛的实验结果，如VGG和ResNet。 我们发现在用我们提出的HetConv滤波器替换这些架构中的标准卷积滤波器后，我们实现了基于3X到8X FLOPs的速度提升，同时仍然保持（有时提高）精度。 我们还将我们提出的卷积与组/深度方式的卷积进行比较，并表明它可以以更高的精度实现更多的FLOPs减少。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>卷积神经网络在视觉和NLP等领域表现出了显著的性能。进一步提高性能的总趋势使模型更加复杂和深入。随着网络的深入，通过增加模型复杂度来提高精度并不是免费的；它伴随着计算量(FLOPs)的大幅增加。因此，人们提出了各种卷积运算/卷积滤波器，以减少对模型的FLOPs，提高模型的效率。</p><p>现有的卷积滤波器可以粗略地分为三类：1-深度卷积滤波器执行深度卷积（DWC），2-逐点卷积滤波器执行逐点卷积（PWC）和3-组循环卷积滤波器执行 分组卷积（GWC）。 大多数最近的架构使用这些卷积滤波器的组合来使模型有效。使用这些卷积（例如，DWC，PWC和GWC），许多流行的模型已经探索了新的架构来减少FLOPs。但是，设计新架构需要大量工作才能找到最佳的滤波器组合，从而实现最小的FLOPs。</p><p>另一种提高模型效率的流行方法是使用模型压缩。模型压缩大致可分为三类:连接剪枝、滤波器剪枝和量化。</p><p>在滤波器剪枝中，其思想是剪枝模型中贡献最小的筛选器，在删除此筛选器/连接之后，通常对模型进行微调以保持其性能。在修剪模型时，我们需要一个预先训练的模型(可能需要一个计算上昂贵的训练作为预处理步骤)，然后我们丢弃贡献最小的过滤器。因此，这是一个非常昂贵和棘手的过程。因此，使用有效的卷积滤波器或卷积运算来设计一个有效的架构是比剪枝更流行的方法。这并不需要昂贵的训练，然后修剪，因为训练是从头开始有效地完成。</p><p>使用有效的卷积滤波器，有两个不同的目标。一种工作侧重于设计具有最小FLOPs而同时降低精度的架构。这些工作重点是开发物联网/低端设备的模型。这些模型的精度较低，因此必须搜索最佳模型，以在精度和FLOPs之间建立平衡。因此，在FLOP和模型精度之间存在权衡。</p><p>另一组工作侧重于提高准确性，同时保持模型FLOPs与原始架构相同。最近的架构，如Inception，RexNetXt和Xception就是这类工作的例子。他们的目标是使用有效的卷积滤波器设计更复杂的模型，同时保持FLOPs与基本模型相同。通常期望更复杂的模型可以学习更好的特征，从而获得更好的准确性。但是，这些方法并不专注于设计新架构，而主要是在标准基础架构中使用现有的高效过滤器。因此，这些工作保持层数和体系结构与基础模型相同，并增加每层上的过滤器，使其不增加FLOPs。</p><p>与这两种方法相比，我们工作的主要重点是通过设计新内核来减少给定模型/体系结构的FLOP，而不会影响精度损失。 在实验上我们发现所提出的方法具有比现有技术修剪方法低得多的FLOPs，同时保持基础模型/架构的准确性。修剪方法非常昂贵，并且显示出实现FLOPs压缩的准确性显着下降。</p><p>在提出的方法中，我们选择了一种不同的策略来提高现有模型的效率，同时又不牺牲精度。架构搜索需要多年的研究才能得到优化的架构。因此，我们没有设计一个新的高效的架构，而是设计了一个高效的卷积运算(卷积滤波器)，它可以直接插入到任何现有的标准架构中以减少FLOPs。为了实现这一点，我们提出了一种新型的卷积——异构卷积。</p><p>卷积运算可以根据核的类型分为两类：</p><ul><li>使用传统卷积滤波器的同构卷积(例如标准卷积、群卷积、深度卷积、点卷积)。同构卷积可以用同构滤波器来实现。如果一个过滤器包含所有大小相同的内核，那么它就是同构的（例如，在一个$3\times 3\times 256$ CONV2D过滤器中，所有256个内核的大小都是$3 \times 3$）。</li><li>异构卷积使用异构卷积滤波器(HetConv)。如果一个过滤器包含不同大小的内核，那么它就是异构的(例如，在HetConv过滤器中，256个内核中有一些内核大小为$3\times 3$，其余的内核大小为$1 \times 1$)。</li></ul><p>在深度CNN中使用异构滤波器克服了现有基于高效架构搜索和模型压缩的方法的局限性。最新的高效架构之一MobileNet使用深度和点卷积。标准的卷积层被两个卷积层替换，因此它有更多的延迟（延迟1，延迟也可以简单的理解为速度慢于基准模型的多少）。有关延迟的详细信息，请参阅- 3.3节和图4。但是我们提出的HetConv具有与原始架构相同的延迟（延迟为零），而不像具有大于零的延迟。</p><p>与高精度下降的模型压缩相比，我们的方法与ResNet和VGGNet等标准模型的最新结果相比具有很强的竞争力。 使用HetConv过滤器，我们可以从头开始训练我们的模型，而不像需要预训练模型的修剪方法，而不会牺牲准确性。 如果我们增加FLOPs修剪的程度，修剪方法也会遭受严重的精确度下降。 使用提出的Het-Conv滤波器，与FLOPs修剪方法相比，我们拥有关于FLOPs的最新结果。 此外，修剪过程效率低，因为修剪后需要花费大量时间进行训练和微调。 我们的方法非常高效，并且在从头开始训练时，与原始模型相比，提供了类似的结果。</p><p>据我们所知，这是第一个异构的卷积/过滤器。这种异构设计有助于提高现有架构的效率（FLOPs降低），而不会牺牲精度。 我们在ResNet，VGG-16等不同架构上进行了大量实验，只需将原来的滤波器替换为我们提出的滤波器即可。 我们发现，在不牺牲这些模型的准确性的情况下，我们将FLOPs的高度降低（3倍到8倍）。与现有的修剪方法相比，这些FLOPs减少甚至更好。</p><p>我们的主要贡献如下：</p><ul><li>我们设计了一个高效的异构卷积滤波器，它可以插入到任何现有的架构中，在不牺牲精度的前提下，提高架构的效率(将FLOPs减少3到8倍)。</li><li>提出的HetConv滤波器的设计方式是零延迟。因此，从输入到输出的延迟可以忽略不计。</li></ul><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><p>最近深度神经网络的成功取决于模型设计。为了实现最小的错误率，模型变得越来越复杂。 复杂而深入的架构包含数百万个参数，需要数十亿次FLOP（计算）。 这些模型需要具有高端规格的机器，并且这些类型的架构在低计算资源上效率非常低。 这引起了人们对设计高效模型的兴趣。提高模型效率的工作可分为两部分。</p><h2 id="2-1-Efficient-Convolutional-Filter-高效的卷积过滤器"><a href="#2-1-Efficient-Convolutional-Filter-高效的卷积过滤器" class="headerlink" title="2.1. Efficient Convolutional Filter(高效的卷积过滤器)"></a>2.1. Efficient Convolutional Filter(高效的卷积过滤器)</h2><p>为了设计高效的卷积滤波器，近年来提出了几种新型的卷积滤波器。其中分组卷积(GWC)、深度卷积(DWC)[38]和点态卷积(PWC)是常用的卷积滤波器。它们被广泛用于设计高效的体系结构。GoogleNet使用inception模块和不规则的堆叠架构。Inception模块使用GWC和PWC来减少FLOPs。ResNet使用瓶颈结构来设计具有剩余连接的高效架构。它们使用PWC和标准卷积，有助于在不增加模型参数的情况下更深入，并减少FLOP爆炸。因此，与VGG相比，他们可以设计更深入的架构。ResNetxt使用ResNet架构，他们用GWC和PWC划分每一层。因此，在不增加FLOP的情况下，它们可以增加基数1.它们表明增加基数比更深或更宽的网络更有效。SENet设计了一种新的连接，它为每个输出特征映射赋予了权重，虽然FLOPs略有增加，但性能却有所提升。</p><p>MobileNet是另一种流行的架构，专为包含DWC和PWC的物联网设备而设计。这种架构在FLOP方面非常轻便且高效。FLOP的减少不是免费的，并且与最先进的模型相比，精度下降的成本也随之降低。在同一层使用不同类型的卷积滤波器，但由于每个过滤器中存在相同类型的内核，所以每个滤波器执行的卷积都是同构的。在相同层使用不同类型的卷积滤波器也有助于减少参数FLOP。在我们提出的卷积中，由于每个滤波器中存在不同类型的内核，卷积操作是异构的。</p><h2 id="2-2-Model-Compression（模型的压缩）"><a href="#2-2-Model-Compression（模型的压缩）" class="headerlink" title="2.2. Model Compression（模型的压缩）"></a>2.2. Model Compression（模型的压缩）</h2><p>另一种提高CNN效率的流行方法是模型压缩。这些可以分为:1-连接剪枝，2-过滤器剪枝和3位压缩。与其他方法相比，滤波器剪枝方法更有效，并且在FLOPs方面具有较高的压缩率。此外，过滤器修剪方法不需要任何特殊的硬件/软件支持(稀疏库)。</p><p>在滤波器剪枝中，大部分工作都是根据一定的准则计算滤波器的重要性，然后对其进行剪枝，然后进行再训练以恢复精度下降。使用L1范数作为排名过滤器的度量。但是，剪枝是在预先训练的模型上完成的，包括迭代训练和剪枝，这是昂贵的。此外，如果触发器剪枝的程度增加，则滤波器剪枝的精度会急剧下降。</p><h1 id="3-Proposed-Method（提出的方法）"><a href="#3-Proposed-Method（提出的方法）" class="headerlink" title="3. Proposed Method（提出的方法）"></a>3. Proposed Method（提出的方法）</h1><p>在这项工作中，我们提出了一种新颖的滤波器/卷积（Het-Conv），它包含异构内核（例如，少数内核的大小为$3 \times 3$，其他内核可能为$1 \times 1$），以减少现有模型的FLOPs。 与原始模型的精度相同。这与由均匀内核（例如全部$3 \times  3$或全部$5 \times 5$）组成的标准卷积滤波器非常不同。异构滤波器在FLOPs方面非常有效。它可以近似为分组卷积滤波器（GWC）和逐点卷积滤波器（PWC）的组合滤波器。为了减少卷积层的FLOPs，我们通常将其替换为两层或更多层（GWC / DWC和PWC），但它会增加延迟，因为下一层的输入是前一层的输出。因此，必须按顺序完成所有计算以获得正确的输出。相比之下，我们提出的HetConv具有相同的延迟。标准滤波器和HetConv滤波器之间的差异如图1和图2所示。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564121374371.png" alt="1564121374371"></p><blockquote><p>图1 标准卷积过滤器（同构）和异构卷积过滤器（HetConv）之间的诧异。其中M是指输入深度（输入通道的数量），P是指part（控制卷积过滤器中不同类型的核的数量）。在M个核中，$\frac MP$核的大小是$3×3$，其余的都是$1×1$。</p></blockquote><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564121408706.png" alt="1564121408706"></p><blockquote><p>图2 将所提出的卷积滤波器(HetConv)与其他有效卷积滤波器进行比较。我们的异构过滤器的延迟为零，而其他过滤器(GWC+PWC或DWC+PWC)的延迟为一个单元。</p></blockquote><p>在标准卷积层中，假设输入(输入特征图)的大小为$D_i\times D_i\times M$。其中$D_i$为输入的正方形特征图空间宽度和高度，$M$为输入深度(输入通道数)。还要考虑$D_o\times D_o\times N$是输出特性映射。这里$D_o$是输出的正方形特征图空间宽度和高度，$N$是输出深度(输出通道数)。应用$K\times K\times M$大小的N个滤波器得到输出特征图。这里K是内核大小。因此，这一$L$层的总计算成本为：</p><script type="math/tex; mode=display">FL_S=D_o\times D_o \times M \times N \times K \times K\tag{1}</script><p>由式(1)可以看出，计算代价与核大小(K)、feature map大小、输入通道M和输出通道n有关。这种计算代价非常高，可以通过精心设计新的卷积运算进一步降低。为了减少高计算量，提出了各种卷积，如DWC、PWC和GWC，这些卷积在许多最近的架构中被使用来减少FLOPs，但它们都增加了延迟。</p><p>标准卷积运算和一些最近的卷积运算使用同构核(即，对于整个过滤器，每个内核的大小相同)。为了提高效率，我们使用了异构内核。对于同一个过滤器，它包含不同大小的内核。请参考图3来可视化特定层l上的所有过滤器。我们定义P部分，它控制卷积过滤器中不同类型内核的数量。对于第P部分，总内核中的$\frac{1}{P}$部分为$K\times K$大小，其余部分$(1-\frac1P)$为$1\times 1$大小。为了更好地理解，让我们举个例子，在一个$3\times3\times 256$标准CONV2D过滤器中，如果您将$(1-\frac1P)\times 256$、$3\times 3$个内核替换为$1\times 1$(沿着中轴)，您将得到一个带有$P$部分的HetConv过滤器。请参见图1和图2。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564122897289.png" alt="1564122897289"></p><blockquote><p>图3 第$L$层卷积滤波器：使用异构内核的卷积滤波器(HetConv)。在图中，每个通道由大小为$3 \times 3$和$1\times 1$的异构内核组成。在标准卷积滤波器中，用$1\times 1$的核替换$3 \times 3$的核，在保持精度的同时，大大减少了误操作。特定层的过滤器以移位的方式排列(即，如果第一个过滤器从第一个位置启动$3\times 3$内核，那么第二个过滤器从第二个位置启动$3 \times 3$内核，以此类推)。</p></blockquote><p>在层$L$上有$P$部分的Hetconv滤波器中，$k\times k$大小的核的计算成本如下所示：</p><script type="math/tex; mode=display">FL_K=\frac{(D_o \times D_o \times M \times N \times K \times K)}{P}\tag{2}</script><p>它降低了P倍的成本，因为我们现在只有$\frac MP$个$K \times K$大小的核。</p><p>其余的$(M-\frac MP)$内核大小为$1\times 1$。剩余的$1\times 1$个内核的计算成本为：</p><script type="math/tex; mode=display">FL_1 = (D_o \times D_o \times N) \times (M - \frac MP)\tag{3}</script><p>因此，第$L$层的总计算成本为：</p><script type="math/tex; mode=display">FL_{HC} = FL_K + FL_1\tag{4}</script><p>与标准卷积相比，计算的总减少量（R）可表示为：</p><script type="math/tex; mode=display">R_{HetConv} = \frac {FL_K + FL_1}{FL_S}=\frac1P + \frac{1-\frac1P}{K^2}\tag{5}</script><p>在方程5中，如果我们令$P = 1$，那么它就变成了标准卷积滤波器。</p><p>通过将某些通道上的过滤器大小从$3\times 3$减小到$1 \times 1$，我们正在减小过滤器的空间范围。但是，通过在某些信道上保持$3\times 3$的大小，我们可以确保滤波器覆盖了某些信道上的空间相关性，并且不需要在所有信道上都具有相同的空间相关性。我们在实验部分观察到，通过这样做，我们可以获得与同构过滤器相似的精度。另一方面，如果我们避免并保留所有通道上的$1\times1$滤波器大小，那么我们就不会覆盖必要的空间相关信息，并且精度会受到影响。</p><h2 id="3-1-Comparision-with-DepthWise-followed-by-PointWise-Convolution（比较深度卷积和点卷积）"><a href="#3-1-Comparision-with-DepthWise-followed-by-PointWise-Convolution（比较深度卷积和点卷积）" class="headerlink" title="3.1. Comparision with DepthWise followed by PointWise Convolution（比较深度卷积和点卷积）"></a>3.1. Comparision with DepthWise followed by PointWise Convolution（比较深度卷积和点卷积）</h2><p>在极端情况下，HetConv中$P=M$时，HetConv可以与DWC+PWC(深度卷积后点卷积)进行比较。MobileNet使用这种类型的卷积。虽然MobileNet比我们的极端情况有更多的FLOPs与更多的延迟，因为MobileNet有一个延迟。</p><p>对于第$L$层，DWC+PWC (MobileNet)的总FLOPs数可以计算为：</p><script type="math/tex; mode=display">FL_{MobNet} =D_o \times D_o \times M \times K \times K + M \times N \times D_o \times D_o\tag{6}</script><p>因此总的计算量比标准卷积减少了：</p><script type="math/tex; mode=display">R_{MobNet}=\frac{FL_{MobNet}}{FL_S}=\frac 1N + \frac{1}{K^2}\tag{7}</script><p>从公式5可以清楚地看出，我们可以改变$P$部分的值来在精度和FLOPs之间进行权衡。 如果我们减小$P$值，产生的卷积将更接近标准卷积。 为了显示所提出的HetConv滤波器的有效性，我们在实验部分中显示了结果，其中HetConv使用类似的FLOP实现了明显更好的精度。</p><p>在$P = M$的极端情况下，由公式5和7(对于MobileNet $N = M$)，我们可以得出结论：</p><script type="math/tex; mode=display">\frac 1M + \frac{(1-\frac1M)}{K^2}< \frac 1M + \frac{1}{K^2}\tag{8}</script><p>与标准卷积相比计算量的总减少：</p><script type="math/tex; mode=display">Speedup = \frac{1}{Reduction}\tag{9}</script><p>因此，从公式8可以看出，MobileNet比我们的方法需要更多的计算。在我们的HetConv中，延迟为零，而MobileNet的延迟为1。在这种极端情况下，我们的精度明显高于MobileNet(请参阅实验部分)。</p><h2 id="3-2-Comparision-with-GroupWise-followed-by-PointWise-Convolution（与GroupWise比较，然后是PointWise-Convolution）"><a href="#3-2-Comparision-with-GroupWise-followed-by-PointWise-Convolution（与GroupWise比较，然后是PointWise-Convolution）" class="headerlink" title="3.2. Comparision with GroupWise followed by PointWise Convolution（与GroupWise比较，然后是PointWise Convolution）"></a>3.2. Comparision with GroupWise followed by PointWise Convolution（与GroupWise比较，然后是PointWise Convolution）</h2><p>对于组大小为$G$的群向卷积和点态卷积(GWC+PWC)，第$L$层的GWC+PWC总的FLOPs次数可以计算为：</p><script type="math/tex; mode=display">FL_G = \frac{(D_o \times D_o \times M \times N \times K \times K)}{G+ M \times N \times D_o \times D_o}\tag{10}</script><p>因此计算的总减少与标准的卷积比较：</p><script type="math/tex; mode=display">R_{Group} = \frac {FL_G}{FL_S} = \frac1G + \frac{1}{K^2}\tag{11}</script><p>同样的，当$P=G$时，由公式5和11得到：</p><script type="math/tex; mode=display">\frac 1P + \frac{(1-\frac1P)}{K^2}<\frac1P + \frac{1}{K^2}\tag{12}</script><p>因此，从公式12可以看出，GWC+PWC的计算量明显大于我们的方法。在HetConv中，我们的延迟为零，而GWC+PWC的延迟为1。</p><h2 id="3-3-Running-Latency（运行延迟）"><a href="#3-3-Running-Latency（运行延迟）" class="headerlink" title="3.3. Running Latency（运行延迟）"></a>3.3. Running Latency（运行延迟）</h2><p>大多数先前的方法设计了有效的卷积来减少FLOP，但它们增加了架构中的延迟。 不同类型卷积的延迟如图4所示。 在Inception模块中，一层被分解为两个或更多个连续层。因此，体系结构中的延迟大于零。 在Xception中应用第一个GWC，并且在GWC的输出上应用PWC。 PWC等待GWC的完成。 因此，这种方法减少了FLOP，但增加了系统的延迟。 类似地，在MobileNet中，第一个DWC然后应用PWC，因此它具有延迟1。 此延迟包括GPU等并行设备的延迟。在我们提出的方法中，任何层都不会被连续层替换，因此延迟为零。我们直接设计过滤器，这样可以在不增加任何延迟的情况下减少FLOP。 与先前的有效卷积相比，我们提出的方法在FLOP方面非常有竞争力，同时保持延迟为零。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564125300667.png" alt="1564125300667"></p><blockquote><p>图4 图中显示了不同类型卷积在延迟方面的比较。</p></blockquote><h2 id="3-4-Speedup-over-standard-convolution-for-different-values-of-P（3-4。对于不同的P值，加速标准卷积）"><a href="#3-4-Speedup-over-standard-convolution-for-different-values-of-P（3-4。对于不同的P值，加速标准卷积）" class="headerlink" title="3.4. Speedup over standard convolution for different values of P（3.4。对于不同的P值，加速标准卷积）"></a>3.4. Speedup over standard convolution for different values of P（3.4。对于不同的P值，加速标准卷积）</h2><p>如图-5所示，加速比随P值增加。我们可以使用P值在准确度和FLOP之间进行权衡。 如果我们减小P值，产生的卷积将更接近标准卷积。 为了显示所提出的HetConv滤波器的有效性，我们在实验部分中显示了结果，其中Het-Conv相对于具有类似FLOPs的其他类型的卷积实现了显着更好的准确性。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564125360227.png" alt="1564125360227"></p><blockquote><p>图5 对于具有$3 \times 3$和$1 \times 1$内核的HetConv滤波器，针对不同$P$值的标准卷积加速。</p></blockquote><h1 id="4-Experiments-and-Results（实验和结果）"><a href="#4-Experiments-and-Results（实验和结果）" class="headerlink" title="4. Experiments and Results（实验和结果）"></a>4. Experiments and Results（实验和结果）</h1><p>为了证明所提出的Hetconv滤波器的有效性，我们对当前的各种体系结构进行了大量的实验。我们用提议的架构替换了这些架构中的标准卷积滤波器。我们使用resnet-34、resnet-50和vgg-16体系结构对imagenet进行了三次大规模实验。我们已经为vgg-16、resnet-56和mobilenet体系结构展示了三个关于cifar-10的小规模实验。在所有实验中，我们都将挤压和激励（SE）的减速比设置为8。</p><h2 id="4-1-Notations（符号）"><a href="#4-1-Notations（符号）" class="headerlink" title="4.1. Notations（符号）"></a>4.1. Notations（符号）</h2><p>XXX_P$\alpha$：$XXX$是架构，部分值是$P =\alpha$; XXX_P$\alpha$ _ SE：$SE$为挤压和激励，减速比= 8；XXX_GWC$\beta$  _ PWC：GWC$\beta$ _ PWC}是具有组大小$\beta$的分组卷积，然后是逐点卷积；​XXX_DWC_PWC：​DWC_PWC是深度卷积，然后是逐点卷积；XXX_PC：​PC是部分值$P =输入通道数（输入深度）$。</p><h2 id="4-2-VGG16-on-CIFAR10"><a href="#4-2-VGG16-on-CIFAR10" class="headerlink" title="4.2. VGG16 on CIFAR10"></a>4.2. VGG16 on CIFAR10</h2><p>在本实验中，我们使用了VGG-16架构的。在CIFAR-10数据集中，每个图像大小在RGB尺度上都是$32\times 32$大小。在VGG-16架构中，有13个卷积层使用标准的CONV2D卷积，每层之后我们都添加了批处理归一化。我们使用的设置与中描述的相同。超参数的值为:权值衰减=5e-4，批大小=128，初始学习率=0.1，每隔50个时点后按$10 \times  0.1$计算。</p><p>除了初始卷积层（即conv 1），其余12个标准卷积层都被我们的hetconv层（所有12个层的$p$值相同）所取代，同时保持与之前相同的文件数量。如表1所示，$P$值增大，FLOPs(计算)值减小，但精度没有明显下降。我们也用$SE$技术对HetConv进行了实验，发现$SE$在开始时提高了精度，但后来由于过拟合，开始降低模型性能(精度)，如表1所示。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126545088.png" alt="1564126545088"></p><blockquote><p>表格1 下表显示了不同设置下CIFAR-10上的VGG-16的详细结果。</p></blockquote><h3 id="4-2-1-Comparison-with-groupwise-followed-by-pointwise-convolution（与分组然后逐点卷积比较）"><a href="#4-2-1-Comparison-with-groupwise-followed-by-pointwise-convolution（与分组然后逐点卷积比较）" class="headerlink" title="4.2.1 Comparison with groupwise followed by pointwise convolution（与分组然后逐点卷积比较）"></a>4.2.1 Comparison with groupwise followed by pointwise convolution（与分组然后逐点卷积比较）</h3><p>我们用分组进行逐点卷积，其中所有标准卷积层（除了初始卷积层，即CONV 1）由两层（具有组大小4和逐点卷积层的分组卷积层）代替。 现在模型有延迟一个。 如表-1所示，VGG-16 GWC4 PWC具有92.76％的准确度，而我们的VGG-16 P4型具有显着更高的93.93％准确度和更低的FLOP。</p><h3 id="4-2-2-Comparison-with-depthwise-followed-by-pointwise-convolution（与深度方式，然后是逐点卷积的比较）"><a href="#4-2-2-Comparison-with-depthwise-followed-by-pointwise-convolution（与深度方式，然后是逐点卷积的比较）" class="headerlink" title="4.2.2 Comparison with depthwise followed by pointwise convolution（与深度方式，然后是逐点卷积的比较）"></a>4.2.2 Comparison with depthwise followed by pointwise convolution（与深度方式，然后是逐点卷积的比较）</h3><p>我们用深度方式进行实验，然后进行逐点卷积，其中所有标准卷积层（初始卷积层除外，即CONV 1）由两层（深度卷积层和逐点卷积层）代替。 现在模型有延迟一个。 如表1所示，VGG-16_DWC_PWC在CIFAR-10上的准确度仅为91.27％，而我们的VGG-16_P64型具有相当的FLOPs，精度高达93.42％。</p><p>我们还尝试了不同层的不同P值。 除了初始卷积层（即CONV 1）之外，所有剩余的12个标准卷积层都被我们的HetConv层替换，其中P =输入通道的数量。 如表1所示，我们的模型VGG-16 PC和VGG-16_PC_SE仍然表现优于VGG-16_DWC_PWC，这表明我们的HetConv优于DWC + PWC。</p><h3 id="4-2-3-Comparison-with-FLOPs-compression-methods（与FLOPs压缩方法的比较）"><a href="#4-2-3-Comparison-with-FLOPs-compression-methods（与FLOPs压缩方法的比较）" class="headerlink" title="4.2.3 Comparison with FLOPs compression methods（与FLOPs压缩方法的比较）"></a>4.2.3 Comparison with FLOPs compression methods（与FLOPs压缩方法的比较）</h3><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126653639.png" alt="1564126653639"></p><blockquote><p>表格2 该表显示了我们的模型与CIFAR-10数据集上VGG-16架构的最新模型压缩方法的比较。</p></blockquote><p>如表-2所示，与现有技术的模型压缩方法相比，我们的模型VGG-16 P32和VGG-16 P64具有明显更高的精度。 我们降低了~85％的FLOP而没有精度损失，而FLOPs压缩方法的准确性损失很大（超过1％），如表-2所示。</p><h2 id="4-3-ResNet56-on-CIFAR10（ResNet56在CIFAR10上）"><a href="#4-3-ResNet56-on-CIFAR10（ResNet56在CIFAR10上）" class="headerlink" title="4.3. ResNet56 on CIFAR10（ResNet56在CIFAR10上）"></a>4.3. ResNet56 on CIFAR10（ResNet56在CIFAR10上）</h2><p>我们在CIFAR-10数据集上试验了ResNet-56架构[8]。 ResNet-56由大小为16-32-64的卷积层的三个阶段组成，其中每个阶段的每个卷积层包含相同的2.36M FLOP，总FLOP为126.01M。我们使用相同的参数训练模型。[8]。 除了初始卷积层之外，所有剩余的标准卷积层都被我们的HetConv层替换，同时保持滤波器的数量与之前相同。</p><p>如表-3所示，与具有更高FLOP降低的现有模型压缩方法相比，我们的模型ResNet-56_P2和ResNet-56_P4具有明显更好的精度。 我们还使用SE技术对HetConv进行了实验，发现由于过度拟合，SE性能不如预期。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126717505.png" alt="1564126717505"></p><blockquote><p>表格 3 下表显示了不同设置下ResNet-56与CIFAR- 10上的最新模型压缩方法的详细结果和比较。</p></blockquote><h2 id="4-4-MobileNet-on-CIFAR10（MobileNet在CIFAR10上）"><a href="#4-4-MobileNet-on-CIFAR10（MobileNet在CIFAR10上）" class="headerlink" title="4.4. MobileNet on CIFAR10（MobileNet在CIFAR10上）"></a>4.4. MobileNet on CIFAR10（MobileNet在CIFAR10上）</h2><p>该表显示了详细结果，并与不同设置中CIFAR-10上ResNet-56的最新模型压缩方法进行了比较。早些时候。 在我们的模型中，两个卷积层（深度卷积层和逐点卷积层）被一个HetConv卷积层取代，这将延迟从1减少到零。</p><p>如表4所示，我们的模型MobileNet_P32和MobileNet_P32_SE与MobileNet模型相比具有显著的更好的精度(接近1%)，而MobileNet架构上的失败几乎相同，这再次表明我们提出的HetConv卷积优于深度卷积和点态卷积。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126751299.png" alt="1564126751299"></p><blockquote><p>表格4 下表显示了在CIFAR- 10上不同设置下MobileNet的结果。</p></blockquote><h2 id="4-5-VGG16-on-ImageNet"><a href="#4-5-VGG16-on-ImageNet" class="headerlink" title="4.5. VGG16 on ImageNet"></a>4.5. VGG16 on ImageNet</h2><p>我们在大型ImageNet数据集上试验了VGG-16架构。 除了初始卷积层之外，所有剩余的卷积层都被我们的HetConv层替换，同时保持文件管理器的数量与之前相同。<br>我们的模型VGG-16_P4显示了最近针对翻转压缩提出的方法的最新结果。 通道修剪（CP）具有50.0％的FLOP压缩，而我们具有65.8％的FLOP压缩而没有精度损失。<br>有关更多详细信息，请参阅表-5。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126805139.png" alt="1564126805139"></p><blockquote><p>表格5 表中显示了ImageNet上VGG-16的结果。与目前最先进的剪枝方法相比，我们的模型在精度上没有损失，同时显著提高了FLOPs减少率。</p></blockquote><h2 id="4-6-ResNet-34-on-ImageNet"><a href="#4-6-ResNet-34-on-ImageNet" class="headerlink" title="4.6. ResNet-34 on ImageNet"></a>4.6. ResNet-34 on ImageNet</h2><p>我们在大型ImageNet数据集上试验了ResNet-34架构。 除了初始卷积层，所有剩余的卷积层都被我们的HetConv层替换。我们的模型ResNet-34_P4显示了先前提出的方法的最新结果。 NISP的FLOP压缩率为43.76％，而FLOP压缩率为64.48％，精度明显提高。 有关详细信息，请参阅表-6。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126878725.png" alt="1564126878725"></p><blockquote><p>表格 6 表中显示了ResNet-34在ImageNet上的结果。与最先进的剪枝方法相比，我们的模型在精度上没有损失，而在不同的设置中显著提高了故障减少。</p></blockquote><h2 id="4-7-ResNet50-on-ImageNet"><a href="#4-7-ResNet50-on-ImageNet" class="headerlink" title="4.7. ResNet50 on ImageNet"></a>4.7. ResNet50 on ImageNet</h2><p>ResNet-50是一种深度卷积神经网络，具有50层的残差连接。在这种结构中，我们用我们提出的HetConv卷积替换标准卷积。超参数的值为：权值衰减=1e-4，批大小=256，初始学习率=0.1，每隔30个epoch进行一次十进0.1，模型在90个epoch进行训练。</p><p>由表7可以看出，我们的模型ResNet-50_P4在精度上没有损失，而触发器剪枝方法在前1精度上存在较大的精度下降。我们的模型是从零开始训练的，但是剪枝方法需要预先训练的模型，并且涉及迭代剪枝和微调，这是一个非常耗时的过程。</p><p><img src="/images/HetConv-Heterogeneous-Kernel-Based-Convolutions-for-Deep-CNNs/1564126943915.png" alt="1564126943915"></p><blockquote><p>表格7 表中显示了ResNet-50在ImageNet上的结果。与现有的触发器剪枝方法相比，我们的模型在精度上没有损失。</p></blockquote><h1 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h1><p>在这项工作中，我们提出了一种使用异构内核的新型卷积。 我们将我们提出的卷积与各种现有架构（VGG-16，ResNet和MobileNet）上的流行卷积（深度卷积，分组卷积，逐点卷积和标准卷积）进行了比较。实验结果表明，与现有的卷积相比，我们的HetConv卷积更有效（较小的FLOP，精度更高）。由于我们提出的卷积不会增加层（替换具有多个层的层，例如，MobileNet）以减少FLOP，因此延迟为零。 我们还将基于HetConv卷积的模型与FLOPs压缩方法进行了比较，结果表明，与压缩方法相比，它可以产生更好的结果。 将来，使用这种类型的卷积，我们可以设计出更高效的架构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;我们提出了一种新颖的深度学习架构，其中卷积操作利用了异构内核。与标准卷积运算相比，所提出的H
      
    
    </summary>
    
      <category term="论文阅读" scheme="https://imzry.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="深度学习" scheme="https://imzry.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="DeepLearning" scheme="https://imzry.github.io/tags/DeepLearning/"/>
    
      <category term="卷积神经网络" scheme="https://imzry.github.io/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://imzry.github.io/2019/01/02/hello-world/"/>
    <id>https://imzry.github.io/2019/01/02/hello-world/</id>
    <published>2019-01-02T01:34:05.000Z</published>
    <updated>2019-07-27T08:24:28.469Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>！这是你的第一篇文章。查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>以获取更多信息。 如果您在使用Hexo时遇到任何问题，可以在<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">故障排除</a>中找到答案，或者您可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上询问我。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一个新帖子"><a href="#创建一个新帖子" class="headerlink" title="创建一个新帖子"></a>创建一个新帖子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"我的新文章"</span></span><br></pre></td></tr></table></figure><p>更多信息：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">写作</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息：<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">生成</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">部署</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;！这是你的第一篇文章。查看&lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Python学习之路8 - 内置方法</title>
    <link href="https://imzry.github.io/2017/11/22/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF8-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>https://imzry.github.io/2017/11/22/Python学习之路8-内置方法/</id>
    <published>2017-11-22T06:37:00.000Z</published>
    <updated>2019-07-27T08:18:56.374Z</updated>
    
    <content type="html"><![CDATA[<div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">abs(-230)   #取绝对值all([0,1,-5])   #如果参数里面的所有值都为真就返回真，否则返回假any([0,1,-5])   #如果参数里面有一个值为真则返回真，否则返回假ascii([1,2,'fds','浮点数'])#将参数变成字符串bin(8)  #十进制转二进制hex(255)    #转十六进制oct(4)  #转八进制bool(2) #判断参数真假a = bytes("abcde",encoding="utf-8") #将字符串转换成二进制b = bytearray("abcde",encoding="utf-8") #将字符串转换成二进制数组b[2] = 100  #然后就可以想数组一样修改值def test():passcallable(test)  #判断参数是否能被调用，test是函数，所以能被调用，返回Truechr(100)    #把数字对应的ASCII码字符取出来ord('d')    #返回对应的ASCII码编号a = {}dir(a)  #查看a有什么方法divmod(5,2) #返回参数一处以参数二的结果和余数a = '''a = [1,2,3]b = iter(a)print(b.__next__())'''exec(a) #将字符串编译成代码，然后运行res = filter(lambda n:n&gt;5,range(10)) #用来过滤数据，第一个是条件，第二个是数据for i in res:    print(i)res = map(lambda n:n*n,range(10)) #用来处理数据，第一个是处理方式，第二个是数据for i in res:    print(i)import functoolsres = functools.reduce(lambda x,y:x*y,range(10))    #累计处理    #第一个参数是累计的方式，这里是累加    #第二个参数是需要运算的数据print(res)  #45a = frozenset([1,4,33,212,54])  #将一个列表变成不可修改的globals()   #返回当前文件的所有变量名和值globals().get('a')  #这样可以取出变量名对应的值hash('test')    #返回对象的哈希值max()   #返回最大值min()   #返回最小值pow(3,5)   #3的5次方repr(a)     #将一个对象转换成字符串round(1.5461,2) #保留2位小数a = {6:2,4:23,34:5,-5:99}sorted(a.items()) #按照key值进行排序sorted(a.items(),key=lambda x:x[1]) #按照value进行排序a = [1,2,3,4,5,6]b = ['a','b','c','d']for i in zip(a,b): #将a和b一一对应组成4个元组，a中的5,6没有对应的元组，所以就不显示    print(i)__import__('decorator') #将同目录下的decorator.py文件导入</pre></div><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;abs(-230)   #取绝对值
all([0,1,-5])   #如果参数里面的所有值都为真就返回真，否则返回假
any([0,1
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路7 - 生成器&amp;迭代器</title>
    <link href="https://imzry.github.io/2017/11/22/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF7-%E7%94%9F%E6%88%90%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://imzry.github.io/2017/11/22/Python学习之路7-生成器-迭代器/</id>
    <published>2017-11-22T06:35:00.000Z</published>
    <updated>2019-07-27T08:18:52.061Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本章内容：</strong></p><ul><li>列表生成式</li><li>生成器</li><li>yield</li><li>迭代器</li></ul><hr><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>当我们要定义一个列表的时候，我们通常用这种方式a = [1,2,3]，但是如果我们定义了一个比较长的列表的时候，手动定义列表就会比较麻烦，这是我们通常的做法就是利用循环的手段来创建列表，例如创建如下的列表：</p><p>L = [0,1,4,9,16,25,36,49,64,81]</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">L = []for x in range(1, 11):   L.append(x*x)</pre></div><p>　　这样我们就创建了一个较长的列表。</p><p>但是这样写，我们用了三行代码，其实我们可以用一行代码就代替了它：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">L = [i*i for i in range(1,11)]</pre></div><p>　　这就是列表生成式。</p><p>前面的i*i是运算式，也可以用函数，然后后面加上一个for循环就可以了。</p><p>其实我们不难看出，for循环和列表生成式的关系，如下图：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201711/1204715-20171122141227493-1577974351.jpg" alt></p><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">[x * x for x in range(1, 11) if x % 2 == 0]#结果为：#[4, 16, 36, 64, 100]</pre></div><p>还可以使用两层循环，可以生成全排列：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">[m + n for m in 'ABC' for n in 'XYZ']#结果为：#['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']</pre></div><p>三层用的就比较少了。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>上面的列表生成式的最外面是用中括号括起来的，如果把中括号变成小括号，也就是这样：</p><p>L = (i*i for i in range(1,11))</p><p>这样就是一个生成器了。</p><p><strong>那么生成器有什么好处呢？</strong></p><p>我们用列表生成式直接生成列表后，列表会直接放在内存中等待被使用。但是如果列表过于长了，但是我们暂时又用不到全部的元素，就会造成内存的浪费。生成器的好处就在于(i*i for i in range(1,11))这句话执行完毕后将返回一个算法给L，并不是直接将所有的数据放到内存中，当我们访问数据时，生成器就会根据算法现生成我们需要的书库，这样就避免了内存的浪费。</p><p>但是生成器不能像列表一样a[100]这样直接取出某个数据，因为生成器还没有访问到第100个元素。生成器其实就像一个递推公式一样，想要知道第100个元素是什么，就必须要先知道第99个元素是什么，以此类推…</p><p>下面用生成器生成一个列表并且遍历所有的数据</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">L = (i*i for i in range(1,11))for i in L:    print(i)</pre></div><p>也可以一个一个数据的访问，调用生成器中下一个数据</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">a = (i*i for i in range(1,11))a.__next__()    #这样就调用了下一个数据</pre></div><p>并且生成器也只有一个方法，就是<strong>next</strong>()方法，只能往下走，不能回头。</p><p>&nbsp;</p><h2 id="yield-nbsp"><a href="#yield-nbsp" class="headerlink" title="yield&nbsp;"></a>yield&nbsp;</h2><p>先来看一个菲波那切数列的迭代算法。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def fib(max):    n,a,b = 0,0,1    while n&lt;max:        #print(b)   #如果用print，那么这个函数就会直接输出数列的所有值        yield b     #如果用yield，那么这个函数就会变成一个生成器        a, b = b, a + b        n = n + 1    return '---done---' #如果程序抛异常，就会返回这个信息</pre></div><p>yield可以保存当前循环的状态，然后可以先做其他的事情，做完其他的事情，可以回来继续进行下一个循环。</p><p>&nbsp;</p><p><strong>yield的一个稍微复杂的应用</strong> - 利用yield模拟多线程</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef consumer(name):    print("%s 准备吃包子了！" %name)    while True:        baozi = yield        print("包子[%s]来了，被[%s]吃了！" %(baozi,name))#当函数中有yield时，这个函数就会变成一个生成器c = consumer('lisi')    #将这个生成器赋值给cc.__next__()    #然后执行一次这个生成器，但是一次调用只会执行到含有yield的语句前面，                # 因为yield可以暂停并保存当前的状态，一到yield就会暂停，所以while循环里面的输出语句没有执行c.send('猪肉')  #send()函数，用来向yield里面传值，然后继续执行一次，直到再次碰到yield时就会再次暂停                #注意，第一次执行时一定要执行__next__()函数，后面才可以执行send()函数c.send('牛肉')    #再次传值，再次执行while里面的语句，注意，不会执行上面的print("%s 准备吃包子了！" %name)语句c.send('niurou')    #再次传值，再次执行while里面的语句c.__next__()    #这里再次调用__next__()函数，同样还是执行while里面的输出语句，但是不会向yield里面传值</pre></div><p>上面是手动执行这个生成器，下面写一个函数来调用这个生成器。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef consumer(name):    print("%s 准备吃包子了！" %name)    while True:        baozi = yield        print("包子[%s]来了，被[%s]吃了！" %(baozi,name))def producer():    c = consumer('A')    c2 = consumer('B')    c.__next__()    c2.__next__()    print('老子开始准备做包子了')    for i in range(10):        time.sleep(1)        print('做了一个包子，分两半')        c.send(i)        c2.send(i)producer()#这样就是一边做包子，一边吃包子了</pre></div><p>&nbsp;</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以被next()函数调用并不断返回下一个值的对象成为迭代器：Iterator。</p><p>可以使用isinstance()判断一个对象是否是Iterator对象或者Iterable对象</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">from collections import Iterator    #需要先导入这个模块isinstance((x for x in range(10)),Iterator)    #第一个参数为想要判断的东西，第二个参数是想要判断的类型isinstance({},Iterator)from collections import Iterableisinstance((),Iterator)isinstance('abc',Iterator)</pre></div><p>生成器都是Iterator对象，但是list、dict、str虽然是Iterator，却不是Iterator。<br>把list、dict、str等Iterable变成Iterator可以使用iter()对象。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">isinstance(iter([]),Iterator)   #这样结果就是True了#例子a = [1,2,3]b = iter(a)b.__next__()</pre></div><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本章内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表生成式&lt;/li&gt;
&lt;li&gt;生成器&lt;/li&gt;
&lt;li&gt;yield&lt;/li&gt;
&lt;li&gt;迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;列表生成式&quot;&gt;&lt;a href=&quot;#列表生成式&quot; class=
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路6 - 装饰器</title>
    <link href="https://imzry.github.io/2017/11/21/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF6-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://imzry.github.io/2017/11/21/Python学习之路6-装饰器/</id>
    <published>2017-11-21T11:01:00.000Z</published>
    <updated>2019-07-27T08:18:48.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><strong>定义</strong>：本质是函数，（装饰其他函数）就是为其他函数添加附加功能。<br><strong>原则</strong>：1.不能修改被装饰的函数的源代码<br>      　　　2.不能修改被装饰的函数的调用方式</p><p><strong>实现装饰器的知识储备：</strong><br>　　1.函数即&ldquo;变量&rdquo;<br>　　2.高阶函数（满足下列条件之一就是高阶函数）</p><ul><li><ul><li>a：把一个函数名当作形参传给另一个函数(在不修改被装饰函数源代码的情况下修改其功能,但是调用方式变了)</li><li>b：返回值中包含函数名(不修改函数的调用方式,而修改函数功能)</li></ul></li></ul><p>　　3.嵌套函数</p><p>&nbsp;</p><p><strong>总结：</strong></p><p>高阶函数+嵌套函数=&gt;装饰器</p><hr><h3 id="1-函数即变量"><a href="#1-函数即变量" class="headerlink" title="1. 函数即变量"></a>1. 函数即变量</h3><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def bar():  #这里定义个函数    print('this is bar...')func = bar  #将函数当变量一样赋值给funcfunc()  #这是func加上()就可以当函数用了</pre></div><p>　　这就是函数即变量。</p><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h3><p><strong>a：</strong>把一个函数名当做形参传给另一函数（在不修改被装饰函数源代码的情况下修改其他功能，但是调用方式变了）</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def bar():    print('this is bar...')bar()print('----------------------------------')def test(func): #在这里增加了功能    print(func)test(bar)  #但是这里修改了调用方式</pre></div><p><strong>b：</strong>返回值中包含函数名（不修改函数的调用方式，而修改函数功能）</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def bar():    print('this is bar...')bar()print('----------------------------------')def test(func):   #在这里增加了功能    print(func)    return func        #这里返回了函数地址bar = test(bar)   #将函数地址赋给一个变量,该变量和传入函数同名bar()        #这个变量加上括号,就可以当函数用了,同时又没有修改函数的调用方式</pre></div><h3 id="3-嵌套函数"><a href="#3-嵌套函数" class="headerlink" title="3. 嵌套函数"></a>3. 嵌套函数</h3><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">x = 1def test1():    def test2():        def test3():            x = 3            print(x)        test3()    test2()test1()</pre></div><p>　　像这样在一个函数里面定义一个函数就叫做嵌套函数。</p><p>&nbsp;</p><p>现在三个知识点都已经解释过了，下面先实现一个原始版的装饰器。</p><p><strong>原始版装饰器</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef test1():  #这里是被装饰的函数    time.sleep(1)    print("this is test1....")def timer(func):  #这里是装饰器函数    def deco():        strat = time.time()        func()        stop = time.time()        print("run time %s" %(stop-strat))    return decotest1 = timer(test1)test1()</pre></div><p>　　这个装饰器的功能是测试test1函数的运行时间，deco函数有这个功能，所以这里其实我想运行的是deco函数，timer()函数的返回值也就是deco函数的地址；同时deco函数想要运行也要满足另一个条件，那就是需要调用timer函数，只有当timer函数运行的时候timer函数里面写的那些东西才会生效或者说被激活，deco函数才会定义成功。到此，test=timer(test1)这句代码的意思就是，先调用timer函数让deco函数的定义生效，同时将要被装饰的函数test1函数的地址传入，让deco函数里面的func函数生效，这是timer函数又会将deco函数的地址返回，并将地址赋值给test1这个变量。然后下面的test1后面加上括号，变成test1()的形式，就可以运行了。这样一个原始版的装饰器就写完了。</p><p><strong>接下来要写一个真实装饰器的实例</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef timer(func):    def deco():        start_time = time.time()        func()        stop_time = time.time()        print('the func run time is %s' %(stop_time-start_time))    return deco@timer  #这里等于 test = timer(test),要装饰哪个函数,就在哪个函数前面加上这个def test():    time.sleep(2)    print('this is test...')test()</pre></div><p>　　上面这些都是一些比较基本的，如果装饰有参数的函数且参数的个数还都不一定怎么办呢？下面写一个高级案例 — 有参数的装饰器</p><p><strong>高级案例 — 有参数装饰器</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef timer(func):    def deco(*args,**kwargs):　　#在这里接收参数        start_time = time.time()        func(*args,**kwargs)        stop_time = time.time()        print('the func run time is %s' %(stop_time-start_time))    return deco@timerdef test(name):    time.sleep(2)    print('this is test...',name)test('vector')</pre></div><p>　　如果原test函数里面有返回值，被装饰后我们打印它print(test())，结果会是none。因为这时的test=deco，而deco没有返回值，所以打印不出来。这样就会出现一个问题，如果test函数有返回值，test函数的一个功能（返回值）就会被弄丢了。</p><p>解决办法看下面案例。</p><p><strong>高高级案例 — 有返回值的装饰器</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef timer(func):    def deco(*args,**kwargs):        start_time = time.time()        res = func(*args,**kwargs)        stop_time = time.time()        print('the func run time is %s' %(stop_time-start_time))        return res  #这里将func的返回值返回    return deco@timerdef test(name):    time.sleep(2)    print('this is test...',name)    return 'asdfasdfgdfgd'print(test('vector'))</pre></div><p>　　这样就可以打印出返回值了。</p><p>还有些时候我们需要给装饰器进行传参，给内部使用。解决方案看下面。</p><p><strong>高高高级案例 — 给装饰器传参</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import timedef timer(temp):    print('this is ',temp)  #这里是加进来的参数    def out(func):        def deco(*args,**kwargs):            start_time = time.time()            res = func(*args,**kwargs)            stop_time = time.time()            print('the func run time is %s' %(stop_time-start_time))            return res        return deco    return out@timer('temp')def test(name):    time.sleep(2)    print('this is test...',name)    return 'asdfasdfgdfgd'print(test('vector'))</pre></div><p>　　实际上就是整体又在外面加了一层内嵌函数。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：本质是函数，（装饰其他函数）就是为其他函数添加附加功能。&lt;br&gt;&lt;strong&gt;原则&lt;/st
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路5 - 函数</title>
    <link href="https://imzry.github.io/2017/09/19/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF5-%E5%87%BD%E6%95%B0/"/>
    <id>https://imzry.github.io/2017/09/19/Python学习之路5-函数/</id>
    <published>2017-09-19T08:25:00.000Z</published>
    <updated>2019-07-27T08:18:43.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>定义方式：</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def func():    "这里面写函数的描述"    这里写代码    return x    #如果没有返回值就叫"过程"，函数和过程的区别就是有无返回值</pre></div><p>实例</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def fun1():    "这里是测试"    print('这是第一个函数')    return 0fun1() #调用函数</pre></div><p>&nbsp;</p><p><strong>函数传参</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def test(x,y,z):    print(x)    print(y)    print(z)test(3,3,5) #这样传的参数叫做位置参数, 位置是一一对应的test(x=5,y=4,z=3) #这样传的参数叫做关键参数, 位置可以不用一一对应</pre></div><p><strong>这里需要注意的是</strong>，关键参数是不能写在位置参数前面的。<br>例如 test(x=4,5,5) 这样x是用了关键参数，y和z用了位置参数，这样就是错的。<br>但是 test(3,y=4,z=6) 这样位置参数x在关键参数y和z的前面，这样就是可以的。<br>同理 test(3,z=6,y=4) 这样也是可以的。</p><p>&nbsp;</p><p><strong>参数组</strong><br>如果我要传入的参数数量不固定，就在形参列表里写 *变量名 来实现。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def test(*args):    print(args) #打印出来的是一个元组test(3,3,5) #这样我传多少个参数都没问题了test(*[3,4,5,6,6,4]) #这是第二种传值方式</pre></div><p>&nbsp;</p><p><strong>传入字典</strong></p><p>如果我想传入字典就在形参的位置用 **变量名 来实现</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def test(**args):    print(args) #打印出来的是一个字典test(name='vector',age=3)</pre></div><p>&nbsp;</p><h4 id="高阶函数（满足下列条件之一就是高阶函数）"><a href="#高阶函数（满足下列条件之一就是高阶函数）" class="headerlink" title="高阶函数（满足下列条件之一就是高阶函数）"></a>高阶函数（满足下列条件之一就是高阶函数）</h4><p>a：把一个函数名当作形参传给另一个函数(在不修改被装饰函数源代码的情况下修改其功能,但是调用方式变了)</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def bar():    print('this is bar...')bar()print('----------------------------------')def test(func): #在这里增加了功能    print(func)test(bar)  #但是这里修改了调用方式</pre></div><p>b：返回值中包含函数名(不修改函数的调用方式,而修改函数功能)</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">def bar():    print('this is bar...')bar()print('----------------------------------')def test(func):   #在这里增加了功能    print(func)    return func        #这里返回了函数地址bar = test(bar)   #将函数地址赋给一个变量,该变量和传入函数同名bar()        #这个变量加上括号,就可以当函数用了,同时又没有修改函数的调用方式</pre></div><p>&nbsp;</p><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">x = 1def test1():    def test2():        def test3():            x = 3            print(x)        test3()    test2()test1()</pre></div><p>像这样在一个函数里面再定义一个函数就叫做嵌套函数。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义方式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre clas
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路4 - 文件操作&amp;编码转换</title>
    <link href="https://imzry.github.io/2017/09/19/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF4-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"/>
    <id>https://imzry.github.io/2017/09/19/Python学习之路4-文件操作-编码转换/</id>
    <published>2017-09-19T08:18:00.000Z</published>
    <updated>2019-07-27T08:18:40.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件操作大概分三步：</p><ol><li>把文件打开。</li><li>操作文件。</li><li>把文件关上。</li></ol><p>&nbsp;</p><p><strong>打开文件</strong></p><p>打开文件用open()函数，打开成功后返回一个资源，具体语法如下。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">open(要打开的文件,打开方式,打开文件的格式，默认为utf-8)#例如f = open('passengers.txt','r',encoding='utf-8')</pre></div><p>上例用open以只读的模式打开文件，因为该文本是utf-8编码的，所以第三个参数是utf-8</p><ul><li>w 模式是写入，是创建一个新文件的写，所以如果已经有了该文件就会被覆盖掉，注意安全!</li><li>a 模式是追加模式，可读；不存在则创建；存在则只追加内容；</li></ul><p>“+” 表示可以同时读写某个文件</p><ul><li>r+，可读写文件。【可读；可写；可追加】</li><li>w+，写读</li><li>a+，可读，可追加</li></ul><p>“U”表示在读取时，可以将 \r \n \r\n自动转换成 \n （与 r 或 r+ 模式同使用）</p><ul><li>rU</li><li>r+U</li></ul><p>“b”表示处理二进制文件（如：FTP发送上传ISO镜像文件，linux可忽略，windows处理二进制文件时需标注）</p><ul><li>rb #当加b时，就不用写encoding参数了</li><li>wb #用二进制打印出来的结果会包裹在 b’ 和 ‘ 中</li><li>ab</li></ul><p>&nbsp;</p><p><strong>读取文件</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">data = f.read() #然后用read读取文件，里面可以传参输入5就是读5个字符，不输入就是读所有字符    #读取所有内容，文件指针就移动到了文件末尾data = f.readline() #读取一行内容data = f.readlines() #将每一行变成一个元素，组成一个列表    #注意，readlines是将文件内容读取后放到内存里，所以它只能读小文件,不能读大文件</pre></div><p>下面是读取大文件最好的方式</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">for line in f:    print(line) #这是读取大文件最好的方式，每次只读一行到内存当中，读下一行的时候就会覆盖当前内存当中的数据</pre></div><p>&nbsp;</p><p><strong>写入文件</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">f.write('这里是写入的内容') #用write来写入内容print(f.tell()) #返回指针的位置f.seek(0) #移动指针的位置，0代表移动到第0个的位置上print(f.encoding) #打印文件的编码print(f.fileno()) #打印文件的编号print(f.name) #打印打开的文件名字print(f.seekable()) #判断文件是否可读print(f.writable()) #判断文件是否可写print(f.flush()) #强制刷新缓存print(f.closed) #判断文件是否关闭f.truncate(10) #从头开始截取10个字符</pre></div><p>&nbsp;</p><p><strong>关闭文件</strong></p><p>手动关闭文件用close()函数。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">f.close() #关闭文件</pre></div><p>自动关闭文件。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">with open() as f1:    pass    pass    # 资源只会在with里面打开，如果执行完毕则会自动关闭资源#并且可以用下面这种方式同时打开多个资源with open() as f1，open() as f2 ,\    open() as f3，open() as f4:    pass    pass</pre></div><p>&nbsp;</p><h6 id="下面是一个修改文件的案例"><a href="#下面是一个修改文件的案例" class="headerlink" title="########下面是一个修改文件的案例"></a>########下面是一个修改文件的案例</h6><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">f = open('passengers','r',encoding='utf-8')f_new = open('new','w',encoding='utf-8')for line in f:    if "漂浮在一片无奈" in line:        line = line.replace('漂浮在一片无奈','人类的渺小')  # replace函数在字符串操作文章中可见    f_new.write(line)f.close() </pre></div><p>　　其实就是将一个文件的内容在内存中修改完后写入到另一个文件中<br>　　因为Python中没有直接修改文件内容的方法。</p><p>&nbsp;</p><h6 id="修改文件的另一种方法"><a href="#修改文件的另一种方法" class="headerlink" title="#######修改文件的另一种方法"></a>#######修改文件的另一种方法</h6><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">file_data = ""with open(file，"r"，encoding="utf-8") as f:    for line in f:        if old_str in line:            line = line.replace(old_str,new_str)        file_data += linewith open(file,"w",encoding="utf-8") as f:    f.write(file_data)</pre></div><p>　　这种方法是先将所以的内容都读出来，并且再写到同一个文件中。</p><p>&nbsp;</p><h3 id="编码之间的转换"><a href="#编码之间的转换" class="headerlink" title="编码之间的转换"></a>编码之间的转换</h3><p><strong>需知：</strong><br>1.在python2默认编码是ASCII，python3里默认是unicode。<br>2.unicode 分为 utf-32(占4个字节),utf-16(占两个字节)，utf-8(占1-4个字节)，so utf-16就是现在最常用的unicode版本，不过在文件里存的还是utf-8，因为utf8省空间。<br>3.在py3中encode,在转码的同时还会把string 变成bytes类型，decode在解码的同时还会把bytes变回string。</p><p>原理图：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170919165527868-620629636.png" alt></p><p>&nbsp;</p><p>utf-8转gbk：<br>    我需要先用decode()解码成为Unicode，然后再用encode()转换成gbk<br>    decode()函数传入一个参数，参数为我当前的编码是什么，或者说我要将什么编码转换成Unicode;<br>    encode()函数传入一个参数，参数为我要转换成什么编码<br>        如果不传参则默认是utf-8<br>gbk转utf-8也是同理</p><p>也就是说Unicode作为中间编码，用来完成utf-8和gbk之间的转换。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">str = '你好' #假设当前为utf-8   注意:Python3里面的默认编码为Unicodestr = str.decode('utf-8') #将utf-8转换为Unicodestr = str.encode('gbk') #将Unicode转换为gbkprint(str)</pre></div><p>如果该文件为gbk，同时Python3的默认编码又是Unicode，则需要告诉程序不要按照默认的编码去执行，要按照gbk的编码去执行，这时就要在文件最顶端声明文件编码格式如下：</p><h1 id="coding-gbk"><a href="#coding-gbk" class="headerlink" title="-- coding:gbk --"></a>-<em>- coding:gbk -</em>-</h1><p>Python3默认是Unicode,而文件又是utf-8类型,两个编码不统一输入中文还不会乱码是因为utf-8是Unicode的一个扩展集,所以Python3默认支持中文不乱码。</p><p>在Python3中执行了encode()后，除了将编码改变了之外，还将它变为byte类型。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件操作&quot;&gt;&lt;a href=&quot;#文件操作&quot; class=&quot;headerlink&quot; title=&quot;文件操作&quot;&gt;&lt;/a&gt;文件操作&lt;/h3&gt;&lt;p&gt;文件操作大概分三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把文件打开。&lt;/li&gt;
&lt;li&gt;操作文件。&lt;/li&gt;
&lt;li&gt;把文件关上。&lt;
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路3 - 字符串操作&amp;字典</title>
    <link href="https://imzry.github.io/2017/09/19/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-%E5%AD%97%E5%85%B8/"/>
    <id>https://imzry.github.io/2017/09/19/Python学习之路3-字符串操作-字典/</id>
    <published>2017-09-19T07:19:00.000Z</published>
    <updated>2019-07-27T08:18:36.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本节内容："><a href="#本节内容：" class="headerlink" title="本节内容："></a><strong>本节内容：</strong></h3><ul><li>常用的字符串处理。</li><li>格式化输出字符串。</li><li>字符串的替换。</li><li>字符串和二进制的相互转化。</li><li>字典的操作</li></ul><hr><h3 id="字符串操作-nbsp"><a href="#字符串操作-nbsp" class="headerlink" title="字符串操作&nbsp;"></a>字符串操作&nbsp;</h3><p><strong>常用的字符串处理</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = 'vector'print(name.capitalize()) # 首字母大写print(name.count('e')) # 判断字符e在字符串中有多少个print(name.center(50,'-')) # 一共打印50个字符,将vector放在中间,两边用-填充print(name.endswith('r')) # 判断字符串以什么结尾, 如果是以r结尾则返回trueprint(name.expandtabs(tabsize=10)) # 如果在字符串中加入\t,则在该位置上加入tabsize个空格print(name.find('ec')) # 找到e在字符串中的位置print(name.isalnum()) # 如果字符串里面只包含英文和数字, 则返回Trueprint(name.isalpha()) # 如果字符串里面是纯英文, 则返回Trueprint(name.isdecimal()) # 如果字符串是十进制数字, 则返回Trueprint(name.isdigit()) # 如果字符串是否为整数, 则返回Trueprint(name.isidentifier()) # 判断是否是一个合法的标识符(变量名), 合法则返回Trueprint(name.islower()) # 判断是否为小写, 是则返回Trueprint(name.isupper()) # 判断是否为大写, 是则返回Trueprint(name.isspace()) # 判断是否为空格, 是则返回Trueprint('My Name Is'.istitle()) # 判断是否为标题(首字符大写), 是则返回Trueprint('+'.join(['1','2','3'])) # 将列表里面的每个元素用'+'拼接起来print(name.ljust(50,"*")) # 如果字符串长度小于50, 则不够的在左侧用*补充print(name.rjust(50,"*")) # 如果字符串长度小于50, 则不够的在右侧用*补充print(name.lower()) # 将大写变成小写print(name.upper()) # 将小写变成大写print('\nvector'.lstrip()) # 去掉字符串左边的空格和回车print('vector\n'.rstrip()) # 去掉字符串右边的空格和回车print('\nvector\n'.strip()) # 去掉字符串两边的空格和回车print('name is a book'.rfind('a')) # 从右边开始找a,返回找到的位置print('name is a book'.split(' ')) # 将字符串按照空格为界分装成列表, 不写参数则分隔符默认为空格print('name is \na book'.splitlines()) # 将字符串根据换行符为界分装成列表print('name is a book'.swapcase()) # 大小写互换print('name is a book'.title()) # 将字符串变成标题(首字母大写)print('name'.zfill(50)) # 如果字符串不够50个,则在左边用0填充</pre></div><p><strong>格式化输出<strong>字符串</strong>&lt;/strong&gt;</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = 'vector {name} {age}'print(name.format(name = 'rev',age=123)) # 格式化字符串print(name.format_map({'name':'rev','age':123})) # 字典的形式格式化字符串</pre></div><p><strong>字符串替换</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">#先用maketrans设置替换规则, 然后用translate执行替换p = str.maketrans('asdfgn','123456') #第一个参数是被替换的字符,第二个参数是替换的字符print('name'.translate(p)) # 将规则p传入,打印出来的就是61me,因为n和a被6和1替换掉了print('name'.replace('n','b',1)) # 将n换成b,第三个参数表示替换几个,如果不写则默认全部替换</pre></div><p><strong>字符串和二进制的相互转化</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">msg = '我爱大延边日不落帝国'print(msg) # 字符串输出print(msg.encode(encoding='utf-8')) # 将字符串转换成二进制print(msg.encode(encoding='utf-8').decode(encoding='utf-8')) # 将二进制转换成字符串</pre></div>> <pre><span>encode参数表示之前是什么格式的，decode参数表示要转换成什么格式的。> 如果encode和decode不写参数，默认就是utf-8。</span></pre>&nbsp;### 字典字典一种key - value 的数据类型，使用就像我们上学用的字典，通过笔划、字母来查对应页的详细内容。字典的特性：*   dict是无序的*   key必须是唯一的,so 天生去重语法：<div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">info = {    'str1':'zhangsan',    'str2':'lisi',    'str3':'wangwu',    'str4':'zhaoliu'}</pre></div><p>&nbsp;</p><p>常见的字典操作：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">info = {    'str1':'zhangsan',    'str2':'lisi',    'str3':'wangwu',    'str4':'zhaoliu'}print(info) # 打印全部字典print(info['str2']) # 根据键名打印字典元素info['str1'] = 'yangzirui' # 这样就会修改值, 如果键名不存在则会直接创建del info['str2'] # 删除该元素info.pop('str2') # 这也是删除print(info.popitem()) # 随机删除一个, 并返回他的键值对print(info['str1']) # 打印数据, 如果键名不存在, 就会报错,不推荐用print(info.get('str2')) # 打印数据, 如果键名不存在, 则返回none, 推荐print('str1' in info) # 判断键名是否存在,存在打印true,否则打印falseaaa = info.setdefault('str5','liangsohohfefho') # 如果info里面有键为str5的,则直接返回对应的值;如果没有,则创建后返回对应的值a = {    'str1':'asdfsdfd',    1:2,    2:3}info.update(a) # 将字典a合并到info中,如果有交叉,则用a字典中的值info.items() # 将字典转成列表, 列表中的每个元素都由元组组成,每个元组又原字典的每个键值对组成c = dict.fromkeys([1,2,3],'test') # 创建一个新字典, 键为1,2,3, 值均为test, 如果不写值,则均为none;后面赋的值是三个键共有的, 所以改一个就全都改了</pre></div><p>&nbsp;</p><p>循环字典：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">info = {    'str1':'zhangsan',    'str2':'lisi',    'str3':'wangwu',    'str4':'zhaoliu'}#第一种循环方法for i in info:    print(i,info[i])# 这应该是最基本的循环了# 第二种循环方法for k,v in info.items():    print(k,v)# 这种循环方式的效率没有第一种循环效率高,因为这种需要将字典转换成列表</pre></div><p>输出结果：（两种循环方式均是这样）</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170919154347134-325374193.png" alt></p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;本节内容：&quot;&gt;&lt;a href=&quot;#本节内容：&quot; class=&quot;headerlink&quot; title=&quot;本节内容：&quot;&gt;&lt;/a&gt;&lt;strong&gt;本节内容：&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;常用的字符串处理。&lt;/li&gt;
&lt;li&gt;格式化输出字符串。&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路2 - 列表和元组</title>
    <link href="https://imzry.github.io/2017/09/05/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF2-%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"/>
    <id>https://imzry.github.io/2017/09/05/Python学习之路2-列表和元组/</id>
    <published>2017-09-05T09:52:00.000Z</published>
    <updated>2019-07-27T08:18:33.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>概念：Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><h3 id="列表的使用"><a href="#列表的使用" class="headerlink" title="列表的使用"></a>列表的使用</h3><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu'] //定义一个了列表print(names) //输出列表的所有内容print(names[0])  //输出列表的第0个内容//用索引来访问list中每一个位置的元素，记得索引是从`0`开始的。</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905161411976-212251094.png" alt></p><p>如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','vector']print(names[-1])</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905163324601-1365225265.png" alt></p><p>&nbsp;用<code>len()</code>函数可以获得list元素的个数。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','yangzirui']print(len(names))</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905163120257-1954413308.png" alt></p><p>&nbsp;当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引还可以是<code>len(classmates) - 1</code>。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>如果想取出中间一段连续的元素，则用name[1:3]的方式，这个参数是左闭右开的。也就是说从第1位取到第2位。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu']print(names[1:3])# 切片</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905161706054-48951916.png" alt></p><h4 id="跳着切片"><a href="#跳着切片" class="headerlink" title="跳着切片"></a>跳着切片</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu']</pre><pre class="brush:python;gutter:true;">print(names[0:-1:2]) # 从第0个到倒数第2个, 每两个元素取一个</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905162100976-1647489134.png" alt></p><h4 id="倒着切片"><a href="#倒着切片" class="headerlink" title="倒着切片"></a>倒着切片</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu']print(names[-3,-1]) # 这也是左闭右开的，表示从倒数第三个切到倒数第二个    # 如果想切到倒数第一个, 就这样写 name[-3:] 这样就表示从倒数第三个切到最后一个了</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905164446194-735979471.png" alt></p><h4 id="追加元素"><a href="#追加元素" class="headerlink" title="追加元素"></a>追加元素</h4><p>如果想在列表的最后面追加一个元素, 就用函数append(‘元素’)。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu']names.append('sunqi')print(names)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905164747804-1354263796.png" alt></p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>插在任意元素的前面, 用函数insert(2,’元素’)。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu']names.insert(1,'yangsan') # 插在下标为1的元素的前面print(names)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905165326804-259508697.png" alt></p><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu']names[2] = 'shenmegui'print(names)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905165458913-168542462.png" alt></p><h4 id="删除元素的三种方法"><a href="#删除元素的三种方法" class="headerlink" title="删除元素的三种方法"></a>删除元素的三种方法</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu']names.remove('shenmegui') # 根据内容删除del names[2] # 根据下标删除names.pop(2) # 如果输入下标,则效果=del names[2], 如果不输入下标,则默认删除最后一个元素</pre></div><h4 id="根据元素内容找到元素的下标"><a href="#根据元素内容找到元素的下标" class="headerlink" title="根据元素内容找到元素的下标"></a>根据元素内容找到元素的下标</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu']print(names.index('zhangsan')) //利用index函数将下标取出来# 还有一种方式是在循环的时候取出下标for i in enumerate(names):    print(i) # 这样取的时候就会有下标# 但是如果我想把下标分离出来, 该怎么处理for index,i in enumerate(names):    print(index,i) # 这样index里面就装了分离出来的下标</pre></div><h4 id="计算某个元素的个数"><a href="#计算某个元素的个数" class="headerlink" title="计算某个元素的个数"></a>计算某个元素的个数</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']print(names.count('zhangsan'))</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905170102757-354277705.png" alt></p><h4 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']names.clear()</pre></div><h4 id="翻转列表"><a href="#翻转列表" class="headerlink" title="翻转列表"></a>翻转列表</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']names.reverse()print(names)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905172935897-2059881759.png" alt></p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>规则是按照ASCII码表的顺序排的。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']names.sort()print(names)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905173517429-1260377597.png" alt></p><h4 id="追加合并"><a href="#追加合并" class="headerlink" title="追加合并"></a>追加合并</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']names2 = [1,2,3,4]names.extend(names2)print(names)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905173728429-935378387.png" alt></p><h4 id="浅拷贝列表"><a href="#浅拷贝列表" class="headerlink" title="浅拷贝列表"></a>浅拷贝列表</h4><p>这个第一维时是深拷贝，第二维开始是浅拷贝。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','wangwu','zhaoliu']names3 = names.copy() // 第一种方式p1 = names[:]　　　　　　// 第二种方式p2 = list(names)　　　　// 第三种方式</pre></div><h4 id="深拷贝-nbsp-需要引入copy模块"><a href="#深拷贝-nbsp-需要引入copy模块" class="headerlink" title="深拷贝 &nbsp;需要引入copy模块"></a>深拷贝 &nbsp;需要引入copy模块</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']import copynames2 = copy.copy(names)</pre></div><h4 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']for i in names:    print(i)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905174802788-288906094.png" alt></p><h4 id="判断一个元素是否在列表里"><a href="#判断一个元素是否在列表里" class="headerlink" title="判断一个元素是否在列表里"></a>判断一个元素是否在列表里</h4><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu']if 'zhangsan' in names:    print('存在')</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905175023226-332155191.png" alt></p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组就是只能查数据的列表。</p><p>定义格式：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">names = ('zhangsan','lisi')</pre></div><p>　　它只有两个方法, count 和 index。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h2&gt;&lt;p&gt;概念：Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。&lt;/p&gt;
&lt;h3 id=&quot;列表
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习之路1 - 基础入门</title>
    <link href="https://imzry.github.io/2017/09/04/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://imzry.github.io/2017/09/04/Python学习之路1-基础入门/</id>
    <published>2017-09-04T10:06:00.000Z</published>
    <updated>2019-07-27T08:18:26.653Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容</p><ol><li>Python介绍</li><li>安装Python解释器</li><li>输出</li><li>变量</li><li>输入</li><li>条件判断语句</li><li>循环语句</li><li>模块讲解</li><li>三元运算</li><li>字符串和二进制的相互转化</li></ol><hr><p>&nbsp;本系列文章使用的Python版本为3.6.2</p><p>使用开发工具为Pycharm2017</p><p>&nbsp;</p><h2 id="一、Python介绍"><a href="#一、Python介绍" class="headerlink" title="一、Python介绍"></a>一、Python介绍</h2><p>Python的创始人为吉多&middot;范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多&middot;范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。&nbsp;&nbsp;</p><div class="page" title="Page 1">最新的TIOBE排行榜，Python赶超PHP占据第五，&nbsp;Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830190706483-1713022637.png)**目前Python主要应用领域：***   **云计算：**云计算最火的语言， 典型应用OpenStack*   **WEB开发：**众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣。。。， 典型WEB框架有Django*   **科学运算、人工智能：**典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas*   **系统运维：**运维人员必备语言*   **金融**：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java,尤其擅长策略回测*   **图形GUI：**PyQT, WxPython,TkInter**Python在一些公司的应用：***   谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发*   CIA：美国中情局网站就是用Python开发的*   NASA：美国航天局(NASA)大量使用Python进行数据分析和运算*   YouTube：世界上最大的视频网站YouTube就是用Python开发的*   Dropbox：美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载*   Instagram：美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发*   Facebook：大量的基础库均通过Python实现的*   Redhat：世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的*   豆瓣：公司几乎所有的业务均是通过Python开发的*   知乎：国内最大的问答社区，通过Python开发(国外Quora)*   春雨医生：国内知名的在线医疗网站是用Python开发的*   除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。&nbsp;### **Python&nbsp;****是一门什么样的语言？**<span style="color: #ff0000;">编程语言主要从以下几个角度为进行分类，编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言，每个分类代表什么意思呢，我们一起来看一下。</span>#### 编译和解释的区别编译器是把源程序的每一条语句都编译成机器语言，并保存成二进制文件，这样运行时计算机可以直接以机器语言来运行此程序，速度很快；&nbsp;而解释器则是只在执行程序时，才一条一条的解释成机器语言给计算机来执行，所以运行速度是不如编译后的程序运行的快的。&nbsp;这是因为计算机不能直接认识并执行我们写的语句，它只能认识机器语言(是二进制的形式)。就好像你想看一本英文书，编译器会将整本书翻译成中文供你观看，这时你看的就会很方便，怎么反复看都没有问题；解释器只会解释你当前想要看的语句，如果你想再次看一遍同样的语句则需要再次找解释器解释一遍，这样就会给你的阅读带来麻烦。&nbsp;**动态语言和静态语言**通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。（1）动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。（2）静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。&nbsp;**强类型定义语言和弱类型定义语言**（1）强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。（2）弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，&ldquo;这门语言是不是动态语言&rdquo;与&ldquo;这门语言是否类型安全&rdquo;之间是完全没有联系的！例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。&nbsp;通过上面这些介绍，我们可以得出，python是一门动态解释性的强类型定义语言。那这些基因使成就了Python的哪些优缺点呢？我们继续往下看。&nbsp;**Python的优点**当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作&ldquo;内置电池（batteries included）&rdquo;。用Python开发，许多功能不必从零编写，直接使用现成的即可。除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。龟叔给Python的定位是&ldquo;优雅&rdquo;、&ldquo;明确&rdquo;、&ldquo;简单&rdquo;，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。那Python适合开发哪些类型的应用呢？首选是网络应用，包括网站、后台服务等等；其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；另外就是把其他语言开发的程序再包装起来，方便使用。**Python的缺点**第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830172927483-1736869329.png)第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。再说了，现在如火如荼的开源运动和互联网自由开放的精神是一致的，互联网上有无数非常优秀的像Linux一样的开源代码，我们千万不要高估自己写的代码真的有非常大的&ldquo;商业价值&rdquo;。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了，一旦开源，就没人敢用他们的产品了。&nbsp;![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830172946187-1723418191.png)&nbsp;## 二、安装Python解释器### 在Mac上安装Python如果你正在使用Mac，系统是OS X 10.8~10.10，那么系统自带的Python版本是2.7。要安装最新的Python 3.6，有两个方法：方法一：从Python官网下载Python 3.6的安装程序（网速慢的同学请移步国内镜像），双击运行并安装；方法二：如果安装了Homebrew，直接通过命令`brew install python3`安装即可。### 在Linux上安装Python如果你正在使用Linux，那么基本代表你有着Linux管理经验，Linux上自带Python2，如果想升级到最新版应该难不倒你的。### 在Windows上安装Python首先，根据你的Windows版本（64位还是32位）从Python的官方网站下载Python 3.6对应的64位安装程序或32位安装程序，然后，运行下载的EXE安装包：![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830175523671-794653867.png)&nbsp;特别要注意勾上`Add Python 3.6 to PATH`，然后点&ldquo;Install Now&rdquo;即可完成安装。&nbsp;</div><h2 id="三、输出"><a href="#三、输出" class="headerlink" title="三、输出"></a><span style="background-color: #ffffff;">三、输出</span></h2><p>输出方式经常使用的有两种，第一种是print()函数，下面我们输出hello world。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">print("hello world")</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830162914515-1283240545.png" alt></p><p>第二种输出方式需要引入sys库，然后使用sys.stdout.write()函数输出。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import syssys.stdout.write("afsd")</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830163223452-1631258494.png" alt></p><blockquote><p>从输出结果可以看出两种输出方式的差别，print()函数输出结果后会再加一个换行，而sys.stdout.write()则没有换行。</p></blockquote><p>&nbsp;Python和其他常用高级语言不同的地方是Python一条语句结束时不需要加分号，并且在Python中也不会用到大括号，Python的语句就只是用换行符和缩进来表示语句之间的关系。</p><p>换行就表示一条语句的结束，缩进表示语句间的包含关系。</p><h2 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h2><p>由于Python是动态类型语言，所以不需要定义变量类型，直接写变量名就可以。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = "my name is Vector"print(name)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830175954671-7016819.png" alt></p><blockquote><p>在Python3中是可以直接输入中文的，例如print（&ldquo;姓名&rdquo;）这样，但是在Python2中需要在文件的顶部加上 &nbsp;-<em>- coding:utf-8 -</em>- 这句话，因为Python3的默认字符为Unicode，而Python2的默认字符为ASCII。</p></blockquote><p>&nbsp;在Python中不仅有单行的字符串，还有多行的字符串，多行字符串用 ‘’’内容’’’ 标记，如下。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">msg = '''这里是第一行这里是第二行这里是第三行'''print(msg)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830180752015-1420839021.png" alt></p><p>&nbsp;</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Python中的单行注释用 # 来注释，如下。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">print('hello world') #这里即将输出hello world</pre></div><p>多行注释用三个单引号来标记 ‘’’内容’’’，如下。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">'''这里是第一行注释这里是第二行注释这里是第三行注释'''</pre></div><p>在Python中单引号和双引号没有区别，都不会转义其他字符。</p><p>&nbsp;</p><h2 id="五、输入"><a href="#五、输入" class="headerlink" title="五、输入"></a>五、输入</h2><p>&nbsp;用户输入通常我们用input()函数，如下。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">username = input('username:')password = input('password:')print(username,password)</pre></div><p>我们输入vector和asd123</p><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830181933421-889670116.png" alt></p><p>有了输入后，我们就可以控制格式化输出了。</p><h3 id="第一种格式化输出方式"><a href="#第一种格式化输出方式" class="headerlink" title="第一种格式化输出方式"></a><strong>第一种格式化输出方式</strong></h3><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = input('name:')age = input('age:')info = '''------------- Info --------------Name:''' + name + '''age:''' + age + '''------------- Over --------------'''print(info)</pre></div><p>这里我们输入vector和18</p><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830183857624-1962918674.png" alt></p><h3 id="第二种格式化输出方式"><a href="#第二种格式化输出方式" class="headerlink" title="第二种格式化输出方式"></a>第二种格式化输出方式</h3><p>用 %s %d %f 等来控制格式，并在结尾一次传入参数，传参格式为 %(参数1,参数2,…)</p><p>&nbsp;%s代表字符串，%d代表正数，%f代表浮点数。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = input('name:')age = int(input('age:'))info = '''------------- Info --------------Name:%sage:%d------------- Over --------------'''%(name,age)print(info)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830184550749-426232156.png" alt></p><div class="cnblogs_code"><pre>如果想将输出的内容变成红色,则用\033[31;1m%s\033<span style="color: #000000;">[0m如果想将输出的内容变成绿色,则用\</span>033[32;1m%s\033<span style="color: #000000;">[0m格式：\</span>033<span style="color: #000000;">[显示方式;前景色;背景色m说明：前景色            背景色           颜色</span>---------------------------------------30                40<span style="color: #000000;">              黑色</span>31                41<span style="color: #000000;">              红色</span>32                42<span style="color: #000000;">              绿色</span>33                43<span style="color: #000000;">              黃色</span>34                44<span style="color: #000000;">              蓝色</span>35                45<span style="color: #000000;">              紫红色</span>36                46<span style="color: #000000;">              青蓝色</span>37                47<span style="color: #000000;">              白色显示方式           意义</span>-------------------------<span style="color: #000000;">0                终端默认设置</span>1<span style="color: #000000;">                高亮显示</span>4<span style="color: #000000;">                使用下划线</span>5<span style="color: #000000;">                闪烁</span>7<span style="color: #000000;">                反白显示</span>8<span style="color: #000000;">                不可见例子：\</span>033[1;31;40m    &lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&gt;<span style="color: #000000;">\</span>033[0m          &lt;!--采用终端默认设置，即取消颜色设置--&gt;</pre></div><p>下面演示一下输出结果带颜色的例子：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = input('name:')age = int(input('age:'))info = '''------------- Info --------------Name:\033[31;1m%s\033[0m  #输出结果为红色age:\033[32;1m%s\033[0m  #输出结果为绿色------------- Over --------------'''%(name,age)print(info)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830190045124-537519902.png" alt></p><h3 id="第三种格式化输出方式"><a href="#第三种格式化输出方式" class="headerlink" title="第三种格式化输出方式"></a>第三种格式化输出方式</h3><p>在字符串中插入形参（形参用大括号标记{形参}），最后在结尾给形参赋值。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = input('name:')age = int(input('age:'))info = '''------------- Info --------------Name:{_name}age:{_age}------------- Over --------------'''.format(_name=name,_age=age)print(info)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830185538155-940502342.png" alt></p><h3 id="第四种格式化输出方式"><a href="#第四种格式化输出方式" class="headerlink" title="第四种格式化输出方式"></a>第四种格式化输出方式</h3><p>形参用数字表示，在结尾直接按照顺序给形参赋值。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">name = input('name:')age = int(input('age:'))info = '''------------- Info --------------Name:{0}age:{1}------------- Over --------------'''.format(name,age)print(info)</pre></div><p>输出结果：</p><p><img src="http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830185711202-1001486243.png" alt></p><p>&nbsp;</p><h3 id="输入变成密文"><a href="#输入变成密文" class="headerlink" title="输入变成密文"></a>输入变成密文</h3><p>需要引入getpass模块。</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">import getpasspassword = getpass.getpass("password:")</pre><pre>print(password)</pre></div><pre>但是这个getpass()这个函数在pycharm中不好使，在其他工具中好使。</pre>## 六、条件判断语句格式：<div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">if 条件1 and 条件2 or 条件3:    pass # 注意这里一定要有缩进elif 条件4 and 条件5:    passelse:    pass</pre></div><p>例子：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">_username = 'rev'_password = 'rev123'username = input('username:')password = input('password:')if _username == username and _password == password:    print('Welcome user {name} login...'.format(name = username))# 注意这里一定要有缩进elif _username == username and _password != password:    print('password error!')else:    print('login fail..')# 注意这里一定要有缩进</pre></div><h2 id="七、循环语句"><a href="#七、循环语句" class="headerlink" title="七、循环语句"></a>七、循环语句</h2><h3 id="循环语句之while"><a href="#循环语句之while" class="headerlink" title="循环语句之while"></a>循环语句之while</h3><p>Python中的while还有else处理。</p><p>例子：</p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">while True:    print('this is loop...')    breakelse:    print('如果while循环条件不符合了，则执行这里的代码')</pre></div><h3 id="循环语句之for"><a href="#循环语句之for" class="headerlink" title="循环语句之for"></a>循环语句之for</h3><p><strong>格式1：</strong></p><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">for i in range(10):    print('loop ',i)</pre></div>> 这里的range代表循环次数，i 从0来是循环输出结果：![](http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905151712335-219987765.png)**格式2：**<div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">for i in range(0,10,2):    print('loop ',i)</pre></div>> range中的第一个参数代表从几开始，第二个参数代表到几结束（不包括10），第三个参数2代表隔一个执行一次**格式3：**<div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">for i in "fasdfasd":    print('loop ',i)</pre></div>> Python中的for循环还可以循环字符串、列表、元组等。&nbsp;输出结果：![](http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905152420554-1608007279.png)## 八、模块讲解### 模块之sys<div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">print(sys.path) # 打印环境变量print(sys.argv) # 打印当前脚本的路径，在pycharm中打印绝对路径，在命令行中打印相对路径（本来打印的就是相对路径）one = sys.argv[1] #用来在外部调用的时候传参, 1代表传入的第一个参数,two = sys.argv[2] #2代表传入的第二个参数, 这样外部调用的时候就可以传多个参数了</pre></div><h3 id="模块之os"><a href="#模块之os" class="headerlink" title="模块之os"></a>模块之os</h3><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">print(os.system('dir')) # system函数就是命令行cmd = os.system('dir')print(cmd) # 这里输出的是 0 因为，system是直接把输出到屏幕上，并不是返回，如果输出成功则返回0cmd = os.popen('dir').read() #popen()方法返回的是该对象的地址，read()方法是将地址中的内容读出来print(cmd)# 创建目录函数os.mkdir('new_dir')</pre></div><h2 id="九、三元运算"><a href="#九、三元运算" class="headerlink" title="九、三元运算"></a>九、三元运算</h2><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">//result = 值1 if 条件 else 值2a,b,c = 1,3,5d = a if a&gt;b else cprint(d) # d = c = 5# 如果条件为真：result = 值1# 如果条件为假：result = 值2</pre></div><h2 id="十、字符串和二进制的相互转化"><a href="#十、字符串和二进制的相互转化" class="headerlink" title="十、字符串和二进制的相互转化"></a>十、字符串和二进制的相互转化</h2><div class="cnblogs_Highlighter"><pre class="brush:python;gutter:true;">msg = '我爱大延边日不落帝国'print(msg) # 字符串输出print(msg.encode(encoding='utf-8')) # 将字符串转换成二进制print(msg.encode(encoding='utf-8').decode(encoding='utf-8')) # 将二进制转换成字符串# 如果encode和decode不写参数，默认就是utf-8</pre></div><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python介绍&lt;/li&gt;
&lt;li&gt;安装Python解释器&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;li&gt;条件判断语句&lt;/li&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;li&gt;模块讲解&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="Python" scheme="https://imzry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>thinkphp简洁、美观、靠谱的分页类</title>
    <link href="https://imzry.github.io/2017/09/04/thinkphp%E7%AE%80%E6%B4%81%E3%80%81%E7%BE%8E%E8%A7%82%E3%80%81%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%88%86%E9%A1%B5%E7%B1%BB/"/>
    <id>https://imzry.github.io/2017/09/04/thinkphp简洁、美观、靠谱的分页类/</id>
    <published>2017-09-04T10:02:00.000Z</published>
    <updated>2019-07-27T08:19:20.577Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说先上图预览下；即本博客的分页；</p><p><img src="http://baijunyao.com/Upload/image/ueditor/20150510/1431271676192112.png" alt="白俊遥博客" title="白俊遥博客"></p><p>这个分页类是在thinkphp框架内置的分页类的基础上修改而来；</p><p>原分页类的一些设计，在实际运用中感觉不是很方便；</p><p>1：只有一页内容时不显示分页；</p><p>2：原分页类在当前页是第一页和最后一页的时候，不显示第一页和最后一页的按钮；</p><p><img src="http://baijunyao.com/Upload/image/ueditor/20150510/1431271881336609.png" alt="白俊遥博客" title="白俊遥博客"></p><p>3：分页数比较少时不显示首页和末页按钮；</p><p>4：包裹分页内容的父级div没有class；</p><p>&nbsp;</p><p>针对以上问题逐一进行了修改成如下；</p><p>1：如果没有数据不显示分页，如果有一页及以上内容即显示分页；</p><p>2：默认就显示第一页和最后一页按钮，但是在当前页是第一页和最后一页的时候按钮点击无效果；</p><p>3：默认就显示首页和末页按钮；</p><p>4：为包裹分页内容的父级div添加名为page的class；</p><p>5：显示总共查出的内容条数；</p><p>&nbsp;</p><p>示例环境：thinkphp3.2.3；</p><p>分页类目录：/Thinkphp/Library/Org/Bjy/Page.class.PHP</p><p>分页类代码如下：</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">&lt;?php  // +----------------------------------------------------------------------  // | ThinkPHP [ WE CAN DO IT JUST THINK IT ]  // +----------------------------------------------------------------------  // | Copyright (c) 2006-2014 http://thinkphp.cn All rights reserved.  // +----------------------------------------------------------------------  // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )  // +----------------------------------------------------------------------  // | Author: 麦当苗儿 &lt;zuojiazi@vip.qq.com&gt; &lt;http://www.zjzit.cn&gt;  // +----------------------------------------------------------------------  /*  * PHP分页类  * 修改者：白俊遥  * 日  期：2015.5.10  * 邮  箱：baijunyao@baijunyao.com  * 博  客：http://baijunyao.com  */  namespace Org\Bjy;  class Page{      public $firstRow; // 起始行数      public $listRows; // 列表每页显示行数      public $parameter; // 分页跳转时要带的参数      public $totalRows; // 总行数      public $totalPages; // 分页总页面数      public $rollPage   = 5;// 分页栏每页显示的页数      public $lastSuffix = true; // 最后一页是否显示总页数      private $p       = 'p'; //分页参数名      private $url     = ''; //当前链接URL      private $nowPage = 1;      // 分页显示定制      private $config  = array(          'header' =&gt; '&lt;span class="rows"&gt;共 %TOTAL_ROW% 条记录&lt;/span&gt;',          'first'   =&gt; '首页',          'prev'   =&gt; '上一页',          'next'   =&gt; '下一页',          'last'   =&gt; '末页',          'theme'  =&gt; '%FIRST% %UP_PAGE% %LINK_PAGE% %DOWN_PAGE% %END% %HEADER%',      );      /**      * 架构函数      * @param array $totalRows  总的记录数      * @param array $listRows  每页显示记录数      * @param array $parameter  分页跳转的参数      */      public function __construct($totalRows, $listRows=20, $parameter = array()) {          C('VAR_PAGE') &amp;&amp; $this-&gt;p = C('VAR_PAGE'); //设置分页参数名称          /* 基础设置 */          $this-&gt;totalRows  = $totalRows; //设置总记录数          $this-&gt;listRows   = $listRows;  //设置每页显示行数          $this-&gt;parameter  = empty($parameter) ? $_GET : $parameter;          $this-&gt;nowPage    = empty($_GET[$this-&gt;p]) ? 1 : intval($_GET[$this-&gt;p]);          $this-&gt;nowPage    = $this-&gt;nowPage&gt;0 ? $this-&gt;nowPage : 1;          $this-&gt;firstRow   = $this-&gt;listRows * ($this-&gt;nowPage - 1);      }      /**      * 定制分页链接设置      * @param string $name  设置名称      * @param string $value 设置值      */      public function setConfig($name,$value) {          if(isset($this-&gt;config[$name])) {              $this-&gt;config[$name] = $value;          }      }      /**      * 生成链接URL      * @param  integer $page 页码      * @return string      */      private function url($page){          return str_replace(urlencode('[PAGE]'), $page, $this-&gt;url);      }      /**      * 组装分页链接      * @return string      */      public function show() {          if(0 == $this-&gt;totalRows) return '';          /* 生成URL */          $this-&gt;parameter[$this-&gt;p] = '[PAGE]';          $this-&gt;url = U(MODULE_NAME.'/'.CONTROLLER_NAME.'/'.ACTION_NAME, $this-&gt;parameter);          /* 计算分页信息 */          $this-&gt;totalPages = ceil($this-&gt;totalRows / $this-&gt;listRows); //总页数          if(!empty($this-&gt;totalPages) &amp;&amp; $this-&gt;nowPage &gt; $this-&gt;totalPages) {              $this-&gt;nowPage = $this-&gt;totalPages;          }          /* 计算分页零时变量 */          $now_cool_page      = $this-&gt;rollPage/2;          $now_cool_page_ceil = ceil($now_cool_page);          //上一页          $up_row  = $this-&gt;nowPage - 1;          $up_page = $up_row &gt; 0 ? '&lt;a class="prev" href="' . $this-&gt;url($up_row) . '"&gt;' . $this-&gt;config['prev'] . '&lt;/a&gt;' : '&lt;a class="prev not-allowed" href="javascript:;"&gt;' . $this-&gt;config['prev'] . '&lt;/a&gt;';          //下一页          $down_row  = $this-&gt;nowPage + 1;          $down_page = ($down_row &lt;= $this-&gt;totalPages) ? '&lt;a class="next" href="' . $this-&gt;url($down_row) . '"&gt;' . $this-&gt;config['next'] . '&lt;/a&gt;' : '&lt;a class="next not-allowed" href="javascript:;"&gt;' . $this-&gt;config['next'] . '&lt;/a&gt;';          //第一页          $the_first = '&lt;a class="first" href="' . $this-&gt;url(1) . '"&gt;' . $this-&gt;config['first'] . '&lt;/a&gt;';          //最后一页          $the_end = '&lt;a class="end" href="' . $this-&gt;url($this-&gt;totalPages) . '"&gt;' . $this-&gt;config['last'] . '&lt;/a&gt;';          //数字连接          $link_page = "";          for($i = 1; $i &lt;= $this-&gt;rollPage; $i++){              if(($this-&gt;nowPage - $now_cool_page) &lt;= 0 ){                  $page = $i;              }elseif(($this-&gt;nowPage + $now_cool_page - 1) &gt;= $this-&gt;totalPages){                  $page = $this-&gt;totalPages - $this-&gt;rollPage + $i;              }else{                  $page = $this-&gt;nowPage - $now_cool_page_ceil + $i;              }              if ($page&gt;0) {                  if($page != $this-&gt;nowPage){                      if($page &lt;= $this-&gt;totalPages){                          $link_page .= '&lt;a class="num" href="' . $this-&gt;url($page) . '"&gt;' . $page . '&lt;/a&gt;';                      }else{                          break;                      }                  }else{                      $link_page .= '&lt;span class="current"&gt;' . $page . '&lt;/span&gt;';                  }                              }          }          //替换分页内容          $page_str = str_replace(              array('%HEADER%', '%NOW_PAGE%', '%UP_PAGE%', '%DOWN_PAGE%', '%FIRST%', '%LINK_PAGE%', '%END%', '%TOTAL_ROW%', '%TOTAL_PAGE%'),              array($this-&gt;config['header'], $this-&gt;nowPage, $up_page, $down_page, $the_first, $link_page, $the_end, $this-&gt;totalRows, $this-&gt;totalPages),              $this-&gt;config['theme']);          return '&lt;div class="page"&gt;'.$page_str.'&lt;/div&gt;';      }  }</pre></div><p>分页类调用：</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">$count=$this-&gt;where($where)-&gt;count();  $page=new \Org\Bjy\Page($count,$limit);  $list=$this-&gt;where($where)-&gt;order('addtime desc')-&gt;limit($page-&gt;firstRow.','.$page-&gt;listRows)-&gt;select();  $show=$page-&gt;show();  </pre></div><p>分页类css</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">.b-page {    background: #fff;    box-shadow: 0px 1px 2px 0px #E2E2E2;  }  .page {    width: 100%;    padding: 30px 15px;    background: #FFF;    text-align: center;    overflow: hidden;  }  .page .first,  .page .prev,  .page .current,  .page .num,  .page .current,  .page .next,  .page .end {    padding: 8px 16px;    margin: 0px 5px;    display: inline-block;    color: #008CBA;    border: 1px solid #F2F2F2;    border-radius: 5px;  }  .page .first:hover,  .page .prev:hover,  .page .current:hover,  .page .num:hover,  .page .current:hover,  .page .next:hover,  .page .end:hover {    text-decoration: none;    background: #F8F5F5;  }  .page .current {    background-color: #008CBA;    color: #FFF;    border-radius: 5px;    border: 1px solid #008CBA;  }  .page .current:hover {    text-decoration: none;    background: #008CBA;  }  .page .not-allowed {    cursor: not-allowed;  }</pre></div><p>分页类的使用方法和原thinkphp相同。</p><p>本文为白俊遥原创文章 , 原文来自白俊遥博客<a href="http://baijunyao.com" target="_blank" rel="noopener">http://baijunyao.com</a></p><p>&nbsp;</p><div class="dp-highlighter bg_php">&nbsp;</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不多说先上图预览下；即本博客的分页；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://baijunyao.com/Upload/image/ueditor/20150510/1431271676192112.png&quot; alt=&quot;白俊遥博客&quot; title=&quot;白俊遥博客&quot;&gt;
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="PHP" scheme="https://imzry.github.io/tags/PHP/"/>
    
      <category term="thinkphp" scheme="https://imzry.github.io/tags/thinkphp/"/>
    
  </entry>
  
  <entry>
    <title>PHPCMS v9表单向导中怎么加入验证码</title>
    <link href="https://imzry.github.io/2017/09/04/PHPCMS-v9%E8%A1%A8%E5%8D%95%E5%90%91%E5%AF%BC%E4%B8%AD%E6%80%8E%E4%B9%88%E5%8A%A0%E5%85%A5%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://imzry.github.io/2017/09/04/PHPCMS-v9表单向导中怎么加入验证码/</id>
    <published>2017-09-04T09:58:00.000Z</published>
    <updated>2019-07-27T08:18:11.250Z</updated>
    
    <content type="html"><![CDATA[<p>表单想到比较简单，所以没有加入验证码的功能。网上的类似教程又大多数不准确。所以亲自<a href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库" target="_blank" rel="noopener">测试</a>了一下，发现下面的方法是可用的。希望对有需求的朋友们有所帮助。</p><p>1.首先是调用表单的页面加入验证码。表单<a href="http://lib.csdn.net/base/javascript" title="JavaScript知识库" target="_blank" rel="noopener">js</a>调用模版默认的是 \phpcms\templates\default\formguide\show_js.html.</p><p>在该文件里面找到这行代码，大概在23行</p><div class="cnblogs_Highlighter"><pre class="brush:html;gutter:true;">&lt;tr&gt;      &lt;th width="80"&gt;{if $info['star']} &lt;font color="red"&gt;*&lt;/font&gt;{/if} {$info['name']}      &lt;/th&gt;      &lt;td&gt;{$info['form']}  {$info['tips']}&lt;/td&gt;    &lt;/tr&gt;{/loop}</pre></div><p>在下面加入一行代码。</p><div class="cnblogs_Highlighter"><pre class="brush:html;gutter:true;">&lt;tr&gt;    &lt;td style="text-align:right;"&gt;验证码&lt;/td&gt;    &lt;td colspan="2"&gt;        &lt;span title="点击更换验证码" style=" cursor:pointer;"&gt;        &lt;input type="text" id="code" name="code" size="8" class="input-text"&gt;        请输入图片中的验证码    &lt;/td&gt;&lt;/tr&gt;</pre></div><p>2.找到这个文件 \phpcms\modules\formguide\index.PHP</p><p>这个需要修改两处</p><p>1）在第三行找到这行代码。</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">defined('IN_PHPCMS') or exit('No permission resources.');define('CACHE_MODEL_PATH',PHPCMS_PATH.'caches'.DIRECTORY_SEPARATOR.'caches_model'.DIRECTORY_SEPARATOR.'caches_data'.DIRECTORY_SEPARATOR);</pre></div><p>然后在后面加入下面两行代码</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">$session_storage = 'session_'.pc_base::load_config('system','session_storage');pc_base::load_sys_class($session_storage);</pre></div><p>2）找到下面这行代码</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">if (isset($_POST['dosubmit'])) {$tablename = 'form_'.$r['tablename'];$this-&gt;m_db-&gt;change_table($tablename);</pre></div><p>然后在下面加入下面这段代码</p><div class="cnblogs_Highlighter"><pre class="brush:php;gutter:true;">if(!empty($_SESSION['code'])) {    //判断验证码    $code = isset($_POST['code']) &amp;&amp; trim($_POST['code']) ? trim($_POST['code']) : showmessage(L('input_code'), HTTP_REFERER);    if ($_SESSION['code'] != strtolower($code)) {        showmessage(L('code_error'), HTTP_REFERER);    }}</pre></div><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;表单想到比较简单，所以没有加入验证码的功能。网上的类似教程又大多数不准确。所以亲自&lt;a href=&quot;http://lib.csdn.net/base/softwaretest&quot; title=&quot;软件测试知识库&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="PHP" scheme="https://imzry.github.io/tags/PHP/"/>
    
      <category term="PHPCMS" scheme="https://imzry.github.io/tags/PHPCMS/"/>
    
  </entry>
  
  <entry>
    <title>C语言函数调用约定</title>
    <link href="https://imzry.github.io/2017/09/04/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <id>https://imzry.github.io/2017/09/04/C语言函数调用约定/</id>
    <published>2017-09-04T09:54:00.000Z</published>
    <updated>2019-07-27T08:24:16.157Z</updated>
    
    <content type="html"><![CDATA[<p>在C语言中，假设我们有这样的一个函数：</p><p><code>int function(int a,int b)</code></p><p>调用时只要用<code>result = function(1,2)</code>这样的方式就可以使用这个函数。但是，当高级语言被编译成计算机可以识别的机器码时，有一个问题就凸现出来：在CPU中，计算机没有办法知道一个函数调用需要多少个、什么样的参数，也没有硬件可以保存这些参数。也就是说，计算机不知道怎么给这个函数传递参数，传递参数的工作必须由函数调用者和函数本身来协调。为此，计算机提供了一种被称为栈的数据结构来支持参数传递。</p><p>栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入数据，这个操作被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修改。用户也可以从堆栈中取走栈顶，称为弹出栈(pop)，弹出栈后，栈顶下的一个元素变成栈顶，栈顶指针随之修改。</p><p>函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈恢复原装。</p><p>在参数传递中，有两个很重要的问题必须得到明确说明：</p><p>当参数个数多于一个时，按照什么顺序把参数压入堆栈。<br>函数调用后，由谁来把堆栈恢复原装。<br>在高级语言中，通过函数调用约定来说明这两个问题。常见的调用约定有：</p><p>stdcall<br>cdecl<br>fastcall<br>thiscall<br>naked call<br>stdcall调用约定<br>stdcall很多时候被称为pascal调用约定，因为pascal是早期很常见的一种教学用计算机程序设计语言，其语法严谨，使用的函数调用约定就是stdcall。在Microsoft C++系列的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。</p><p>stdcall调用约定声明的语法为(以前文的那个函数为例）：</p><p><code>int __stdcall function(int a,int b)</code></p><p>stdcall的调用约定意味着：1）参数从右向左压入堆栈，2）函数自身修改堆栈 3)函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸。</p><p>以上述这个函数为例，参数b首先被压栈，然后是参数a，函数调用function(1,2)调用处翻译成汇编语言将变成：</p><p>push 2 第二个参数入栈<br>push 1 第一个参数入栈<br>call function 调用参数，注意此时自动把cs:eip入栈</p><p>而对于函数自身，则可以翻译为：</p><p>push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复mov ebp,esp 保存堆栈指针mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a<br>add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b<br>mov esp,ebp 恢复esp<br>pop ebp<br>ret 8</p><p>而在编译时，这个函数的名字被翻译成_function@8</p><p>注意不同编译器会插入自己的汇编代码以提供编译的通用性，但是大体代码如此。其中在函数开始处保留esp到ebp中，在函数结束恢复是编译器常用的方法。</p><p>从函数调用看，2和1依次被push进堆栈，而在函数中又通过相对于ebp(即刚进函数时的堆栈指针）的偏移量存取参数。函数结束后，ret 8表示清理8个字节的堆栈，函数自己恢复了堆栈。</p><p>cdecl调用约定<br>cdecl调用约定又称为C调用约定，是C语言缺省的调用约定，它的定义语法是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span> <span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span> <span class="comment">//不加修饰就是C调用约定</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">function</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//明确指出C调用约定</span></span></span><br></pre></td></tr></table></figure></p><p>在写本文时，出乎我的意料，发现cdecl调用约定的参数压栈顺序是和stdcall是一样的，参数首先由有向左压入堆栈。所不同的是，函数本身不清理堆栈，调用者负责清理堆栈。由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。对于前面的function函数，使用cdecl后的汇编码变成：</p><p>调用处<br>push 1<br>push 2<br>call function<br>add esp,8 注意：这里调用者在恢复堆栈<br>被调用函数_function处<br>push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复mov ebp,esp 保存堆栈指针<br>mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a<br>add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b<br>mov esp,ebp 恢复esp<br>pop ebp<br>ret 注意，这里没有修改堆栈</p><p>MSDN中说，该修饰自动在函数名前加前导的下划线，因此函数名在符号表中被记录为_function，但是我在编译时似乎没有看到这种变化。</p><p>由于参数按照从右向左顺序压栈，因此最开始的参数在最接近栈顶的位置，因此当采用不定个数参数时，第一个参数在栈中的位置肯定能知道，只要不定的参数个数能够根据第一个后者后续的明确的参数确定下来，就可以使用不定参数，例如对于CRT中的sprintf函数，定义为：</p><p><code>int sprintf(char* buffer,const char* format,...)</code></p><p>由于所有的不定参数都可以通过format确定，因此使用不定个数的参数是没有问题的。</p><p>fastcall<br>fastcall调用约定和stdcall类似，它意味着：</p><p>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈被调用函数清理堆栈函数名修改规则同stdcall其声明语法为：int fastcall function(int a,int b)</p><p>thiscall<br>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：</p><p>参数从右向左入栈<br>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈。</p><p>为了说明这个调用约定，定义如下类和使用代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> a,...)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::function1 (<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="keyword">int</span> A::function2(<span class="keyword">int</span> a,...)</span><br><span class="line">&#123;</span><br><span class="line">va_list ap;</span><br><span class="line">va_start(ap,a);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> i &amp;lt; a i ++)</span><br><span class="line">&#123;</span><br><span class="line">result += va_arg(ap,<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callee</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.function1 (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">a.function2(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callee函数被翻译成汇编后就变成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数function1调用</span></span><br><span class="line"><span class="number">0401</span>C1D push <span class="number">2</span></span><br><span class="line"><span class="number">00401</span>C1F push <span class="number">1</span></span><br><span class="line"><span class="number">00401</span>C21 lea ecx,[ebp<span class="number">-8</span>]</span><br><span class="line"><span class="number">00401</span>C24 call function1 注意，这里<span class="keyword">this</span>没有被入栈</span><br><span class="line"><span class="comment">//函数function2调用</span></span><br><span class="line"><span class="number">00401</span>C29 push <span class="number">3</span></span><br><span class="line"><span class="number">00401</span>C2B push <span class="number">2</span></span><br><span class="line"><span class="number">00401</span>C2D push <span class="number">1</span></span><br><span class="line"><span class="number">00401</span>C2F push <span class="number">3</span></span><br><span class="line"><span class="number">00401</span>C31 lea eax,[ebp<span class="number">-8</span>] 这里引入<span class="keyword">this</span>指针</span><br><span class="line"><span class="number">00401</span>C34 push eax</span><br><span class="line"><span class="number">00401</span>C35 call function2</span><br><span class="line"><span class="number">00401</span>C3A add esp,<span class="number">14</span>h</span><br></pre></td></tr></table></figure></p><p>可见，对于参数个数固定情况下，它类似于stdcall，不定时则类似cdecl</p><p>naked call<br>这是一个很少见的调用约定，一般程序设计者建议不要使用。编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果。这一般用于实模式驱动程序设计，假设定义一个求和的加法程序，可以定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm mov eax,a</span><br><span class="line">__asm add eax,b</span><br><span class="line">__asm ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个函数没有显式的return返回值，返回通过修改eax寄存器实现，而且连退出函数的ret指令都必须显式插入。上面代码被翻译成汇编以后变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+<span class="number">8</span>]</span><br><span class="line">add eax,[ebp+<span class="number">12</span>]</span><br><span class="line">ret <span class="number">8</span></span><br></pre></td></tr></table></figure><p>注意这个修饰是和__stdcall及cdecl结合使用的，前面是它和cdecl结合使用的代码，对于和stdcall结合的代码，则变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="keyword">int</span> __<span class="function">stdcall <span class="title">function</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm mov eax,a</span><br><span class="line">__asm add eax,b</span><br><span class="line">__asm ret <span class="number">8</span> <span class="comment">//注意后面的8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这种函数被调用，则和普通的cdecl及stdcall调用函数一致。</p><p>函数调用约定导致的常见问题<br>如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题，下面是两种常见的问题：</p><p>函数原型声明和函数体定义不一致DLL导入函数时声明了不同的函数约定以后者为例，假设我们在dll种声明了一种函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;<span class="comment">//注意，这里没有stdcall，使用的是cdecl</span></span><br></pre></td></tr></table></figure><p>使用时代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*WINAPI DLLFUNC)</span><span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">hLib = LoadLibrary(...);</span><br><span class="line">DLLFUNC func = (DLLFUNC)GetProcAddress(...)<span class="comment">//这里修改了调用约定</span></span><br><span class="line">result = func(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//导致错误</span></span><br></pre></td></tr></table></figure><p>由于调用者没有理解WINAPI的含义错误的增加了这个修饰，上述代码必然导致堆栈被破坏，MFC在编译时插入的checkesp函数将告诉你，堆栈被破坏了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C语言中，假设我们有这样的一个函数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int function(int a,int b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用时只要用&lt;code&gt;result = function(1,2)&lt;/code&gt;这样的方式就可以使用这个函数。但是，当高级语言
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="C语言" scheme="https://imzry.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>scanf格式控制符的完整格式</title>
    <link href="https://imzry.github.io/2017/09/04/scanf%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%A0%BC%E5%BC%8F/"/>
    <id>https://imzry.github.io/2017/09/04/scanf格式控制符的完整格式/</id>
    <published>2017-09-04T09:51:00.000Z</published>
    <updated>2019-07-27T08:19:05.783Z</updated>
    
    <content type="html"><![CDATA[<p><span>scanf格式控制的完整格式：</span></p><p><span><br>　　%&nbsp;&nbsp;&nbsp;&nbsp; <em>&nbsp;&nbsp;&nbsp;&nbsp; m&nbsp;&nbsp;&nbsp;&nbsp; l或h&nbsp;&nbsp;&nbsp;&nbsp; 格式字符<br>　　①格式字符与printf函数中的使用方式相同，以%d、%o、%x、%c、%s、%f、%e，无%u格式、%g格式。<span><br>　　②可以指定输入数据所占列宽，系统自动按它截取所需数据。如:<br>　　scanf( “%3d%3d”, &amp;a, &amp;b);<br>　　输入：123456<br>　　系统自动将123赋给a,456赋给b。<br>　　③%后的&ldquo;</span></em>&rdquo; 附加说明符，用来表示跳过它相应的数据。例如：<br>　　scanf( “%2d%*3d%2d”, &amp;a, &amp;b);<br>　　如果输入如下信息：1234567。将&ldquo;12 &rdquo;赋给a，&ldquo;67 &rdquo;赋给b。第二个数据&ldquo;345&rdquo;被跳过不赋给任何变量。<br>　　④输入数据时不能规定精度，例如：<br>　　scanf( “%7.2f”, &amp;a);<br>　　是不合法的，不能企图输入：12345.67而使a的值为12345.67。</span>&lt;/span&gt;</p><p><span>附加格式说明字符:<span><br><span>　　━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　 字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说明&nbsp;<br>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　&nbsp;&nbsp;&nbsp;&nbsp; l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于输入长整型数据(可用%ld,%lo,%lx)以及double型数据(用%lf或%le)<br>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>&nbsp;&nbsp;&nbsp; 　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于输入短整型数据(可用%hd, %ho, %hx)&nbsp;<br>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br>　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 域宽&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定输入数据所占宽度(列数),域宽应为正整数&nbsp;<br>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 表示本输入项在读入后不赋绐相应的变量<br>　　━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br><span>－－－－－－－－－－－－－－－－－－相关－－－－－－－－－－－－－－－－－－－<span><br>输入数据流分隔<br>　　①根据格式字符的含义从输入流中取得数据，当输入流中数据类型与格式字符要求不符时，就认为这一项结束。例如：<br>　　scanf( “%d%c%f”, &amp;a, &amp;b, &amp;c);<br>　　如果输入如下信息：<br>　　1234r1234.567<br>　　则scanf函数在接收数据时发现&ldquo;r&rdquo;类型不匹配，于是把&ldquo;1234&rdquo;转换成整型赋值给a，把&ldquo;r&rdquo;赋给变量b，最后把&ldquo;1234.567&rdquo;转换成实型数据赋给c。<br>　　②根据格式项中指定的域宽分隔出数据项。如语句：<br><span>　　scanf( “%2d%3f%4f”, &amp;a, &amp;b, &amp;c);<br>　　如果输入如下信息：<br>　　123456789012345<br>　　则scanf函数在接收数据时根据域宽把12赋值给a,345赋值给b，6789赋值给c。<br>　　③隐示分隔符。空格、跳格符（’\t’）、换行符（’\n’）都是<a href="http://lib.csdn.net/base/c" title="C语言知识库" target="_blank" rel="noopener">C语言</a>认定的数据分隔符。<br>　　④显示分隔符。在scanf函数的两个格式说明项间有一个或多个普通字符，那么在输入数据时，在两个数据之间也必须以这一个或多个字符分隔。如语句：<br>　　scanf( “a=%d,b=%f,c=%f”, &amp;a, &amp;b, &amp;c);<br>　　则输入数据应该为：<br>　　a=1234,b=67.8,c=98.123</span></span></span></span></span></span></p><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>关于scanf函数的进一步说明：<br>　　①scanf函数中的&ldquo;格式控制&rdquo;后面应当是变量地址，而不应是变量名。例如，如果a、b为整型变量，则<br>　　scanf( “%d,%d”, a, b);<br>　　是不对的，应将&ldquo;a, b&rdquo;改为 &ldquo;&amp;a, &amp;b&rdquo;。<br>　　②如果在&ldquo;格式控制&rdquo;字符串中除了格式说明以外还有其它字符，则在输入数据时应输入与这些字符相同的字符。例如：<br>　　scanf( “%d,%d”, &amp;a, &amp;b);<br>　　输入时应输入：3，4。3与4之间的逗号应与scanf函数中的&ldquo;格式控制&rdquo;中的逗号相对应，输入其它符号是不对的。<br>　　③在用&ldquo;%c&rdquo;格式输入字符时，空格字符和转义字符都作为有效字符输入。<br>　　scanf( “%c%c%c”, &amp;c1, &amp;c2, &amp;c3);<br>　　如输入：a b c 。字符 ‘a’ 赋给c1,字符（空格）’&nbsp;&nbsp;&nbsp;&nbsp; ‘ 赋给c2,字符 ‘b’&nbsp;&nbsp;&nbsp;&nbsp; 赋给c3。<br>　　④ scanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中不使用U说明符.对unsigned型数据用d、o、x说明符输入.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</p><p><span>补充：</span></p><p><span>对于 const char<em> p = “12232114687ABC12356”;<br>　　scanf( “%[123]”, buf); // 就把是’1’或’2’或’3’的字读读到buf中，直到遇到一个不是’1’且不是’2’且不是’3’的字符，于是执行后buf应该是”1223211”;<br>　　%[123]等同于%[231]，等同于%[321]&hellip;&hellip;，列表中的顺序是无所谓的；<br>　　%[123]也等同于%[1-3]或%[3-1],也就是&ldquo;1至3&rdquo;，对于连续的字符列表这样写就很简单，比如%[a-z]等同%[abc&hellip;省略&hellip;z]；<br>　　想想看，%[3-14]应该等同于什么？是&ldquo;3至14&rdquo;吗？当然不是，因为[]中的是字符，而不是数字，所以%[3-14]应该等同于%[3214]，等同于%[1234]；<br>　　同理，想只取字母，那就可以写成%[A-Za-z]；<br>　　如果列表的第一个字母是^，那么正好相反，比如%<sup><a href="#fn_A-Za-z" id="reffn_A-Za-z">A-Za-z</a></sup>的意思就是取字母之外的所有字符。<br>　　对于字符串”abDEc123”如果想按照字母和数字读到两个字符串中就应该是 “%[a-zA-Z]%[0-9]”,buf1,buf2 ；<br>　　假如我想<span>取一行字符，该怎么办？”%s”是不行的，因为%s遇到空白字符（空格、制表符、\r、\n）就结束了，所以可以写成&nbsp;<span>“%<sup><a href="#fn_\n" id="reffn_\n">\n</a></sup>%</span></span></em>c”，%<sup><a href="#fn_\n" id="reffn_\n">\n</a></sup>的作用刚才讲过了，就是读\n之外的所有字符，也就是说读到\n为止，%<em>c的作用就是把\n去掉，否则再次读的时候一直遇到的都是\n；<br>　　所有对%s起作用的控制，都可以用于%[]，比如”%</em><sup><a href="#fn_\n" id="reffn_\n">\n</a></sup>%*c”就表示跳过一行，”%-20<sup><a href="#fn_\n" id="reffn_\n">\n</a></sup>“就表示读取\n前20个字符。&nbsp;</span>&lt;/span&gt;&lt;/span&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span&gt;scanf格式控制的完整格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br&gt;　　%&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; l或h&amp;nbsp
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="C语言" scheme="https://imzry.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java学习个人备忘录之线程间的通信</title>
    <link href="https://imzry.github.io/2017/09/04/Java%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E5%A4%87%E5%BF%98%E5%BD%95%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://imzry.github.io/2017/09/04/Java学习个人备忘录之线程间的通信/</id>
    <published>2017-09-04T09:50:00.000Z</published>
    <updated>2019-07-27T08:17:32.731Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程间通讯</strong><br>多个线程在处理同一资源,但是任务却不同.&nbsp;</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Resource  {      String name;      String sex;  }  //输入  class Input implements Runnable  {      Resource r;      Input(Resource r)      {          this.r = r;      }      public void run()      {          int i = 0;          while(true)          {              synchronized(r)  //保证两个线程用同一个锁              {                  if (i==0)                  {                      r.name = "mike";                      r.sex = "nan";                  }                  else                  {                      r.name = "丽丽";                      r.name = "女女女女女女女女女";                  }                  x = (x+1)%2;              }          }      }  }  //输出  class Output implements Runnable  {      Resource r;      Output(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              synchronized(r)  //保证两个线程用同一个锁              {                  System.out.println(r.name+"....."+r.sex);              }          }      }  }  class ResourceDemo  {      public static void main(String[] args)      {          //创建资源          Resource r = new Resource();          //创建任务          Input in = new Input(r);          Output out = new Output(r);          //创建线程          Thread t1 = new Thread(in);          Thread t2 = new Thread(out);          //开启线程          t1.start();          t2.start();      }  }</pre></div><p>但是这样会造成大量的才重复, 没有交替性。</p><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>等待唤醒机制</strong></span></p><p>涉及的方法:<br>1. wait(): 让线程处于冻结状态, 被wait的线程会被存储到线程池中.<br>2. notify(): 唤醒线程池中一个线程(任意)<br>3. notifyAll(): 唤醒线程池中的所有线程. </p><p>这些方法都必须定义在同步中,<br>因为这些方法都是用于操做线程状态的方法.<br>必须要明确到底操做的是哪个锁上的线程. </p><p>为什么操做线程的方法wait notify notifyAll定义在了Object类中. </p><p>因为这些方法时监视器的方法, 坚持其其实就是锁.<br>锁可以是任意的对象,任意的对象调用的方式一定定义在Object类中的.&nbsp;</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Resource  {      String name;      String sex;      boolean flag = false;  }  //输入  class Input implements Runnable  {      Resource r;      Input(Resource r)      {          this.r = r;      }      public void run()      {          int i = 0;          while(true)          {              synchronized(r)  //保证两个线程用同一个锁              {                  if (r.flag)                  {                      r.wait();                  }                  if (i==0)                  {                      r.name = "mike";                      r.sex = "nan";                  }                  else                  {                      r.name = "丽丽";                      r.name = "女女女女女女女女女";                  }                  r.flag = true;                  r.notify();  //唤醒对方                  x = (x+1)%2;              }          }      }  }  //输出  class Output implements Runnable  {      Resource r;      Output(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              synchronized(r)  //保证两个线程用同一个锁              {                  if (!r.flag)                  {                      r.wait();                  }                  System.out.println(r.name+"....."+r.sex);                  r.flag = false;                  r.notify();  //唤醒对方              }          }      }  }  class ResourceDemo2  {      public static void main(String[] args)      {          //创建资源          Resource r = new Resource();          //创建任务          Input in = new Input(r);          Output out = new Output(r);          //创建线程          Thread t1 = new Thread(in);          Thread t2 = new Thread(out);          //开启线程          t1.start();          t2.start();      }  }</pre></div><p>上面代码的优化</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Resource  {      private String name;  //这里要私有化      private String sex;      boolean flag = false;      public synchronized void set(String name,String sex)  //对数据要可控化      {          if (this.flag)              try{this.wait();}catch(InterruptedException e){}          this.name = name;          this.sex = sex;          flag = true;          this.notify();      }      public synchronized void out()      {          if (this.flag)              try{this.wait();}catch(InterruptedException e){}          System.out.println(name+"....."+sex);          flag = false;          this.notify();      }  }  //输入  class Input implements Runnable  {      Resource r;      Input(Resource r)      {          this.r = r;      }      public void run()      {          int i = 0;          while(true)          {              if (i==0)              {                  r.set("mike","nan");              }              else              {                  r.set"丽丽","女女女女女女女女女");              }              x = (x+1)%2;          }      }  }  //输出  class Output implements Runnable  {      Resource r;      Output(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              r.out();          }      }  }  class ResourceDemo3  {      public static void main(String[] args)      {          //创建资源          Resource r = new Resource();          //创建任务          Input in = new Input(r);          Output out = new Output(r);          //创建线程          Thread t1 = new Thread(in);          Thread t2 = new Thread(out);          //开启线程          t1.start();          t2.start();      }  }</pre></div><p>&nbsp;</p><p><strong>多生产者多消费者问题</strong></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Resource  {      private String name;      private int count = 1;      private boolean flag = false;      public synchronized void set(String name)      {          if (flag)              try{this.wait();}catch(InterruptedException e){}          this.name = name + count;          count++;          System.out.println(Thread.currentThread().getName()+".....生产者....."+this.name);          flag = true;          notify();      }      public synchronized void out()      {          if (!flag)              try{this.wait();}catch(InterruptedException e){}          System.out.println(Thread.currentThread().getName()+".....消费者....."+this.name);          flag = false;          notify();      }  }  class Producer implements Runnable  {      private Resource r;      Producer(Resource r)      {          this.r = r;      }      public void run()      {          while (true)          {              r.set("烤鸭");          }      }  }  class Consumer implements Runnable  {      private Resource r;      Consumer(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              r.out();          }      }  }  class ProducerConsumerDemo  {      public static void main(String[] args)      {          Resource r = new Resource();          Producer pro = new Producer(r);          Consumer con = new Consumer(r);          Thread t0 = new Thread(pro);          Thread t1 = new Thread(pro);          Thread t2 = new Thread(con);          Thread t3 = new Thread(con);          t0.start();          t1.start();          t2.start();          t3.start();      }  }</pre></div><p>但是这样会出现安全隐患, 从这4个线程上看, 一共分了两组, t0和t1一组, t2和t3一组, 当t1 t2 t3 睡眠时, t0出来后再次唤醒t1, 这时t1是不用判断的if条件的,直接向下继续执行. 这样就又进行了”生产烤鸭”, 所以出现了安全隐患. 解决办法: 将两个if 换成 while, 这样在t1醒来的时候会继续判断flag是否为真. 但是这样又会出现死锁现象, 因为t1判断flag时, flag为真, 这时t1会再次等待,这时4个线程都进入等待状态—-死锁!!</p><p>&nbsp;</p><p><strong>解决办法1</strong><br>将notify换成notifyAll, 这样就一定会唤醒对方的线程,同时自己方的线程因为while循环出不去.&nbsp;</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Resource  {      private String name;      private int count = 1;      private boolean flag = false;      public synchronized void set(String name)      {          while (flag)              try{this.wait();}catch(InterruptedException e){}          this.name = name + count;          count++;          System.out.println(Thread.currentThread().getName()+".....生产者....."+this.name);          flag = true;          notifyAll();      }      public synchronized void out()      {          while (!flag)              try{this.wait();}catch(InterruptedException e){}          System.out.println(Thread.currentThread().getName()+".....消费者....."+this.name);          flag = false;          notifyAll();      }  }  class Producer implements Runnable  {      private Resource r;      Producer(Resource r)      {          this.r = r;      }      public void run()      {          while (true)          {              r.set("烤鸭");          }      }  }  class Consumer implements Runnable  {      private Resource r;      Consumer(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              r.out();          }      }  }  class ProducerConsumerDemo  {      public static void main(String[] args)      {          Resource r = new Resource();          Producer pro = new Producer(r);          Consumer con = new Consumer(r);          Thread t0 = new Thread(pro);          Thread t1 = new Thread(pro);          Thread t2 = new Thread(con);          Thread t3 = new Thread(con);          t0.start();          t1.start();          t2.start();          t3.start();      }  }</pre></div>> if判断标记只有一次, 会导致不该运行的线程运行了, 出现了数据错误的情况.&nbsp;while判断标记, 解决了线程获取执行权后, 是否要运行。> notify: 只能唤醒一个线程, 如果本方唤醒了本方, 就没有意义, 而且while判断标记notify会导致死锁.&nbsp;notifyAll解决了, 本方线程一定会唤醒对方线程.&nbsp;**解决办法2:** JDK1.5新特征的解决办法--Lock 可以看出来, 上面的解决方法会造成多次无用的判断, 这会降低效率,可以用这面的方法解决.&nbsp;<div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">Lock l = new ReentrantLock(); void show() {     l.lock(); //获取锁     code...     l.unlock(); //释放锁 }</pre></div><p>jdk1.5以后将同步和锁封装成了对象.<br>并将操作锁的隐式方法定义到了该对象中,<br>将隐式动作变成了显示动作. </p><p>但是如果执行的代码抛出了异常, 这样代码就会一直持有锁,不释放,所以要如下</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">Lock l = new ReentrantLock(); void show() {     l.lock(); //获取锁     try     {         code...     }     finally     {         l.unlock(); //释放锁     } }</pre></div><p>&nbsp;</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">import java.util.concurrent.locks.*  class Resource  {      private String name;      private int count = 1;      private boolean flag = false;      Lock l = new ReentrantLock();//因为Lock是java.util.concurrent.locks包中的类, 所以要先导入包.      public void set(String name) //这里的同步就可以去掉了      {          l.lock();  //在这里加上锁          try          {              while (flag)                  try{this.wait();}catch(InterruptedException e){}              this.name = name + count;              count++;              System.out.println(Thread.currentThread().getName()+".....生产者....."+this.name);              flag = true;              notifyAll();          }          finally          {              l.unlock();          }      }      public void out()      {          l.lock();          try          {              while (!flag)                  try{this.wait();}catch(InterruptedException e){}              System.out.println(Thread.currentThread().getName()+".....消费者....."+this.name);              flag = false;              notifyAll();          }          finally          {              l.unlock();          }      }  }  class Producer implements Runnable  {      private Resource r;      Producer(Resource r)      {          this.r = r;      }      public void run()      {          while (true)          {              r.set("烤鸭");          }      }  }  class Consumer implements Runnable  {      private Resource r;      Consumer(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              r.out();          }      }  }  class ProducerConsumerDemo  {      public static void main(String[] args)      {          Resource r = new Resource();          Producer pro = new Producer(r);          Consumer con = new Consumer(r);          Thread t0 = new Thread(pro);          Thread t1 = new Thread(pro);          Thread t2 = new Thread(con);          Thread t3 = new Thread(con);          t0.start();          t1.start();          t2.start();          t3.start();      }  }</pre></div><p><strong>解决办法3:</strong><br>JDK1.5新特征的解决办法—Condition </p><p>Condition在底层上是这样实现的:<br>interface Condition<br>{<br>    　　await();<br>    　　signal();<br>    　　signalAll();<br>} </p><p>所以要这样实现, 如下:<br>Lock l = new ReectrantLock(); </p><p>Condition c1 = l.newCondition(); </p><p>Condition c2 = l.newCondition(); </p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">import java.util.concurrent.locks.*  class Resource  {      private String name;      private int count = 1;      private boolean flag = false;      //创建一个锁对象.      Lock l = new ReentrantLock();//因为Lock是java.util.concurrent.locks包中的类, 所以要先导入包.      //通过已有的锁获取该锁上的监视器对象.      Condition con = l.newCondition();      public void set(String name) //这里的同步就可以去掉了      {          l.lock();  //在这里加上锁          try          {              while (flag)  //              try{this.wait();}catch(InterruptedException e){}   //这里用con.await()替换                  try{con.await();}catch(InterruptedException e){}              this.name = name + count;              count++;              System.out.println(Thread.currentThread().getName()+".....生产者....."+this.name);              flag = true;  //          notifyAll();  //这里用con.signalAll() 替换              con.signalAll();          }          finally          {              l.unlock();          }      }      public void out()      {          l.lock();          try          {              while (!flag)  //              try{this.wait();}catch(InterruptedException e){}   //这里用con.await()替换                  try{con.await();}catch(InterruptedException e){}              System.out.println(Thread.currentThread().getName()+".....消费者....."+this.name);              flag = false;  //          notifyAll();  //这里用con.signalAll() 替换              con.signalAll();          }          finally          {              l.unlock();          }      }  }  class Producer implements Runnable  {      private Resource r;      Producer(Resource r)      {          this.r = r;      }      public void run()      {          while (true)          {              r.set("烤鸭");          }      }  }  class Consumer implements Runnable  {      private Resource r;      Consumer(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              r.out();          }      }  }  class ProducerConsumerDemo2  {      public static void main(String[] args)      {          Resource r = new Resource();          Producer pro = new Producer(r);          Consumer con = new Consumer(r);          Thread t0 = new Thread(pro);          Thread t1 = new Thread(pro);          Thread t2 = new Thread(con);          Thread t3 = new Thread(con);          t0.start();          t1.start();          t2.start();          t3.start();      }  }</pre></div><p>其实解决办法3和解决办法2没有太大的区别.并没有真的运用了1.5的新特征。</p><p><strong>解决办法4</strong><br>这个解决办法才真正的运用到了1.5的新特征。</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">import java.util.concurrent.locks.*  class Resource  {      private String name;      private int count = 1;      private boolean flag = false;      //创建一个锁对象.      Lock l = new ReentrantLock();//因为Lock是java.util.concurrent.locks包中的类, 所以要先导入包.      //通过已有的锁获取该锁上的监视器对象.  //  Condition con = l.newCondition();      //通过已有的锁获取两组监视器, 一组监视生产者, 一组监视消费者.      Condition producer_con = l.newCondition();      Condition consumer_con = l.newCondition();      public void set(String name) //这里的同步就可以去掉了      {          l.lock();  //在这里加上锁          try          {              while (flag)                  try{producer_con.await();}catch(InterruptedException e){} //这里只让生产者等待              this.name = name + count;              count++;              System.out.println(Thread.currentThread().getName()+".....生产者....."+this.name);              flag = true;              consumer_con.signal(); //这里直接唤醒消费者          }          finally          {              l.unlock();          }      }      public void out()      {          l.lock();          try          {              while (!flag)                  try{consumer_con.await();}catch(InterruptedException e){} //这里只让消费者等待              System.out.println(Thread.currentThread().getName()+".....消费者....."+this.name);              flag = false;              producer_con.signalAll(); //这里只唤醒生产者          }          finally          {              l.unlock();          }      }  }  class Producer implements Runnable  {      private Resource r;      Producer(Resource r)      {          this.r = r;      }      public void run()      {          while (true)          {              r.set("烤鸭");          }      }  }  class Consumer implements Runnable  {      private Resource r;      Consumer(Resource r)      {          this.r = r;      }      public void run()      {          while(true)          {              r.out();          }      }  }  class ProducerConsumerDemo2  {      public static void main(String[] args)      {          Resource r = new Resource();          Producer pro = new Producer(r);          Consumer con = new Consumer(r);          Thread t0 = new Thread(pro);          Thread t1 = new Thread(pro);          Thread t2 = new Thread(con);          Thread t3 = new Thread(con);          t0.start();          t1.start();          t2.start();          t3.start();      }  }</pre></div><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;线程间通讯&lt;/strong&gt;&lt;br&gt;多个线程在处理同一资源,但是任务却不同.&amp;nbsp;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;class Res
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="java" scheme="https://imzry.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习个人备忘录之多线程</title>
    <link href="https://imzry.github.io/2017/09/04/Java%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E5%A4%87%E5%BF%98%E5%BD%95%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://imzry.github.io/2017/09/04/Java学习个人备忘录之多线程/</id>
    <published>2017-09-04T09:42:00.000Z</published>
    <updated>2019-07-27T08:16:29.381Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20150123185344974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTFxMXgyeDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p><strong>进程</strong>：正在进行中的程序(直译)。</p><p><strong>线程</strong>：就是进程中一个负责程序执行的控制单元(执行路径)<br>一个进程中可以有多个执行路径，称之为多线程。</p><p>一个进程中至少要有一个线程。</p><p>开启多个线程是为了同时运行多部分代码。</p><p>每一个线程都有自己运行的内容。这个内容可以称为线程要执行的任务。</p><p>多线程的好处：解决了多部分同时运行的问题。</p><p>多线程的弊端：线程太多回到效率的降低。</p><p>其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。</p><p>jvm启动时就启动了多个线程，至少有两个线程可以分析的出来。</p><p>1。执行main函数的线程<br>    该线程的任务代码都定义在main函数中<br>2。负责垃圾回收的线程. </p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo extends Object  {      public void finalize()  //用来回收      {          System.out.println("demo ok");      }  }  class ThreadDemo  {      public static void main(String[] args)      {          new Demo();          new Demo();          new Demo();          System.gc();          System.out.println("Hello World!");      }  }  </pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>多线程的创建方式—继承Thread类</strong> </span></p><p>步骤：<br>1。定义一个类继承Thread类<br>2。覆盖Thread类中的run方法<br>3。直接创建Thread的子类对象创建线程<br>4。调用start方法开启线程并调用线程的任务run方法执行。</p><p>可以通过Thread的getName获取线程的名称Thread-编号(从0开始) </p><p>主线程的名字就是main. </p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo extends Thread  {       private String name;      Demo(String name)      {          super(name);//自定义线程的名称          this.name = name;      }      public void run()      {          show();      }      public void show()      {  //      System.out.println(name+"........x="+x+".......name="+getName());          System.out.println(name+"........x="+x+".......name="+Thread.currentThread().getName());//当前运行线程的名称。     }  }  class ThreadDemo2  {      public static void main(String[] args)      {          /*         创建线程的母的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行。        而运行的指定代码就是这个执行路径的任务。        jvm创建的主线程的任务都定义在了主函数中。        而自定义的线程它的任务在哪儿呢?         Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述。        这个任务就是通过Thread类中的run方法来体现。也就是说，run方法就是封装自定义线程运行任务的函数。        run方法中定义就是线程要运行的任务代码。        开启线程是为了运行指定代码，所以只有继承Thread类，并复写run方法。        将运行的代码定义在run方法中即可。        */          Demo d1 = new Demo("旺财");          Demo d2 = new Demo("xiaoqiang");          //d1.run();          //d2.run();          d1.start(); //开启线程，调用run方法          d2.start();          System.out.println("over....."+Thread.currentThread().getName());      }  }  </pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>创建多线程的第二种方式—实现Runnable接口</strong></span></p><p>1。定义类实现Runnable接口<br>2。覆盖接口中的run方法，将线程的任务代码封装到run方法中。<br>3。通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。<br>    　　为什么? 因为线程的任务都封装在Runnable接口子类对象的run方法中<br>        　　所以要在线程对象创建时就必须明确要运行的任务。<br>4。调用线程对象的start方法开启线程. </p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo implements Runnable  {      public void run()  //Runnable里只有一个run方法      {          show();      }      public void show()      {          for (int x=0; x&lt;20 ; x++ )          {              System.out.println(Thread.currentThread().getName()+"....."+x);          }      }  }  class TreadDemo  {      public static void main(String[] args)      {          Demo d = new Demo();          Thread t1 = new Thread(d); //将d传进去          Thread t2 = new Thread(d);          t1.start();          t2.start();      }  }</pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>实现Runnable接口的好处</strong>：</span><br>1。将线程的任务从线程的子类中分离出来，进行了单独的封装。<br>    按照面向对象的思想将任务的封装成对象。<br>2。避免了java单继承的局限性。</p><p>所以，创建线程的第二种方式较为常用. </p><p>&nbsp;</p><p>例子：卖票。<br>四个人一起卖100张票 </p><div class="dp-highlighter bg_java">第一种方法</div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Ticket extends Thread  {      private static int num = 100; //这个变量要共享，所以要加静态      public void run()      {          sale();      }      public void sale()      {          while(true)          {              if (num&gt;0)              {                  System.out.println(num--);              }          }      }  }  class TicketDemo  {      public static void main(String[] args)      {          Ticket t1 = new Ticket();          Ticket t2 = new Ticket();          Ticket t3 = new Ticket();          Ticket t4 = new Ticket();          t1.start();          t2.start();          t3.start();          t4.start();      }  }</pre></div><p>&nbsp;</p><p>第二种方法</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Ticket implements Runnable  {      private int num = 100;      public void run()      {          sale();      }      public void sale()      {          while(true)          {              if (num&gt;0)              {                  try{Thread.sleep(10);}catch(InterruptedException e){}                  System.out.println(Thread.currentThread().getName()+"....."+num--);              }          }      }  }  class TicketDemo  {      public static void main(String[] args)      {          Ticket t = new Ticket();                 //因为只创建了一个对象，但是下面开启了4个进程，所以就等于4个人卖共同卖100张票          Thread t1 = new Thread(t);          Thread t2 = new Thread(t);          Thread t3 = new Thread(t);          Thread t4 = new Thread(t);          t1.start();          t2.start();          t3.start();          t4.start();      }  }</pre></div><p>&nbsp;</p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">**线程安全问题产生的原因**：1。多个线程在操作共享数据。2。操作共享数据的线程代码有多条。当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生。解决思路：就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在java中用，同步代码块就可以解决这个问题. </div><div class="dp-highlighter bg_java">&nbsp;</div><div class="dp-highlighter bg_java"><span style="font-size: 16px;">**同步代码块**</span></div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">格式：synchronized(对象) {     需要被同步的代码 }</pre></div><p>&nbsp;</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Ticket implements Runnable  {      private int num = 100;      Object obj = new Object();      public void run()      {          sale();      }      public void sale()      {      //Object obj = new Object();  //它在这是错误的，这样每开启一个线程，就创建一把锁，一同是4个线程4个锁          while(true)          {              synchronized(obj)  //同步代码块              {                  if (num&gt;0)                  {                      try{Thread.sleep(10);}catch(InterruptedException e){}                      System.out.println(Thread.currentThread().getName()+"....."+num--);                  }              }          }      }  }  class TicketDemo  {      public static void main(String[] args)      {          Ticket t = new Ticket();          Thread t1 = new Thread(t);          Thread t2 = new Thread(t);          Thread t3 = new Thread(t);          Thread t4 = new Thread(t);          t1.start();          t2.start();          t3.start();          t4.start();      }  }</pre></div><p>同步的好处：解决了线程的安全问题。<br>同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。<br>同步的前提：必须有多个线程并使用同一锁. </p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">&nbsp;</div><div class="dp-highlighter bg_java">实例：储户，两个，每个都到银行存钱，每次存100，共存三次。</div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Bank  {      private int sum;  //  private Object obj = new Object();      public synchronized void add(int num)  //也可以用同步函数      {  //      synchronized(obj)  //      {              sum = sum + num;              System.out.println("sum="+sum);  //      }      }  }  class Cus implements Runnable  {      private Bank b = new Bank();      public void run()      {          for (int x=0; x&lt;3 ; x++ )          {              b.add(100);          }      }  }  class BankDemo  {      public static void main(String[] args)      {          Cus c = new Cus();          Thread t1 = new Thread(c);          Thread t2 = new Thread(c);          t1.start();          t2.start();      }  }</pre></div><p>&nbsp;</p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">**验证同步函数的锁**</div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Ticket implements Runnable  {      private int num = 100;      Object obj = new Object();      boolean flag = true;      public void run()      {  //      Object obj = new Object();  //它在这是错误的，这样每开启一个线程，就创建一把锁，一同是4个线程4个锁          if (flag)          {              while(true)              {                  synchronized(this)  //同步代码块                  {                      if (num&gt;0)                      {                          try{Thread.sleep(10);}catch(InterruptedException e){}                          System.out.println(Thread.currentThread().getName()+"...obj..."+num--);                      }                  }              }          }          else               while(true)              show();      }      public synchronized void show()  //但是可以这样用，把需要同步的代码封装起来。     {          if (num&gt;0)          {              try{Thread.sleep(10);}catch(InterruptedException e){}              System.out.println(Thread.currentThread().getName()+"...function..."+num--);          }      }  }  class SynFunctionLockDemo  {      public static void main(String[] args)      {          Ticket t = new Ticket();          Thread t1 = new Thread(t);          Thread t2 = new Thread(t);          t1.start();          try{Thread.sleep(10);}catch(InterruptedException e){}          t.flag = false;          t2.start();      }  }</pre></div><p>&nbsp;</p><p>同步函数使用的锁是this。</p><p>同步函数和同步代码块的区别：<br>    　　同步函数的锁是固定的this。<br>    　　同步代码块的锁是任意对象。</p><p>建议使用同步代码块. </p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">&nbsp;</div><div class="dp-highlighter bg_java"><span style="font-size: 16px;">**验证静态同步函数的锁**</span></div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Ticket implements Runnable  {      private static int num = 100;      Object obj = new Object();      boolean flag = true;      public void run()      {          //Object obj = new Object();  //它在这是错误的，这样每开启一个线程，就创建一把锁，一同是4个线程4个锁          if (flag)          {          while(true)          {          synchronized(this)  //同步代码块          {          if (num&gt;0)          {          try{Thread.sleep(10);}catch(InterruptedException e){}          System.out.println(Thread.currentThread().getName()+"...obj..."+num--);          }          }          }          }          else           while(true)          this.show();      }      public static synchronized void show(Ticket.class)  //但是可以这样用，把需要同步的代码封装起来。     {          if (num&gt;0)          {              try{Thread.sleep(10);}catch(InterruptedException e){}              System.out.println(Thread.currentThread().getName()+"...function..."+num--);          }      }  }  class SynFunctionLockDemo  {      public static void main(String[] args)      {          Ticket t = new Ticket();          Thread t1 = new Thread(t);          Thread t2 = new Thread(t);          t1.start();          try{Thread.sleep(10);}catch(InterruptedException e){}          t.flag = false;          t2.start();      }  }</pre></div><p>静态的同步函数使用的锁是该函数所属字节码文件对象可以用getClass方法获取，也可以用当前 类名.class 表示.</p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">&nbsp;</div><div class="dp-highlighter bg_java"><span style="font-size: 16px;">**多线程下的单例**</span></div><div class="dp-highlighter bg_java">**饿汉式**</div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Single  {      private static final Single s = new Single();      private Single(){}      public static Single getInstance()      {          return s;      }  }//这个方法没有安全隐患</pre></div><p>&nbsp;</p><p><strong>懒汉式</strong></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Single  {      private static Single s = null;      private Single(){}      public static synchronized Single getInstance()      {          if (s==null)          //--&gt;0  --&gt;1    //懒汉式本身有安全隐患，所以要加同步 synchronized          s = new Single();          return s;      }  }//虽然这样解决的安全隐患，但是每次获取数据s时都要判断锁，这样效率不高，解决如下： class Single  {      private static final Single s = null;      private Single(){}      public static Single getInstance()      {          if (s==null)          {              synchronized(Single.class)              {                  if (s==null)                  {                      s = new Single();                  }              }          }          return s;      }  }//可以用这种双重判断的方式解决懒汉式的安全隐患。</pre></div><p>&nbsp;</p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java"><span style="font-size: 16px;">**死锁示例**</span></div><div class="dp-highlighter bg_java">死锁：常见情景之一：同步的嵌套。</div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Ticket implements Runnable  {      private static int num = 100;      Object obj = new Object();      boolean flag = true;      public void run()      {          if (flag)          {              while(true)              {                  synchronized(obj)  //同步代码块里面嵌套着同步函数                  {                      show();  //同步函数                  }              }          }          else           while(true)          this.show();      }      public static synchronized void show()  //同步函数里面嵌套着同步代码块      {          synchronized(obj)  //同步代码块          {              if (num&gt;0)              {                  try{Thread.sleep(10);}catch(InterruptedException e){}                  System.out.println(Thread.currentThread().getName()+"...sale..."+num--);              }          }      }  }  class SynFunctionLockDemo  {      public static void main(String[] args)      {          Ticket t = new Ticket();          Thread t1 = new Thread(t);          Thread t2 = new Thread(t);          t1.start();          try{Thread.sleep(10);}catch(InterruptedException e){}          t.flag = false;          t2.start();      }  }</pre></div><p>&nbsp;</p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">**一种死锁示例**</div><div class="dp-highlighter bg_java"><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Test implements Runnable  {      private boolean flag;      Test(boolean flag)      {          this.flag = flag;      }      public void run()      {          if (flag)          {              while(true)              {                  synchronized(MyLock.locka)                  {                      System.out.println(Thread.currentThread().getName()+"...if   locka......");                      synchronized(MyLock.lockb)                      {                          System.out.println(Thread.currentThread().getName()+"...if    lockb.....");                      }                  }              }          }          else          {              while(true)              {                  synchronized(MyLock.lockb)                  {                      System.out.println(Thread.currentThread().getName()+"...else   lockb......");                      synchronized(MyLock.locka)                      {                          System.out.println(Thread.currentThread().getName()+"...else   locka......");                      }                  }              }          }      }  }  class MyLock  {      public static final Object locka = new Object();      public static final Object lockb = new Object();  }  class DeadLockTest  {      public static void main(String[] args)      {          Test a = new Test(true);          Test b = new Test(false);          Thread t1 = new Thread(a);          Thread t2 = new Thread(b);          t1.start();          t2.start();      }  }</pre></div><p>&nbsp;</p><p>&lt;/div&gt;</p><div class="dp-highlighter bg_java">&nbsp;</div></div></div></div></div></div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150123185344974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTFxMXgyeDI=/font/5a6L5L2T/fontsize/400
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="java" scheme="https://imzry.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习个人备忘录之异常</title>
    <link href="https://imzry.github.io/2017/09/04/Java%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E5%A4%87%E5%BF%98%E5%BD%95%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>https://imzry.github.io/2017/09/04/Java学习个人备忘录之异常/</id>
    <published>2017-09-04T09:03:00.000Z</published>
    <updated>2019-07-27T08:17:36.387Z</updated>
    
    <content type="html"><![CDATA[<p><span style="font-size: 16px;"><strong>概述</strong></span></p><p>异常：是在运行时期发生的不正常情况。</p><p>在java中用类的形式对不正常情况进行了描述和封装对象。</p><p>描述不正常的情况的类，就称为异常类。</p><p>以前正常流程代码和问题处理代码相结合，<br>现在将正常流程代码和问题处理代码分离，提高阅读性。</p><p>其实异常就是java通过面向对象的思想将问题封装成了对象。</p><p>用异常类对其进行描述。<br>不同的问题用不同的类进行具体的描述。</p><p>问题很多，意味着描述的类也很多。<br>将其共性进行向上抽取，形成了异常体系。</p><p>最终问题(不正常情况)就分成了两大类<br>Throwable：无论是error，还是异常，问题发生就应该可以抛出，让调用者知道并处理。<br>            //该体系的特点就在于Throwable及其所有的子类都具有可抛性。<br>            可抛性到底指的是什么呢? 怎么体现可抛性呢?<br>            其实是通过两个关键字来体现的。<br>            throws  throw，凡是可以被这两个关键字所操作的类和对象都具备可抛性。<br>    |—1。一般不可处理的。 一般用Error表示<br>        特点:是由jvm抛出的严重性的问题。<br>            这种问题发生一般不针对性处理.直接修改程序。<br>    |—2。可以处理的，一般用Exception表示 。</p><p>该体系的特点：<br>    子类的后缀名都是用其父类名作为后缀，阅读性很强。</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class ExceptionDemo  {      public static void main(String[] args)      {          int[] arr = new int[3];          System.out.println(arr[3]);//编译通过，运行不通过          sleep(-5);      }      public static void sleep(int time)      {          if (time&lt;0)          {               //抛出 new FuTime();//就代码的时间为负的情况，这个对象中会包含着问题的名称，信息，位置等信息。         }          System.out.println("我睡..."+time);      }  }  class FuTime  {  }</pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>异常对象的抛出throw &nbsp;</strong></span></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo  {      public int method(int[] arr，int index)      {          if (arr==null)          {              throw new NullPointerException("数组的引用不能为空!");          }          if (index&gt;=arr.length)          {              throw new ArrayIndexOutOfBoundsException("数组的角标越界了 "+index);//这里就抛出了自定义的异常信息。         }          if (index&lt;0)          {              throw new ArrayIndexOutOfBoundsException("数组的角标不能为负值 "+index);//这里就抛出了自定义的异常信息。         }          return arr[index];      }  }  class ExceptionDemo2  {      public static void main(String[] args)      {          int[] arr = new int[3];          Demo d = new Demo();          int num = d.method(arr，30);          System.out.println("num="+num);          System.out.println("over");      }  }  </pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>自定义异常&amp;异常类的抛出throws</strong> </span></p><p>对于角标是正数不存在，可以用角标越界表示。<br>对于角标为负数的情况，准备用负数角标异常来表示。</p><p>负数角标这种异常在java中并没有定义过。<br>那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象。</p><p>这种自定义的问题描述称为自定义异常. </p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo  {      public int method(int[] arr，int index)throws FuShuIndexException  //表示抛出了。     {          if (arr==null)          {              throw new NullPointerException("数组的引用不能为空!");          }          if (index&gt;=arr.length)          {              throw new ArrayIndexOutOfBoundsException("数组的角标越界了 "+index);//这里就抛出了自定义的异常信息。         }          if (index&lt;0)          {              throw new FuShuIndexException("数组的角标不能为负值 "+index);          }          return arr[index];      }  }  class ExceptionDemo3  {      public static void main(String[] args)throws FuShuIndexException      {          int[] arr = new int[3];          Demo d = new Demo();          int num = d.method(null，30);          System.out.println("num="+num);          System.out.println("over");      }  }  </pre></div><p><strong>注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性，才可以被两个关键字所操作，throw，throws。</strong></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class FuShuIndexException extends Exception  {      FuShuIndexException()      {}      FuShuIndexException(String msg)      {          super(msg);      }  }  </pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>异常的分类</strong>：</span><br>1。编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系<br>    这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。<br>    这样的问题都可以针对性的处理。</p><p>2。编译时不检测异常(运行时异常)：就是Exception中的RuntimeException和其子类。<br>    这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的而或者引发了内部状态的改变导致的。<br>    那么这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止，让调用者对代码进行修正。</p><p>所以自定义异常时，要么继承Exception，要么继承RuntimeException。</p><p><span style="font-size: 16px;"><strong>throws和throw的区别</strong> </span><br>1。throws使用在函数上。<br>    throw使用在函数内。<br>2。throws抛出的是异常类，可以抛出多个，用逗号隔开。<br>    throw抛出的是异常对象.</p><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>异常捕捉trycatch</strong> </span></p><p>异常处理的捕捉形式：<br>这是可以对异常进行针对性处理的方式. </p><p><strong>具体格式是：</strong></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">try {     需要被检测异常的代码。} catch(异常类 变量) //该变量用于接收发生的异常对象。{     处理异常的代码。} finally {     一定会被执行的代码 } </pre></div><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo  {      public int method(int[] arr，int index)throws FuShuIndexException，NullPointerException  //表示抛出了。     {          if (arr==null)          {              throw new NullPointerException("没有任何数组实体");          }          if (index&lt;0)          {              throw new FuShuIndexException("数组的角标不能为负值 "+index);          }          return arr[index];      }  }  class ExceptionDemo4  {      public static void main(String[] args)throws FuShuIndexException      {          int[] arr = new int[3];          Demo d = new Demo();          try          {              int num = d.method(null，-30);                 System.out.println("num="+num);          }          catch (NullPointerException e)          {              System.out.println(e.toString());          }          catch (FuShuIndexException e)          {              System.out.println("message:"+e.getMessage()); //数组的角标不能为负值              System.out.println("string:"+e.toString());  //FuShuIndexException：数组的角标不能为负值              e.printStackTrace();//jvm默认的异常处理机制就是调用异常对象的这个方法。             //System.out.println("负数角标异常!!!!");          }          System.out.println("over");      }  }  class FuShuIndexException extends Exception  {      FuShuIndexException()      {}      FuShuIndexException(String msg)      {          super(msg);      }  }</pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>异常处理的原则</strong>：</span><br>1。函数内容如果抛出需要检测的异常，那么函数上必须要声明。<br>    否则必须在函数内用trycatch捕捉，否则编译失败。<br>2。如果调用了声明异常的函数，要么trycatch要么throws，否则编译失败。<br>3。什么时候catch，什么时候throws呢?<br>    功能内部可以解决，用catch。<br>    解决不了，用throws告诉调用者，由调用者解决。<br>4。一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。<br>    内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch个. </p><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>finally代码块</strong></span></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class Demo  {      public int show(int index)      {          if (index&lt;0)          {              throw new ArrayIndexOutOfBoundsException("角标越界了!!");          }          int[] arr = new int[3];          return arr[index];      }  }  class ExceptionDemo5  {      public static void main(String[] args)      {          Demo d = new Demo();          try          {              int num = d.show(-3);              System.out.println("num="+num);          }          catch (ArrayIndexOutOfBoundsException e)          {              System.out.println(e.toString());  //开发的时候不要写输出语句。         }          finally //通常用于关闭(释放)资源          {              System.out.println("finally");          }      }  }  </pre></div><p>例如：<br>连接数据库<br>查询。Exception<br>关闭连接 </p><p>try catch finally 代码块组合特点：</p><p>1。try  catch  finally </p><p>2。try  catch(多个) 当没有必要资源需要释放时，可以不用定义finally。</p><p>3。try  finally  //必须用throws声明 </p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">void show()throws Exception  {     try     {         throw new Exception();     }     finally     {     } }</pre></div><p>&nbsp;</p><p><span style="font-size: 16px;"><strong>异常的注意事项</strong>：</span><br>1。子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类。</p><p><strong>解释：</strong></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class A extends Exception  {  }  class B extends A  {  }  class C extends Exception  {  }  Exception      |--A          |--B      |--C  class Fu  {      void show()throws A      {}  }  class Zi extends Fu  {      void show()throws A或B  //这里抛出的必须是父类的异常或父类异常的子类，所以不能抛出C      {}  }  </pre></div><p>2。如果父类抛出多个异常，那么子类只能抛出父类异常的子集。<br>解释：如果父类抛出A B C D ，那么子类要么抛出 A B，要么抛出 C D ，要么抛出 A B C ，也可以全抛出，总之就是不能抛出像A B C D E这样的。简单说：子类覆盖父类只能抛出父类的异常或者子类或者子集。<br>注意：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try。</p><p>&nbsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;异常：是在运行时期发生的不正常情况。&lt;/p&gt;
&lt;p&gt;在java中用类的形式对不正常情况进行了描述和封装对象。&lt;/p&gt;
&lt;p&gt;描述不正常的情况的类
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="java" scheme="https://imzry.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习个人备忘录之内部类</title>
    <link href="https://imzry.github.io/2017/09/03/Java%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E5%A4%87%E5%BF%98%E5%BD%95%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://imzry.github.io/2017/09/03/Java学习个人备忘录之内部类/</id>
    <published>2017-09-03T11:48:00.000Z</published>
    <updated>2019-07-29T02:17:18.477Z</updated>
    
    <content type="html"><![CDATA[<p><strong>内部类</strong>: 将一个类定义在另一个类的里面,对里面那个类就称为内部类. &nbsp;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> //它想访问<span class="title">Outer</span>中的<span class="title">num</span>, 如果在外面就需要创建一个对象,然后通过公开的接口访问,但是现在<span class="title">Outer</span>内部, 就可以直接访问了.这样方便  </span></span><br><span class="line"><span class="class">    </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"show run..."</span> + num);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//如果现在想访问Inner就需要这样  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();  </span><br><span class="line">        in.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//内部类由于在内部, 相当于定义在了成员的位置上, 所以可以用成员修饰符, 如:  </span></span><br><span class="line">    <span class="comment">//private class Test&#123;&#125;  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>  </span></span><br><span class="line"><span class="class">    </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"function run......"</span>+num);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部类访问特点：</strong><br>1. 内部类可以直接访问外部类中的成员.<br>2. 外部类要访问内部类, 必须建立内部类的对象. </p><p>一般用于类的设计。</p><p>分析事物时, 发现该事物描述中还有事物,而且这个事物还在访问被描述事物的内容。<br>这时就把还有的事物定义成内部类来描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Outer out  = <span class="keyword">new</span> Outer();  </span><br><span class="line">        out.method();  </span><br><span class="line">        <span class="comment">//直接访问外部类中的内部类中的成员.  </span></span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Oouter().new Inner();  </span><br><span class="line">        in.show();  </span><br><span class="line">        <span class="comment">//如果内部类是静态, 那就相当于一个外部类了.  </span></span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner();  </span><br><span class="line">        in.show();  </span><br><span class="line">        <span class="comment">//如果内部类是静态的,成员是静态的.  </span></span><br><span class="line">        Outer.Inner.function();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果内部类中定义了静态成员,该内部类也必须是静态的.  </span></span><br><span class="line">    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>  </span></span><br><span class="line"><span class="class">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">4</span>;  </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">5</span>;  </span><br><span class="line">            System.out.println(num);<span class="comment">//5  </span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);<span class="comment">//4  </span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);<span class="comment">//3  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Inner().show();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo2</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Outer().method();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么内部类能直接访问外部类中成员呢?</strong><br>那是因为内部类持有了外部类的引用——-外部类名.this </p><p>&nbsp;</p><p>内部类可以存放在局部位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;  </span><br><span class="line">    <span class="function">Object <span class="title">method</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">9</span>;  </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>  </span></span><br><span class="line"><span class="class">        </span>&#123;  </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">"show..."</span>+num);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Object in = <span class="keyword">new</span> Inner();  </span><br><span class="line">        <span class="keyword">return</span> in;<span class="comment">//0x0045  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo3</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();  </span><br><span class="line">        Object obj = out.method();<span class="comment">//0x0045  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类在局部位置上只能访问局部中被final修饰的局部变量。</p><p><strong>匿名内部类</strong>, 就是内部类的简写格式.<br>必须有前提:<br>    内部类必须继承或者实现一个外部类或者接口. </p><p>匿名内部类: 其实就是一个匿名子类对象. </p><p>格式: new 父类or接口(){子类内容}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">4</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">Demo</span> //这是正常情况  </span></span><br><span class="line"><span class="class">    </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"show...."</span>+num);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Demo()<span class="comment">//这个就叫匿名内部类  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">"show...."</span>+num);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类的应用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Inter()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;&#125;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;&#125;  </span><br><span class="line">        &#125;.show1();  <span class="comment">//调用了show1的方法, 相当于  new Inner().show1();  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者用下面的方法  </span></span><br><span class="line">        Inter in = <span class="keyword">new</span> Inter()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;&#125;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;&#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        in.show1();  </span><br><span class="line">        in.show2();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通常的使用场景之一:</strong><br>当函数参数是接口类型时,而且接口中的方法不超过三个.<br>可以用匿名内部类作为实际参数进行传递. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo5</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        show(<span class="keyword">new</span> InterImpl());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Inter in)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        in.show1();  </span><br><span class="line">        in.show2();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inter</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象的初始化过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">9</span>;  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(<span class="string">"Fu"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Fu()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">        <span class="comment">//显示初始化  </span></span><br><span class="line">        <span class="comment">//构造代码块初始化  </span></span><br><span class="line">        show();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"fu show..."</span>+num); <span class="comment">//被覆盖,运行子类  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(<span class="string">"Zi"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Zi()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">        <span class="comment">//显示初始化  </span></span><br><span class="line">        <span class="comment">//构造代码块初始化  </span></span><br><span class="line">        show();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"zi show..."</span>+num);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Zi();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Fu</span></span><br><span class="line"><span class="comment">zi show...0</span></span><br><span class="line"><span class="comment">Zi</span></span><br><span class="line"><span class="comment">zi show...8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20150117095127046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTFxMXgyeDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;内部类&lt;/strong&gt;: 将一个类定义在另一个类的里面,对里面那个类就称为内部类. &amp;nbsp;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="java" scheme="https://imzry.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习个人备忘录之多态</title>
    <link href="https://imzry.github.io/2017/09/03/Java%E5%AD%A6%E4%B9%A0%E4%B8%AA%E4%BA%BA%E5%A4%87%E5%BF%98%E5%BD%95%E4%B9%8B%E5%A4%9A%E6%80%81/"/>
    <id>https://imzry.github.io/2017/09/03/Java学习个人备忘录之多态/</id>
    <published>2017-09-03T11:31:00.000Z</published>
    <updated>2019-07-27T08:16:24.806Z</updated>
    
    <content type="html"><![CDATA[<p><span style="font-size: 16px;"><strong>对象的多态性</strong></span></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">class 动物{}class 猫 extends 动物{}class 狗 extends 动物{}猫 x = new 猫();//意思是建立本类的对象 new 猫()，并通过本类的引用指向本类的对象。动物 x = new 猫();//所以也可以这样写 &nbsp;一个对象两种形态.//上面的代码表示，用猫类型创建对象，用动物类型指向.//它的表现就是 &nbsp;父类型的指向子对象//这就是多种形态.</pre></div><p>猫这类事物即具备着猫的形态，又具备着动物的形态。<br>这就是对象的多态性。</p><p>简单说：就是一个对象对应着不同类型。</p><p>多态在代码中的体现：<br>父类或者接口的引用指向其子类的对象。</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">abstract class Animal{    abstract void eat();}class Dog extends Animal{    void eat()    {        System.out.println("啃骨头");    }    void lookHone()    {        System.out.println("看家");    }}class Cat extends Animal{    void eat()    {        System.out.println("吃鱼");    }    void catchMouse()    {        System.out.println("抓老鼠");    }}class Pig extends Animal{    void eat()    {        System.out.println("饲料");    }    void gongDi()    {        System.out.println("拱地");    }}class DuoTaiDemo{    public static void main(String[] args)    {        Cat c = new Cat();        //c.eat();        method(c);        Dog d = new Dog();        method(d);        Pig p = new Pig();        method(p);        //改进后        Animal a = new Cat();//这叫自动类型提升,猫对象提升了动物类型. 但是特有功能无法访问.        //作用就是限制对特有功能的访问.        //专业讲：向上转型        a.eat();        //如果我还想用具体动物猫的特有功能.        //你可以将该对象进行向下转型.        Cat c = (Cat)a; //向下转型的目的是为了使用子类中特有方法.        c.eat();        c.catchMouse();        //注意，对于转型,自始至终都是子类对象在做着类型的变化.    }}</pre></div><p>&nbsp;</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">public static void method(Pig p){    p.eat();}public static void method(Cat c){    c.eat();}public static void method(Dog d){    d.eat();}</pre></div><p>每加一个动物，就要再写一个函数，这样很麻烦.<br>不如我直接让”动物们去吃饭”就可以了</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">public static void method(Animal a){    a.eat();}//这样就行了.省了很多的代码</pre></div><p>这就是多态的简单使用。</p><p><span style="font-size: 16px;"><strong>多态的好处：</strong></span><br>提高了代码的扩展性，前期定义的代码可以使用后期的内容.</p><p>多态的弊端：<br>前期定义的内容不能使用(调用)后期子类的特有内容.</p><p>多态的前提：<br>1. 必须有关系：继承，实现<br>2. 要有覆盖. &nbsp;</p><p><strong>类型判断</strong></p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">public static void method(Animal a){    a.eat();    if (a instanceof Cat)//instanceof：用于判断对象的具体类型,只能用于引用数据类型的判断. (也可以判断接口)    {        Cat c = (Cat)a;        c.catchMouse();    }    else if (a instanceof Dog)    {        Dog d = (Dog)a;        d.lookHome();    }}</pre></div><p><span style="font-size: 16px;"><strong>成员变量</strong></span></p><p>多态时：<br>成员的特点：<br>1. 成员变量.<br>编译时：参考引用型变量所属的类中的是否有调用的成员变量，有，编译通过，没有，编译失败.<br>运行时：参考引用型变量所属的类中的是否有调用的成员变量，并运行该所属类型中的成员变量<br>简单说：编译和运行都参考等号的左边.</p><p>2. 成员函数(非静态)：<br>编译时：参考引用类型变量所属的类中的是否有调用的函数，有，编译通过.<br>运行时：参考对象所属的类中是否调用的函数.<br>简单说：编译看左边，运行看右边.</p><p>3. 静态函数：<br>编译时：参考引用型变量所属的类中的是否有调用的静态方法.<br>运行时：参考引用型变量所属的类中的是否有调用的静态方法.<br>简单说，编译和运行都看左边.</p><p>其实对于静态方法，是不需要对象的，直接用类名调用即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;strong&gt;对象的多态性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
      
    
    </summary>
    
      <category term="闲扯" scheme="https://imzry.github.io/categories/%E9%97%B2%E6%89%AF/"/>
    
    
      <category term="java" scheme="https://imzry.github.io/tags/java/"/>
    
  </entry>
  
</feed>
