{"meta":{"title":"杨同学的日常闲扯","subtitle":"杨同学的日常闲扯","description":"杨同学的日常闲扯个人技术博客，Python、算法、机器学习、深度学习","author":"杨同学","url":"https://imzry.github.io","root":"/"},"pages":[],"posts":[{"title":"配置本地访问远程Linux系统服务器的jupyter notebook","slug":"配置本地访问远程Linux系统服务器的jupyter-notebook","date":"2019-07-23T11:22:28.000Z","updated":"2019-07-26T08:32:52.218Z","comments":true,"path":"2019/07/23/配置本地访问远程Linux系统服务器的jupyter-notebook/","link":"","permalink":"https://imzry.github.io/2019/07/23/配置本地访问远程Linux系统服务器的jupyter-notebook/","excerpt":"","text":"环境情况 远程服务器上配置了anaconda 本地主机没有安装anaconda（其实安不安装都无所谓，有浏览器就行） 配置步骤如下 登录远程服务器 生成配置文件 jupyter notebook --generate-config 生成密码 输入ipython打开ipython生成密钥： 12345In [1]: from notebook.auth import passwdIn [2]: passwd()Enter password:Verify password:Out[2]: 'sha1:ce23d945972f:34769685a7ccd3d08c84a18c63968a41f1140274' #这段是密钥 把生成的密钥’sha1:ce2…’复制下来后面用，password是远程登录时需要输入的密码，要记住。 修改配置文件 使用vim打开配置文件 vim ~/.jupyter/jupyter_notebook_config.py 修改如下地方： 123456c.NotebookApp.ip = '*'c.NotebookApp.password = u'sha:ce...刚才复制的那个密文'c.NotebookApp.open_browser = Falsec.NotebookApp.port = 8888 #随便指定一个端口，但是要记住c.NotebookApp.allow_remote_access = Truec.NotebookApp.notebook_dir = u'目录' #这个是根目录，不想配置就不配置，默认是用户家目录 启动jupyter notebook 正常启动： jupyter notebook 但是我们可能通常想要在后台启动jupyter，然后关闭终端，在本地电脑上用浏览器访问： nohup jupyter notebook &amp; 远程访问 在本地打开浏览器访问http://address_of_remote:8888就可以访问jupyter的登录界面了，输入密码就可以正常登录了。 意外情况有些服务器可能只开放一个对外的端口，但是我们通过终端访问服务器需要一个对外端口，开启jupyter服务又需要一个端口，这样就需要同时占用两个端口才行。举个栗子，服务器为了保证安全性只开放了一个对外的端口，22号端口，我们使用终端通过22号端口登录到服务器上打开jupyter，jupyter创建的端口是8888号，但是服务器没有对外开放8888号端口，所以即使打开了jupyter，外面也无法正常访问。如果把jupyter的端口号改为22号，由于我们登录终端的时候正在占用22号，所以jupyter就会提示端口已被占用，无法创建。网上有很多教程说可以通过修改防火墙设置来开放端口，修改防火墙设置一般都需要管理员权限，但是通常我们使用服务器的时候大多数情况下是不可能有管理员权限的，这时候我们可以使用端口映射来解决这个问题。 首先登录终端打开jupyter，这是根据配置信息jupyter占用的是8888端口。 然后我们在本地上使用命令行输入： ssh -N -f -L localhost:9999:localhost:8888 -p 端口号 username@远程地址 例如ssh -N -f -L localhost:9999:localhost:8888 -p 22 yzr@202.48.29.23 这里说明一下：locahost:9999是指本地地址，localhost:8888是指远程地址，其中8888是jupyter notebook中设置的端口号，-p 22是指登录服务器的端口号 后面是用户名和服务器ip。 打开浏览器，输入localhost:9999就可以看到jupyter notebook的登录界面了。 这里原理上就是将服务器上的8888端口映射到本机的9999端口。","categories":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"},{"name":"jupyter","slug":"jupyter","permalink":"https://imzry.github.io/tags/jupyter/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://imzry.github.io/tags/DeepLearning/"}]},{"title":"论文翻译：HetConv-Heterogeneous Kernel-Based Convolutions for Deep CNNs","slug":"论文翻译：HetConv-Heterogeneous Kernel-Based Convolutions for Deep CNNs","date":"2019-06-06T05:57:02.000Z","updated":"2019-07-27T02:42:17.894Z","comments":true,"path":"2019/06/06/论文翻译：HetConv-Heterogeneous Kernel-Based Convolutions for Deep CNNs/","link":"","permalink":"https://imzry.github.io/2019/06/06/论文翻译：HetConv-Heterogeneous Kernel-Based Convolutions for Deep CNNs/","excerpt":"","text":"Abstract我们提出了一种新颖的深度学习架构，其中卷积操作利用了异构内核。与标准卷积运算相比，所提出的HetConv（基于异构内核的卷积）减少了计算（FLOPs）和参数的数量，同时仍保持表示效率。为了证明我们提出的卷积的有效性，我们在标准卷积神经网络（CNN）架构上提供了广泛的实验结果，如VGG和ResNet。 我们发现在用我们提出的HetConv滤波器替换这些架构中的标准卷积滤波器后，我们实现了基于3X到8X FLOPs的速度提升，同时仍然保持（有时提高）精度。 我们还将我们提出的卷积与组/深度方式的卷积进行比较，并表明它可以以更高的精度实现更多的FLOPs减少。 1. Introduction卷积神经网络在视觉和NLP等领域表现出了显著的性能。进一步提高性能的总趋势使模型更加复杂和深入。随着网络的深入，通过增加模型复杂度来提高精度并不是免费的；它伴随着计算量(FLOPs)的大幅增加。因此，人们提出了各种卷积运算/卷积滤波器，以减少对模型的FLOPs，提高模型的效率。 现有的卷积滤波器可以粗略地分为三类：1-深度卷积滤波器执行深度卷积（DWC），2-逐点卷积滤波器执行逐点卷积（PWC）和3-组循环卷积滤波器执行 分组卷积（GWC）。 大多数最近的架构使用这些卷积滤波器的组合来使模型有效。使用这些卷积（例如，DWC，PWC和GWC），许多流行的模型已经探索了新的架构来减少FLOPs。但是，设计新架构需要大量工作才能找到最佳的滤波器组合，从而实现最小的FLOPs。 另一种提高模型效率的流行方法是使用模型压缩。模型压缩大致可分为三类:连接剪枝、滤波器剪枝和量化。 在滤波器剪枝中，其思想是剪枝模型中贡献最小的筛选器，在删除此筛选器/连接之后，通常对模型进行微调以保持其性能。在修剪模型时，我们需要一个预先训练的模型(可能需要一个计算上昂贵的训练作为预处理步骤)，然后我们丢弃贡献最小的过滤器。因此，这是一个非常昂贵和棘手的过程。因此，使用有效的卷积滤波器或卷积运算来设计一个有效的架构是比剪枝更流行的方法。这并不需要昂贵的训练，然后修剪，因为训练是从头开始有效地完成。 使用有效的卷积滤波器，有两个不同的目标。一种工作侧重于设计具有最小FLOPs而同时降低精度的架构。这些工作重点是开发物联网/低端设备的模型。这些模型的精度较低，因此必须搜索最佳模型，以在精度和FLOPs之间建立平衡。因此，在FLOP和模型精度之间存在权衡。 另一组工作侧重于提高准确性，同时保持模型FLOPs与原始架构相同。最近的架构，如Inception，RexNetXt和Xception就是这类工作的例子。他们的目标是使用有效的卷积滤波器设计更复杂的模型，同时保持FLOPs与基本模型相同。通常期望更复杂的模型可以学习更好的特征，从而获得更好的准确性。但是，这些方法并不专注于设计新架构，而主要是在标准基础架构中使用现有的高效过滤器。因此，这些工作保持层数和体系结构与基础模型相同，并增加每层上的过滤器，使其不增加FLOPs。 与这两种方法相比，我们工作的主要重点是通过设计新内核来减少给定模型/体系结构的FLOP，而不会影响精度损失。 在实验上我们发现所提出的方法具有比现有技术修剪方法低得多的FLOPs，同时保持基础模型/架构的准确性。修剪方法非常昂贵，并且显示出实现FLOPs压缩的准确性显着下降。 在提出的方法中，我们选择了一种不同的策略来提高现有模型的效率，同时又不牺牲精度。架构搜索需要多年的研究才能得到优化的架构。因此，我们没有设计一个新的高效的架构，而是设计了一个高效的卷积运算(卷积滤波器)，它可以直接插入到任何现有的标准架构中以减少FLOPs。为了实现这一点，我们提出了一种新型的卷积——异构卷积。 卷积运算可以根据核的类型分为两类： 使用传统卷积滤波器的同构卷积(例如标准卷积、群卷积、深度卷积、点卷积)。同构卷积可以用同构滤波器来实现。如果一个过滤器包含所有大小相同的内核，那么它就是同构的（例如，在一个$3\\times 3\\times 256$ CONV2D过滤器中，所有256个内核的大小都是$3 \\times 3$）。 异构卷积使用异构卷积滤波器(HetConv)。如果一个过滤器包含不同大小的内核，那么它就是异构的(例如，在HetConv过滤器中，256个内核中有一些内核大小为$3\\times 3$，其余的内核大小为$1 \\times 1$)。 在深度CNN中使用异构滤波器克服了现有基于高效架构搜索和模型压缩的方法的局限性。最新的高效架构之一MobileNet使用深度和点卷积。标准的卷积层被两个卷积层替换，因此它有更多的延迟（延迟1，延迟也可以简单的理解为速度慢于基准模型的多少）。有关延迟的详细信息，请参阅- 3.3节和图4。但是我们提出的HetConv具有与原始架构相同的延迟（延迟为零），而不像具有大于零的延迟。 与高精度下降的模型压缩相比，我们的方法与ResNet和VGGNet等标准模型的最新结果相比具有很强的竞争力。 使用HetConv过滤器，我们可以从头开始训练我们的模型，而不像需要预训练模型的修剪方法，而不会牺牲准确性。 如果我们增加FLOPs修剪的程度，修剪方法也会遭受严重的精确度下降。 使用提出的Het-Conv滤波器，与FLOPs修剪方法相比，我们拥有关于FLOPs的最新结果。 此外，修剪过程效率低，因为修剪后需要花费大量时间进行训练和微调。 我们的方法非常高效，并且在从头开始训练时，与原始模型相比，提供了类似的结果。 据我们所知，这是第一个异构的卷积/过滤器。这种异构设计有助于提高现有架构的效率（FLOPs降低），而不会牺牲精度。 我们在ResNet，VGG-16等不同架构上进行了大量实验，只需将原来的滤波器替换为我们提出的滤波器即可。 我们发现，在不牺牲这些模型的准确性的情况下，我们将FLOPs的高度降低（3倍到8倍）。与现有的修剪方法相比，这些FLOPs减少甚至更好。 我们的主要贡献如下： 我们设计了一个高效的异构卷积滤波器，它可以插入到任何现有的架构中，在不牺牲精度的前提下，提高架构的效率(将FLOPs减少3到8倍)。 提出的HetConv滤波器的设计方式是零延迟。因此，从输入到输出的延迟可以忽略不计。 2. Related Work最近深度神经网络的成功取决于模型设计。为了实现最小的错误率，模型变得越来越复杂。 复杂而深入的架构包含数百万个参数，需要数十亿次FLOP（计算）。 这些模型需要具有高端规格的机器，并且这些类型的架构在低计算资源上效率非常低。 这引起了人们对设计高效模型的兴趣。提高模型效率的工作可分为两部分。 2.1. Efficient Convolutional Filter(高效的卷积过滤器)为了设计高效的卷积滤波器，近年来提出了几种新型的卷积滤波器。其中分组卷积(GWC)、深度卷积(DWC)[38]和点态卷积(PWC)是常用的卷积滤波器。它们被广泛用于设计高效的体系结构。GoogleNet使用inception模块和不规则的堆叠架构。Inception模块使用GWC和PWC来减少FLOPs。ResNet使用瓶颈结构来设计具有剩余连接的高效架构。它们使用PWC和标准卷积，有助于在不增加模型参数的情况下更深入，并减少FLOP爆炸。因此，与VGG相比，他们可以设计更深入的架构。ResNetxt使用ResNet架构，他们用GWC和PWC划分每一层。因此，在不增加FLOP的情况下，它们可以增加基数1.它们表明增加基数比更深或更宽的网络更有效。SENet设计了一种新的连接，它为每个输出特征映射赋予了权重，虽然FLOPs略有增加，但性能却有所提升。 MobileNet是另一种流行的架构，专为包含DWC和PWC的物联网设备而设计。这种架构在FLOP方面非常轻便且高效。FLOP的减少不是免费的，并且与最先进的模型相比，精度下降的成本也随之降低。在同一层使用不同类型的卷积滤波器，但由于每个过滤器中存在相同类型的内核，所以每个滤波器执行的卷积都是同构的。在相同层使用不同类型的卷积滤波器也有助于减少参数FLOP。在我们提出的卷积中，由于每个滤波器中存在不同类型的内核，卷积操作是异构的。 2.2. Model Compression（模型的压缩）另一种提高CNN效率的流行方法是模型压缩。这些可以分为:1-连接剪枝，2-过滤器剪枝和3位压缩。与其他方法相比，滤波器剪枝方法更有效，并且在FLOPs方面具有较高的压缩率。此外，过滤器修剪方法不需要任何特殊的硬件/软件支持(稀疏库)。 在滤波器剪枝中，大部分工作都是根据一定的准则计算滤波器的重要性，然后对其进行剪枝，然后进行再训练以恢复精度下降。使用L1范数作为排名过滤器的度量。但是，剪枝是在预先训练的模型上完成的，包括迭代训练和剪枝，这是昂贵的。此外，如果触发器剪枝的程度增加，则滤波器剪枝的精度会急剧下降。 3. Proposed Method（提出的方法）在这项工作中，我们提出了一种新颖的滤波器/卷积（Het-Conv），它包含异构内核（例如，少数内核的大小为$3 \\times 3$，其他内核可能为$1 \\times 1$），以减少现有模型的FLOPs。 与原始模型的精度相同。这与由均匀内核（例如全部$3 \\times 3$或全部$5 \\times 5$）组成的标准卷积滤波器非常不同。异构滤波器在FLOPs方面非常有效。它可以近似为分组卷积滤波器（GWC）和逐点卷积滤波器（PWC）的组合滤波器。为了减少卷积层的FLOPs，我们通常将其替换为两层或更多层（GWC / DWC和PWC），但它会增加延迟，因为下一层的输入是前一层的输出。因此，必须按顺序完成所有计算以获得正确的输出。相比之下，我们提出的HetConv具有相同的延迟。标准滤波器和HetConv滤波器之间的差异如图1和图2所示。 图1 标准卷积过滤器（同构）和异构卷积过滤器（HetConv）之间的诧异。其中M是指输入深度（输入通道的数量），P是指part（控制卷积过滤器中不同类型的核的数量）。在M个核中，$\\frac MP$核的大小是$3×3$，其余的都是$1×1$。 图2 将所提出的卷积滤波器(HetConv)与其他有效卷积滤波器进行比较。我们的异构过滤器的延迟为零，而其他过滤器(GWC+PWC或DWC+PWC)的延迟为一个单元。 在标准卷积层中，假设输入(输入特征图)的大小为$D_i\\times D_i\\times M$。其中$D_i$为输入的正方形特征图空间宽度和高度，$M$为输入深度(输入通道数)。还要考虑$D_o\\times D_o\\times N$是输出特性映射。这里$D_o$是输出的正方形特征图空间宽度和高度，$N$是输出深度(输出通道数)。应用$K\\times K\\times M$大小的N个滤波器得到输出特征图。这里K是内核大小。因此，这一$L$层的总计算成本为： FL_S=D_o\\times D_o \\times M \\times N \\times K \\times K \\tag{1}由式(1)可以看出，计算代价与核大小(K)、feature map大小、输入通道M和输出通道n有关。这种计算代价非常高，可以通过精心设计新的卷积运算进一步降低。为了减少高计算量，提出了各种卷积，如DWC、PWC和GWC，这些卷积在许多最近的架构中被使用来减少FLOPs，但它们都增加了延迟。 标准卷积运算和一些最近的卷积运算使用同构核(即，对于整个过滤器，每个内核的大小相同)。为了提高效率，我们使用了异构内核。对于同一个过滤器，它包含不同大小的内核。请参考图3来可视化特定层l上的所有过滤器。我们定义P部分，它控制卷积过滤器中不同类型内核的数量。对于第P部分，总内核中的$\\frac{1}{P}$部分为$K\\times K$大小，其余部分$(1-\\frac1P)$为$1\\times 1$大小。为了更好地理解，让我们举个例子，在一个$3\\times3\\times 256$标准CONV2D过滤器中，如果您将$(1-\\frac1P)\\times 256$、$3\\times 3$个内核替换为$1\\times 1$(沿着中轴)，您将得到一个带有$P$部分的HetConv过滤器。请参见图1和图2。 图3 第$L$层卷积滤波器：使用异构内核的卷积滤波器(HetConv)。在图中，每个通道由大小为$3 \\times 3$和$1\\times 1$的异构内核组成。在标准卷积滤波器中，用$1\\times 1$的核替换$3 \\times 3$的核，在保持精度的同时，大大减少了误操作。特定层的过滤器以移位的方式排列(即，如果第一个过滤器从第一个位置启动$3\\times 3$内核，那么第二个过滤器从第二个位置启动$3 \\times 3$内核，以此类推)。 在层$L$上有$P$部分的Hetconv滤波器中，$k\\times k$大小的核的计算成本如下所示： FL_K=\\frac{(D_o \\times D_o \\times M \\times N \\times K \\times K)}{P} \\tag{2}它降低了P倍的成本，因为我们现在只有$\\frac MP$个$K \\times K$大小的核。 其余的$(M-\\frac MP)$内核大小为$1\\times 1$。剩余的$1\\times 1$个内核的计算成本为： FL_1 = (D_o \\times D_o \\times N) \\times (M - \\frac MP) \\tag{3}因此，第$L$层的总计算成本为： FL_{HC} = FL_K + FL_1 \\tag{4}与标准卷积相比，计算的总减少量（R）可表示为： R_{HetConv} = \\frac {FL_K + FL_1}{FL_S} =\\frac1P + \\frac{1-\\frac1P}{K^2} \\tag{5}在方程5中，如果我们令$P = 1$，那么它就变成了标准卷积滤波器。 通过将某些通道上的过滤器大小从$3\\times 3$减小到$1 \\times 1$，我们正在减小过滤器的空间范围。但是，通过在某些信道上保持$3\\times 3$的大小，我们可以确保滤波器覆盖了某些信道上的空间相关性，并且不需要在所有信道上都具有相同的空间相关性。我们在实验部分观察到，通过这样做，我们可以获得与同构过滤器相似的精度。另一方面，如果我们避免并保留所有通道上的$1\\times1$滤波器大小，那么我们就不会覆盖必要的空间相关信息，并且精度会受到影响。 3.1. Comparision with DepthWise followed by PointWise Convolution（比较深度卷积和点卷积）在极端情况下，HetConv中$P=M$时，HetConv可以与DWC+PWC(深度卷积后点卷积)进行比较。MobileNet使用这种类型的卷积。虽然MobileNet比我们的极端情况有更多的FLOPs与更多的延迟，因为MobileNet有一个延迟。 对于第$L$层，DWC+PWC (MobileNet)的总FLOPs数可以计算为： FL_{MobNet} =D_o \\times D_o \\times M \\times K \\times K + M \\times N \\times D_o \\times D_o \\tag{6}因此总的计算量比标准卷积减少了： R_{MobNet}=\\frac{FL_{MobNet}}{FL_S}=\\frac 1N + \\frac{1}{K^2} \\tag{7}从公式5可以清楚地看出，我们可以改变$P$部分的值来在精度和FLOPs之间进行权衡。 如果我们减小$P$值，产生的卷积将更接近标准卷积。 为了显示所提出的HetConv滤波器的有效性，我们在实验部分中显示了结果，其中HetConv使用类似的FLOP实现了明显更好的精度。 在$P = M$的极端情况下，由公式5和7(对于MobileNet $N = M$)，我们可以得出结论： \\frac 1M + \\frac{(1-\\frac1M)}{K^2}< \\frac 1M + \\frac{1}{K^2} \\tag{8}与标准卷积相比计算量的总减少： Speedup = \\frac{1}{Reduction} \\tag{9}因此，从公式8可以看出，MobileNet比我们的方法需要更多的计算。在我们的HetConv中，延迟为零，而MobileNet的延迟为1。在这种极端情况下，我们的精度明显高于MobileNet(请参阅实验部分)。 3.2. Comparision with GroupWise followed by PointWise Convolution（与GroupWise比较，然后是PointWise Convolution）对于组大小为$G$的群向卷积和点态卷积(GWC+PWC)，第$L$层的GWC+PWC总的FLOPs次数可以计算为： FL_G = \\frac{(D_o \\times D_o \\times M \\times N \\times K \\times K)}{G+ M \\times N \\times D_o \\times D_o} \\tag{10}因此计算的总减少与标准的卷积比较： R_{Group} = \\frac {FL_G}{FL_S} = \\frac1G + \\frac{1}{K^2} \\tag{11}同样的，当$P=G$时，由公式5和11得到： \\frac 1P + \\frac{(1-\\frac1P)}{K^2}","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://imzry.github.io/categories/论文阅读/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"https://imzry.github.io/tags/DeepLearning/"},{"name":"深度学习","slug":"深度学习","permalink":"https://imzry.github.io/tags/深度学习/"},{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://imzry.github.io/tags/卷积神经网络/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-02T01:34:05.000Z","updated":"2019-07-27T08:24:28.469Z","comments":true,"path":"2019/01/02/hello-world/","link":"","permalink":"https://imzry.github.io/2019/01/02/hello-world/","excerpt":"","text":"欢迎来到Hexo！这是你的第一篇文章。查看文档以获取更多信息。 如果您在使用Hexo时遇到任何问题，可以在故障排除中找到答案，或者您可以在GitHub上询问我。 快速开始创建一个新帖子1$ hexo new \"我的新文章\" 更多信息：写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[]},{"title":"Python学习之路8 - 内置方法","slug":"Python学习之路8-内置方法","date":"2017-11-22T06:37:00.000Z","updated":"2019-07-27T08:18:56.374Z","comments":true,"path":"2017/11/22/Python学习之路8-内置方法/","link":"","permalink":"https://imzry.github.io/2017/11/22/Python学习之路8-内置方法/","excerpt":"","text":"abs(-230) #取绝对值 all([0,1,-5]) #如果参数里面的所有值都为真就返回真，否则返回假 any([0,1,-5]) #如果参数里面有一个值为真则返回真，否则返回假 ascii([1,2,'fds','浮点数'])#将参数变成字符串 bin(8) #十进制转二进制 hex(255) #转十六进制 oct(4) #转八进制 bool(2) #判断参数真假 a = bytes(\"abcde\",encoding=\"utf-8\") #将字符串转换成二进制 b = bytearray(\"abcde\",encoding=\"utf-8\") #将字符串转换成二进制数组 b[2] = 100 #然后就可以想数组一样修改值 def test():pass callable(test) #判断参数是否能被调用，test是函数，所以能被调用，返回True chr(100) #把数字对应的ASCII码字符取出来 ord('d') #返回对应的ASCII码编号 a = {} dir(a) #查看a有什么方法 divmod(5,2) #返回参数一处以参数二的结果和余数 a = ''' a = [1,2,3] b = iter(a) print(b.__next__()) ''' exec(a) #将字符串编译成代码，然后运行 res = filter(lambda n:n&gt;5,range(10)) #用来过滤数据，第一个是条件，第二个是数据 for i in res: print(i) res = map(lambda n:n*n,range(10)) #用来处理数据，第一个是处理方式，第二个是数据 for i in res: print(i) import functools res = functools.reduce(lambda x,y:x*y,range(10)) #累计处理 #第一个参数是累计的方式，这里是累加 #第二个参数是需要运算的数据 print(res) #45 a = frozenset([1,4,33,212,54]) #将一个列表变成不可修改的 globals() #返回当前文件的所有变量名和值 globals().get('a') #这样可以取出变量名对应的值 hash('test') #返回对象的哈希值 max() #返回最大值 min() #返回最小值 pow(3,5) #3的5次方 repr(a) #将一个对象转换成字符串 round(1.5461,2) #保留2位小数 a = {6:2,4:23,34:5,-5:99} sorted(a.items()) #按照key值进行排序 sorted(a.items(),key=lambda x:x[1]) #按照value进行排序 a = [1,2,3,4,5,6] b = ['a','b','c','d'] for i in zip(a,b): #将a和b一一对应组成4个元组，a中的5,6没有对应的元组，所以就不显示 print(i) __import__('decorator') #将同目录下的decorator.py文件导入","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路7 - 生成器&迭代器","slug":"Python学习之路7-生成器-迭代器","date":"2017-11-22T06:35:00.000Z","updated":"2019-07-27T08:18:52.061Z","comments":true,"path":"2017/11/22/Python学习之路7-生成器-迭代器/","link":"","permalink":"https://imzry.github.io/2017/11/22/Python学习之路7-生成器-迭代器/","excerpt":"","text":"本章内容： 列表生成式 生成器 yield 迭代器 列表生成式当我们要定义一个列表的时候，我们通常用这种方式a = [1,2,3]，但是如果我们定义了一个比较长的列表的时候，手动定义列表就会比较麻烦，这是我们通常的做法就是利用循环的手段来创建列表，例如创建如下的列表： L = [0,1,4,9,16,25,36,49,64,81] L = [] for x in range(1, 11): L.append(x*x) 这样我们就创建了一个较长的列表。 但是这样写，我们用了三行代码，其实我们可以用一行代码就代替了它： L = [i*i for i in range(1,11)] 这就是列表生成式。 前面的i*i是运算式，也可以用函数，然后后面加上一个for循环就可以了。 其实我们不难看出，for循环和列表生成式的关系，如下图： for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [x * x for x in range(1, 11) if x % 2 == 0] #结果为： #[4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [m + n for m in 'ABC' for n in 'XYZ'] #结果为： #['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层用的就比较少了。 生成器上面的列表生成式的最外面是用中括号括起来的，如果把中括号变成小括号，也就是这样： L = (i*i for i in range(1,11)) 这样就是一个生成器了。 那么生成器有什么好处呢？ 我们用列表生成式直接生成列表后，列表会直接放在内存中等待被使用。但是如果列表过于长了，但是我们暂时又用不到全部的元素，就会造成内存的浪费。生成器的好处就在于(i*i for i in range(1,11))这句话执行完毕后将返回一个算法给L，并不是直接将所有的数据放到内存中，当我们访问数据时，生成器就会根据算法现生成我们需要的书库，这样就避免了内存的浪费。 但是生成器不能像列表一样a[100]这样直接取出某个数据，因为生成器还没有访问到第100个元素。生成器其实就像一个递推公式一样，想要知道第100个元素是什么，就必须要先知道第99个元素是什么，以此类推… 下面用生成器生成一个列表并且遍历所有的数据 L = (i*i for i in range(1,11)) for i in L: print(i) 也可以一个一个数据的访问，调用生成器中下一个数据 a = (i*i for i in range(1,11)) a.__next__() #这样就调用了下一个数据 并且生成器也只有一个方法，就是next()方法，只能往下走，不能回头。 &nbsp; yield&nbsp;先来看一个菲波那切数列的迭代算法。 def fib(max): n,a,b = 0,0,1 while n&lt;max: #print(b) #如果用print，那么这个函数就会直接输出数列的所有值 yield b #如果用yield，那么这个函数就会变成一个生成器 a, b = b, a + b n = n + 1 return '---done---' #如果程序抛异常，就会返回这个信息 yield可以保存当前循环的状态，然后可以先做其他的事情，做完其他的事情，可以回来继续进行下一个循环。 &nbsp; yield的一个稍微复杂的应用 - 利用yield模拟多线程 import time def consumer(name): print(\"%s 准备吃包子了！\" %name) while True: baozi = yield print(\"包子[%s]来了，被[%s]吃了！\" %(baozi,name)) #当函数中有yield时，这个函数就会变成一个生成器 c = consumer('lisi') #将这个生成器赋值给c c.__next__() #然后执行一次这个生成器，但是一次调用只会执行到含有yield的语句前面， # 因为yield可以暂停并保存当前的状态，一到yield就会暂停，所以while循环里面的输出语句没有执行 c.send('猪肉') #send()函数，用来向yield里面传值，然后继续执行一次，直到再次碰到yield时就会再次暂停 #注意，第一次执行时一定要执行__next__()函数，后面才可以执行send()函数 c.send('牛肉') #再次传值，再次执行while里面的语句，注意，不会执行上面的print(\"%s 准备吃包子了！\" %name)语句 c.send('niurou') #再次传值，再次执行while里面的语句 c.__next__() #这里再次调用__next__()函数，同样还是执行while里面的输出语句，但是不会向yield里面传值 上面是手动执行这个生成器，下面写一个函数来调用这个生成器。 import time def consumer(name): print(\"%s 准备吃包子了！\" %name) while True: baozi = yield print(\"包子[%s]来了，被[%s]吃了！\" %(baozi,name)) def producer(): c = consumer('A') c2 = consumer('B') c.__next__() c2.__next__() print('老子开始准备做包子了') for i in range(10): time.sleep(1) print('做了一个包子，分两半') c.send(i) c2.send(i) producer() #这样就是一边做包子，一边吃包子了 &nbsp; 迭代器可以被next()函数调用并不断返回下一个值的对象成为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象或者Iterable对象 from collections import Iterator #需要先导入这个模块 isinstance((x for x in range(10)),Iterator) #第一个参数为想要判断的东西，第二个参数是想要判断的类型 isinstance({},Iterator) from collections import Iterable isinstance((),Iterator) isinstance('abc',Iterator) 生成器都是Iterator对象，但是list、dict、str虽然是Iterator，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()对象。 isinstance(iter([]),Iterator) #这样结果就是True了 #例子 a = [1,2,3] b = iter(a) b.__next__() &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路6 - 装饰器","slug":"Python学习之路6-装饰器","date":"2017-11-21T11:01:00.000Z","updated":"2019-07-27T08:18:48.357Z","comments":true,"path":"2017/11/21/Python学习之路6-装饰器/","link":"","permalink":"https://imzry.github.io/2017/11/21/Python学习之路6-装饰器/","excerpt":"","text":"装饰器定义：本质是函数，（装饰其他函数）就是为其他函数添加附加功能。原则：1.不能修改被装饰的函数的源代码 2.不能修改被装饰的函数的调用方式 实现装饰器的知识储备： 1.函数即&ldquo;变量&rdquo; 2.高阶函数（满足下列条件之一就是高阶函数） a：把一个函数名当作形参传给另一个函数(在不修改被装饰函数源代码的情况下修改其功能,但是调用方式变了) b：返回值中包含函数名(不修改函数的调用方式,而修改函数功能) 3.嵌套函数 &nbsp; 总结： 高阶函数+嵌套函数=&gt;装饰器 1. 函数即变量 def bar(): #这里定义个函数 print('this is bar...') func = bar #将函数当变量一样赋值给func func() #这是func加上()就可以当函数用了 这就是函数即变量。 2. 高阶函数a：把一个函数名当做形参传给另一函数（在不修改被装饰函数源代码的情况下修改其他功能，但是调用方式变了） def bar(): print('this is bar...') bar() print('----------------------------------') def test(func): #在这里增加了功能 print(func) test(bar) #但是这里修改了调用方式 b：返回值中包含函数名（不修改函数的调用方式，而修改函数功能） def bar(): print('this is bar...') bar() print('----------------------------------') def test(func): #在这里增加了功能 print(func) return func #这里返回了函数地址 bar = test(bar) #将函数地址赋给一个变量,该变量和传入函数同名 bar() #这个变量加上括号,就可以当函数用了,同时又没有修改函数的调用方式 3. 嵌套函数 x = 1 def test1(): def test2(): def test3(): x = 3 print(x) test3() test2() test1() 像这样在一个函数里面定义一个函数就叫做嵌套函数。 &nbsp; 现在三个知识点都已经解释过了，下面先实现一个原始版的装饰器。 原始版装饰器 import time def test1(): #这里是被装饰的函数 time.sleep(1) print(\"this is test1....\") def timer(func): #这里是装饰器函数 def deco(): strat = time.time() func() stop = time.time() print(\"run time %s\" %(stop-strat)) return deco test1 = timer(test1) test1() 这个装饰器的功能是测试test1函数的运行时间，deco函数有这个功能，所以这里其实我想运行的是deco函数，timer()函数的返回值也就是deco函数的地址；同时deco函数想要运行也要满足另一个条件，那就是需要调用timer函数，只有当timer函数运行的时候timer函数里面写的那些东西才会生效或者说被激活，deco函数才会定义成功。到此，test=timer(test1)这句代码的意思就是，先调用timer函数让deco函数的定义生效，同时将要被装饰的函数test1函数的地址传入，让deco函数里面的func函数生效，这是timer函数又会将deco函数的地址返回，并将地址赋值给test1这个变量。然后下面的test1后面加上括号，变成test1()的形式，就可以运行了。这样一个原始版的装饰器就写完了。 接下来要写一个真实装饰器的实例 import time def timer(func): def deco(): start_time = time.time() func() stop_time = time.time() print('the func run time is %s' %(stop_time-start_time)) return deco @timer #这里等于 test = timer(test),要装饰哪个函数,就在哪个函数前面加上这个 def test(): time.sleep(2) print('this is test...') test() 上面这些都是一些比较基本的，如果装饰有参数的函数且参数的个数还都不一定怎么办呢？下面写一个高级案例 — 有参数的装饰器 高级案例 — 有参数装饰器 import time def timer(func): def deco(*args,**kwargs): #在这里接收参数 start_time = time.time() func(*args,**kwargs) stop_time = time.time() print('the func run time is %s' %(stop_time-start_time)) return deco @timer def test(name): time.sleep(2) print('this is test...',name) test('vector') 如果原test函数里面有返回值，被装饰后我们打印它print(test())，结果会是none。因为这时的test=deco，而deco没有返回值，所以打印不出来。这样就会出现一个问题，如果test函数有返回值，test函数的一个功能（返回值）就会被弄丢了。 解决办法看下面案例。 高高级案例 — 有返回值的装饰器 import time def timer(func): def deco(*args,**kwargs): start_time = time.time() res = func(*args,**kwargs) stop_time = time.time() print('the func run time is %s' %(stop_time-start_time)) return res #这里将func的返回值返回 return deco @timer def test(name): time.sleep(2) print('this is test...',name) return 'asdfasdfgdfgd' print(test('vector')) 这样就可以打印出返回值了。 还有些时候我们需要给装饰器进行传参，给内部使用。解决方案看下面。 高高高级案例 — 给装饰器传参 import time def timer(temp): print('this is ',temp) #这里是加进来的参数 def out(func): def deco(*args,**kwargs): start_time = time.time() res = func(*args,**kwargs) stop_time = time.time() print('the func run time is %s' %(stop_time-start_time)) return res return deco return out @timer('temp') def test(name): time.sleep(2) print('this is test...',name) return 'asdfasdfgdfgd' print(test('vector')) 实际上就是整体又在外面加了一层内嵌函数。 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路5 - 函数","slug":"Python学习之路5-函数","date":"2017-09-19T08:25:00.000Z","updated":"2019-07-27T08:18:43.645Z","comments":true,"path":"2017/09/19/Python学习之路5-函数/","link":"","permalink":"https://imzry.github.io/2017/09/19/Python学习之路5-函数/","excerpt":"","text":"函数定义方式： def func(): \"这里面写函数的描述\" 这里写代码 return x #如果没有返回值就叫\"过程\"，函数和过程的区别就是有无返回值 实例 def fun1(): \"这里是测试\" print('这是第一个函数') return 0 fun1() #调用函数 &nbsp; 函数传参 def test(x,y,z): print(x) print(y) print(z) test(3,3,5) #这样传的参数叫做位置参数, 位置是一一对应的 test(x=5,y=4,z=3) #这样传的参数叫做关键参数, 位置可以不用一一对应 这里需要注意的是，关键参数是不能写在位置参数前面的。例如 test(x=4,5,5) 这样x是用了关键参数，y和z用了位置参数，这样就是错的。但是 test(3,y=4,z=6) 这样位置参数x在关键参数y和z的前面，这样就是可以的。同理 test(3,z=6,y=4) 这样也是可以的。 &nbsp; 参数组如果我要传入的参数数量不固定，就在形参列表里写 *变量名 来实现。 def test(*args): print(args) #打印出来的是一个元组 test(3,3,5) #这样我传多少个参数都没问题了 test(*[3,4,5,6,6,4]) #这是第二种传值方式 &nbsp; 传入字典 如果我想传入字典就在形参的位置用 **变量名 来实现 def test(**args): print(args) #打印出来的是一个字典 test(name='vector',age=3) &nbsp; 高阶函数（满足下列条件之一就是高阶函数）a：把一个函数名当作形参传给另一个函数(在不修改被装饰函数源代码的情况下修改其功能,但是调用方式变了) def bar(): print('this is bar...') bar() print('----------------------------------') def test(func): #在这里增加了功能 print(func) test(bar) #但是这里修改了调用方式 b：返回值中包含函数名(不修改函数的调用方式,而修改函数功能) def bar(): print('this is bar...') bar() print('----------------------------------') def test(func): #在这里增加了功能 print(func) return func #这里返回了函数地址 bar = test(bar) #将函数地址赋给一个变量,该变量和传入函数同名 bar() #这个变量加上括号,就可以当函数用了,同时又没有修改函数的调用方式 &nbsp; 嵌套函数 x = 1 def test1(): def test2(): def test3(): x = 3 print(x) test3() test2() test1() 像这样在一个函数里面再定义一个函数就叫做嵌套函数。 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路4 - 文件操作&编码转换","slug":"Python学习之路4-文件操作-编码转换","date":"2017-09-19T08:18:00.000Z","updated":"2019-07-27T08:18:40.282Z","comments":true,"path":"2017/09/19/Python学习之路4-文件操作-编码转换/","link":"","permalink":"https://imzry.github.io/2017/09/19/Python学习之路4-文件操作-编码转换/","excerpt":"","text":"文件操作文件操作大概分三步： 把文件打开。 操作文件。 把文件关上。 &nbsp; 打开文件 打开文件用open()函数，打开成功后返回一个资源，具体语法如下。 open(要打开的文件,打开方式,打开文件的格式，默认为utf-8) #例如 f = open('passengers.txt','r',encoding='utf-8') 上例用open以只读的模式打开文件，因为该文本是utf-8编码的，所以第三个参数是utf-8 w 模式是写入，是创建一个新文件的写，所以如果已经有了该文件就会被覆盖掉，注意安全! a 模式是追加模式，可读；不存在则创建；存在则只追加内容； “+” 表示可以同时读写某个文件 r+，可读写文件。【可读；可写；可追加】 w+，写读 a+，可读，可追加 “U”表示在读取时，可以将 \\r \\n \\r\\n自动转换成 \\n （与 r 或 r+ 模式同使用） rU r+U “b”表示处理二进制文件（如：FTP发送上传ISO镜像文件，linux可忽略，windows处理二进制文件时需标注） rb #当加b时，就不用写encoding参数了 wb #用二进制打印出来的结果会包裹在 b’ 和 ‘ 中 ab &nbsp; 读取文件 data = f.read() #然后用read读取文件，里面可以传参输入5就是读5个字符，不输入就是读所有字符 #读取所有内容，文件指针就移动到了文件末尾 data = f.readline() #读取一行内容 data = f.readlines() #将每一行变成一个元素，组成一个列表 #注意，readlines是将文件内容读取后放到内存里，所以它只能读小文件,不能读大文件 下面是读取大文件最好的方式 for line in f: print(line) #这是读取大文件最好的方式，每次只读一行到内存当中，读下一行的时候就会覆盖当前内存当中的数据 &nbsp; 写入文件 f.write('这里是写入的内容') #用write来写入内容 print(f.tell()) #返回指针的位置 f.seek(0) #移动指针的位置，0代表移动到第0个的位置上 print(f.encoding) #打印文件的编码 print(f.fileno()) #打印文件的编号 print(f.name) #打印打开的文件名字 print(f.seekable()) #判断文件是否可读 print(f.writable()) #判断文件是否可写 print(f.flush()) #强制刷新缓存 print(f.closed) #判断文件是否关闭 f.truncate(10) #从头开始截取10个字符 &nbsp; 关闭文件 手动关闭文件用close()函数。 f.close() #关闭文件 自动关闭文件。 with open() as f1: pass pass # 资源只会在with里面打开，如果执行完毕则会自动关闭资源 #并且可以用下面这种方式同时打开多个资源 with open() as f1，open() as f2 ,\\ open() as f3，open() as f4: pass pass &nbsp; ########下面是一个修改文件的案例 f = open('passengers','r',encoding='utf-8') f_new = open('new','w',encoding='utf-8') for line in f: if \"漂浮在一片无奈\" in line: line = line.replace('漂浮在一片无奈','人类的渺小') # replace函数在字符串操作文章中可见 f_new.write(line) f.close() 其实就是将一个文件的内容在内存中修改完后写入到另一个文件中 因为Python中没有直接修改文件内容的方法。 &nbsp; #######修改文件的另一种方法 file_data = \"\" with open(file，\"r\"，encoding=\"utf-8\") as f: for line in f: if old_str in line: line = line.replace(old_str,new_str) file_data += line with open(file,\"w\",encoding=\"utf-8\") as f: f.write(file_data) 这种方法是先将所以的内容都读出来，并且再写到同一个文件中。 &nbsp; 编码之间的转换需知：1.在python2默认编码是ASCII，python3里默认是unicode。2.unicode 分为 utf-32(占4个字节),utf-16(占两个字节)，utf-8(占1-4个字节)，so utf-16就是现在最常用的unicode版本，不过在文件里存的还是utf-8，因为utf8省空间。3.在py3中encode,在转码的同时还会把string 变成bytes类型，decode在解码的同时还会把bytes变回string。 原理图： &nbsp; utf-8转gbk： 我需要先用decode()解码成为Unicode，然后再用encode()转换成gbk decode()函数传入一个参数，参数为我当前的编码是什么，或者说我要将什么编码转换成Unicode; encode()函数传入一个参数，参数为我要转换成什么编码 如果不传参则默认是utf-8gbk转utf-8也是同理 也就是说Unicode作为中间编码，用来完成utf-8和gbk之间的转换。 str = '你好' #假设当前为utf-8 注意:Python3里面的默认编码为Unicode str = str.decode('utf-8') #将utf-8转换为Unicode str = str.encode('gbk') #将Unicode转换为gbk print(str) 如果该文件为gbk，同时Python3的默认编码又是Unicode，则需要告诉程序不要按照默认的编码去执行，要按照gbk的编码去执行，这时就要在文件最顶端声明文件编码格式如下： -- coding:gbk --Python3默认是Unicode,而文件又是utf-8类型,两个编码不统一输入中文还不会乱码是因为utf-8是Unicode的一个扩展集,所以Python3默认支持中文不乱码。 在Python3中执行了encode()后，除了将编码改变了之外，还将它变为byte类型。 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路3 - 字符串操作&字典","slug":"Python学习之路3-字符串操作-字典","date":"2017-09-19T07:19:00.000Z","updated":"2019-07-27T08:18:36.704Z","comments":true,"path":"2017/09/19/Python学习之路3-字符串操作-字典/","link":"","permalink":"https://imzry.github.io/2017/09/19/Python学习之路3-字符串操作-字典/","excerpt":"","text":"本节内容： 常用的字符串处理。 格式化输出字符串。 字符串的替换。 字符串和二进制的相互转化。 字典的操作 字符串操作&nbsp;常用的字符串处理 name = 'vector' print(name.capitalize()) # 首字母大写 print(name.count('e')) # 判断字符e在字符串中有多少个 print(name.center(50,'-')) # 一共打印50个字符,将vector放在中间,两边用-填充 print(name.endswith('r')) # 判断字符串以什么结尾, 如果是以r结尾则返回true print(name.expandtabs(tabsize=10)) # 如果在字符串中加入\\t,则在该位置上加入tabsize个空格 print(name.find('ec')) # 找到e在字符串中的位置 print(name.isalnum()) # 如果字符串里面只包含英文和数字, 则返回True print(name.isalpha()) # 如果字符串里面是纯英文, 则返回True print(name.isdecimal()) # 如果字符串是十进制数字, 则返回True print(name.isdigit()) # 如果字符串是否为整数, 则返回True print(name.isidentifier()) # 判断是否是一个合法的标识符(变量名), 合法则返回True print(name.islower()) # 判断是否为小写, 是则返回True print(name.isupper()) # 判断是否为大写, 是则返回True print(name.isspace()) # 判断是否为空格, 是则返回True print('My Name Is'.istitle()) # 判断是否为标题(首字符大写), 是则返回True print('+'.join(['1','2','3'])) # 将列表里面的每个元素用'+'拼接起来 print(name.ljust(50,\"*\")) # 如果字符串长度小于50, 则不够的在左侧用*补充 print(name.rjust(50,\"*\")) # 如果字符串长度小于50, 则不够的在右侧用*补充 print(name.lower()) # 将大写变成小写 print(name.upper()) # 将小写变成大写 print('\\nvector'.lstrip()) # 去掉字符串左边的空格和回车 print('vector\\n'.rstrip()) # 去掉字符串右边的空格和回车 print('\\nvector\\n'.strip()) # 去掉字符串两边的空格和回车 print('name is a book'.rfind('a')) # 从右边开始找a,返回找到的位置 print('name is a book'.split(' ')) # 将字符串按照空格为界分装成列表, 不写参数则分隔符默认为空格 print('name is \\na book'.splitlines()) # 将字符串根据换行符为界分装成列表 print('name is a book'.swapcase()) # 大小写互换 print('name is a book'.title()) # 将字符串变成标题(首字母大写) print('name'.zfill(50)) # 如果字符串不够50个,则在左边用0填充 格式化输出字符串&lt;/strong&gt; name = 'vector {name} {age}' print(name.format(name = 'rev',age=123)) # 格式化字符串 print(name.format_map({'name':'rev','age':123})) # 字典的形式格式化字符串 字符串替换 #先用maketrans设置替换规则, 然后用translate执行替换 p = str.maketrans('asdfgn','123456') #第一个参数是被替换的字符,第二个参数是替换的字符 print('name'.translate(p)) # 将规则p传入,打印出来的就是61me,因为n和a被6和1替换掉了 print('name'.replace('n','b',1)) # 将n换成b,第三个参数表示替换几个,如果不写则默认全部替换 字符串和二进制的相互转化 msg = '我爱大延边日不落帝国' print(msg) # 字符串输出 print(msg.encode(encoding='utf-8')) # 将字符串转换成二进制 print(msg.encode(encoding='utf-8').decode(encoding='utf-8')) # 将二进制转换成字符串 > encode参数表示之前是什么格式的，decode参数表示要转换成什么格式的。 > 如果encode和decode不写参数，默认就是utf-8。 &nbsp; ### 字典 字典一种key - value 的数据类型，使用就像我们上学用的字典，通过笔划、字母来查对应页的详细内容。 字典的特性： * dict是无序的 * key必须是唯一的,so 天生去重 语法： info = { 'str1':'zhangsan', 'str2':'lisi', 'str3':'wangwu', 'str4':'zhaoliu' } &nbsp; 常见的字典操作： info = { 'str1':'zhangsan', 'str2':'lisi', 'str3':'wangwu', 'str4':'zhaoliu' } print(info) # 打印全部字典 print(info['str2']) # 根据键名打印字典元素 info['str1'] = 'yangzirui' # 这样就会修改值, 如果键名不存在则会直接创建 del info['str2'] # 删除该元素 info.pop('str2') # 这也是删除 print(info.popitem()) # 随机删除一个, 并返回他的键值对 print(info['str1']) # 打印数据, 如果键名不存在, 就会报错,不推荐用 print(info.get('str2')) # 打印数据, 如果键名不存在, 则返回none, 推荐 print('str1' in info) # 判断键名是否存在,存在打印true,否则打印false aaa = info.setdefault('str5','liangsohohfefho') # 如果info里面有键为str5的,则直接返回对应的值;如果没有,则创建后返回对应的值 a = { 'str1':'asdfsdfd', 1:2, 2:3 } info.update(a) # 将字典a合并到info中,如果有交叉,则用a字典中的值 info.items() # 将字典转成列表, 列表中的每个元素都由元组组成,每个元组又原字典的每个键值对组成 c = dict.fromkeys([1,2,3],'test') # 创建一个新字典, 键为1,2,3, 值均为test, 如果不写值,则均为none;后面赋的值是三个键共有的, 所以改一个就全都改了 &nbsp; 循环字典： info = { 'str1':'zhangsan', 'str2':'lisi', 'str3':'wangwu', 'str4':'zhaoliu' } #第一种循环方法 for i in info: print(i,info[i]) # 这应该是最基本的循环了 # 第二种循环方法 for k,v in info.items(): print(k,v) # 这种循环方式的效率没有第一种循环效率高,因为这种需要将字典转换成列表 输出结果：（两种循环方式均是这样） &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路2 - 列表和元组","slug":"Python学习之路2-列表和元组","date":"2017-09-05T09:52:00.000Z","updated":"2019-07-27T08:18:33.339Z","comments":true,"path":"2017/09/05/Python学习之路2-列表和元组/","link":"","permalink":"https://imzry.github.io/2017/09/05/Python学习之路2-列表和元组/","excerpt":"","text":"列表概念：Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 列表的使用 names = ['zhangsan','lisi','wangwu','zhaoliu'] //定义一个了列表 print(names) //输出列表的所有内容 print(names[0]) //输出列表的第0个内容 //用索引来访问list中每一个位置的元素，记得索引是从`0`开始的。 输出结果： 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： names = ['zhangsan','lisi','wangwu','zhaoliu','vector'] print(names[-1]) 输出结果： &nbsp;用len()函数可以获得list元素的个数。 names = ['zhangsan','lisi','wangwu','zhaoliu','yangzirui'] print(len(names)) 输出结果： &nbsp;当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引还可以是len(classmates) - 1。 切片如果想取出中间一段连续的元素，则用name[1:3]的方式，这个参数是左闭右开的。也就是说从第1位取到第2位。 names = ['zhangsan','lisi','wangwu','zhaoliu'] print(names[1:3])# 切片 输出结果： 跳着切片 names = ['zhangsan','lisi','wangwu','zhaoliu'] print(names[0:-1:2]) # 从第0个到倒数第2个, 每两个元素取一个 输出结果： 倒着切片 names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu'] print(names[-3,-1]) # 这也是左闭右开的，表示从倒数第三个切到倒数第二个 # 如果想切到倒数第一个, 就这样写 name[-3:] 这样就表示从倒数第三个切到最后一个了 输出结果： 追加元素如果想在列表的最后面追加一个元素, 就用函数append(‘元素’)。 names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu'] names.append('sunqi') print(names) 输出结果： 插入元素插在任意元素的前面, 用函数insert(2,’元素’)。 names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu'] names.insert(1,'yangsan') # 插在下标为1的元素的前面 print(names) 输出结果： 修改元素 names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu'] names[2] = 'shenmegui' print(names) 输出结果： 删除元素的三种方法 names = ['zhangsan','lisi','wangwu','zhaoliu'] names.remove('shenmegui') # 根据内容删除 del names[2] # 根据下标删除 names.pop(2) # 如果输入下标,则效果=del names[2], 如果不输入下标,则默认删除最后一个元素 根据元素内容找到元素的下标 names = ['zhangsan','lisi','wangwu','zhaoliu','vector','zhaoliu'] print(names.index('zhangsan')) //利用index函数将下标取出来 # 还有一种方式是在循环的时候取出下标 for i in enumerate(names): print(i) # 这样取的时候就会有下标 # 但是如果我想把下标分离出来, 该怎么处理 for index,i in enumerate(names): print(index,i) # 这样index里面就装了分离出来的下标 计算某个元素的个数 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] print(names.count('zhangsan')) 输出结果： 清空列表 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] names.clear() 翻转列表 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] names.reverse() print(names) 输出结果： 排序规则是按照ASCII码表的顺序排的。 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] names.sort() print(names) 输出结果： 追加合并 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] names2 = [1,2,3,4] names.extend(names2) print(names) 输出结果： 浅拷贝列表这个第一维时是深拷贝，第二维开始是浅拷贝。 names = ['zhangsan','lisi','wangwu','zhaoliu'] names3 = names.copy() // 第一种方式 p1 = names[:] // 第二种方式 p2 = list(names) // 第三种方式 深拷贝 &nbsp;需要引入copy模块 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] import copy names2 = copy.copy(names) 循环列表 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] for i in names: print(i) 输出结果： 判断一个元素是否在列表里 names = ['zhangsan','lisi','zhangsan','zhaoliu','vector','zhaoliu'] if 'zhangsan' in names: print('存在') 输出结果： 元组元组就是只能查数据的列表。 定义格式： names = ('zhangsan','lisi') 它只有两个方法, count 和 index。 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"Python学习之路1 - 基础入门","slug":"Python学习之路1-基础入门","date":"2017-09-04T10:06:00.000Z","updated":"2019-07-27T08:18:26.653Z","comments":true,"path":"2017/09/04/Python学习之路1-基础入门/","link":"","permalink":"https://imzry.github.io/2017/09/04/Python学习之路1-基础入门/","excerpt":"","text":"本文内容 Python介绍 安装Python解释器 输出 变量 输入 条件判断语句 循环语句 模块讲解 三元运算 字符串和二进制的相互转化 &nbsp;本系列文章使用的Python版本为3.6.2 使用开发工具为Pycharm2017 &nbsp; 一、Python介绍Python的创始人为吉多&middot;范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多&middot;范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。&nbsp;&nbsp; 最新的TIOBE排行榜，Python赶超PHP占据第五，&nbsp;Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。 ![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830190706483-1713022637.png) **目前Python主要应用领域：** * **云计算：**云计算最火的语言， 典型应用OpenStack * **WEB开发：**众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣。。。， 典型WEB框架有Django * **科学运算、人工智能：**典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas * **系统运维：**运维人员必备语言 * **金融**：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java,尤其擅长策略回测 * **图形GUI：**PyQT, WxPython,TkInter **Python在一些公司的应用：** * 谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发 * CIA：美国中情局网站就是用Python开发的 * NASA：美国航天局(NASA)大量使用Python进行数据分析和运算 * YouTube：世界上最大的视频网站YouTube就是用Python开发的 * Dropbox：美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载 * Instagram：美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发 * Facebook：大量的基础库均通过Python实现的 * Redhat：世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的 * 豆瓣：公司几乎所有的业务均是通过Python开发的 * 知乎：国内最大的问答社区，通过Python开发(国外Quora) * 春雨医生：国内知名的在线医疗网站是用Python开发的 * 除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。&nbsp; ### **Python&nbsp;****是一门什么样的语言？** 编程语言主要从以下几个角度为进行分类，编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言，每个分类代表什么意思呢，我们一起来看一下。 #### 编译和解释的区别 编译器是把源程序的每一条语句都编译成机器语言，并保存成二进制文件，这样运行时计算机可以直接以机器语言来运行此程序，速度很快；&nbsp; 而解释器则是只在执行程序时，才一条一条的解释成机器语言给计算机来执行，所以运行速度是不如编译后的程序运行的快的。&nbsp; 这是因为计算机不能直接认识并执行我们写的语句，它只能认识机器语言(是二进制的形式)。 就好像你想看一本英文书，编译器会将整本书翻译成中文供你观看，这时你看的就会很方便，怎么反复看都没有问题；解释器只会解释你当前想要看的语句，如果你想再次看一遍同样的语句则需要再次找解释器解释一遍，这样就会给你的阅读带来麻烦。 &nbsp; **动态语言和静态语言** 通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。 （1）动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。 （2）静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。 &nbsp; **强类型定义语言和弱类型定义语言** （1）强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 （2）弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，&ldquo;这门语言是不是动态语言&rdquo;与&ldquo;这门语言是否类型安全&rdquo;之间是完全没有联系的！ 例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。 &nbsp; 通过上面这些介绍，我们可以得出，python是一门动态解释性的强类型定义语言。那这些基因使成就了Python的哪些优缺点呢？我们继续往下看。 &nbsp; **Python的优点** 当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作&ldquo;内置电池（batteries included）&rdquo;。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 龟叔给Python的定位是&ldquo;优雅&rdquo;、&ldquo;明确&rdquo;、&ldquo;简单&rdquo;，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 **Python的缺点** 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。 ![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830172927483-1736869329.png) 第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。 再说了，现在如火如荼的开源运动和互联网自由开放的精神是一致的，互联网上有无数非常优秀的像Linux一样的开源代码，我们千万不要高估自己写的代码真的有非常大的&ldquo;商业价值&rdquo;。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了，一旦开源，就没人敢用他们的产品了。 &nbsp;![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830172946187-1723418191.png) &nbsp; ## 二、安装Python解释器 ### 在Mac上安装Python 如果你正在使用Mac，系统是OS X 10.8~10.10，那么系统自带的Python版本是2.7。要安装最新的Python 3.6，有两个方法： 方法一：从Python官网下载Python 3.6的安装程序（网速慢的同学请移步国内镜像），双击运行并安装； 方法二：如果安装了Homebrew，直接通过命令`brew install python3`安装即可。 ### 在Linux上安装Python 如果你正在使用Linux，那么基本代表你有着Linux管理经验，Linux上自带Python2，如果想升级到最新版应该难不倒你的。 ### 在Windows上安装Python 首先，根据你的Windows版本（64位还是32位）从Python的官方网站下载Python 3.6对应的64位安装程序或32位安装程序，然后，运行下载的EXE安装包： ![](http://images2017.cnblogs.com/blog/1204715/201708/1204715-20170830175523671-794653867.png) &nbsp; 特别要注意勾上`Add Python 3.6 to PATH`，然后点&ldquo;Install Now&rdquo;即可完成安装。 &nbsp; 三、输出输出方式经常使用的有两种，第一种是print()函数，下面我们输出hello world。 print(\"hello world\") 输出结果： 第二种输出方式需要引入sys库，然后使用sys.stdout.write()函数输出。 import sys sys.stdout.write(\"afsd\") 输出结果： 从输出结果可以看出两种输出方式的差别，print()函数输出结果后会再加一个换行，而sys.stdout.write()则没有换行。 &nbsp;Python和其他常用高级语言不同的地方是Python一条语句结束时不需要加分号，并且在Python中也不会用到大括号，Python的语句就只是用换行符和缩进来表示语句之间的关系。 换行就表示一条语句的结束，缩进表示语句间的包含关系。 四、变量由于Python是动态类型语言，所以不需要定义变量类型，直接写变量名就可以。 name = \"my name is Vector\" print(name) 输出结果： 在Python3中是可以直接输入中文的，例如print（&ldquo;姓名&rdquo;）这样，但是在Python2中需要在文件的顶部加上 &nbsp;-- coding:utf-8 -- 这句话，因为Python3的默认字符为Unicode，而Python2的默认字符为ASCII。 &nbsp;在Python中不仅有单行的字符串，还有多行的字符串，多行字符串用 ‘’’内容’’’ 标记，如下。 msg = ''' 这里是第一行 这里是第二行 这里是第三行 ''' print(msg) 输出结果： &nbsp; 注释Python中的单行注释用 # 来注释，如下。 print('hello world') #这里即将输出hello world 多行注释用三个单引号来标记 ‘’’内容’’’，如下。 ''' 这里是第一行注释 这里是第二行注释 这里是第三行注释 ''' 在Python中单引号和双引号没有区别，都不会转义其他字符。 &nbsp; 五、输入&nbsp;用户输入通常我们用input()函数，如下。 username = input('username:') password = input('password:') print(username,password) 我们输入vector和asd123 输出结果： 有了输入后，我们就可以控制格式化输出了。 第一种格式化输出方式 name = input('name:') age = input('age:') info = ''' ------------- Info -------------- Name:''' + name + ''' age:''' + age + ''' ------------- Over -------------- ''' print(info) 这里我们输入vector和18 输出结果： 第二种格式化输出方式用 %s %d %f 等来控制格式，并在结尾一次传入参数，传参格式为 %(参数1,参数2,…) &nbsp;%s代表字符串，%d代表正数，%f代表浮点数。 name = input('name:') age = int(input('age:')) info = ''' ------------- Info -------------- Name:%s age:%d ------------- Over -------------- '''%(name,age) print(info) 输出结果： 如果想将输出的内容变成红色,则用\\033[31;1m%s\\033[0m 如果想将输出的内容变成绿色,则用\\033[32;1m%s\\033[0m 格式：\\033[显示方式;前景色;背景色m 说明： 前景色 背景色 颜色 --------------------------------------- 30 40 黑色 31 41 红色 32 42 绿色 33 43 黃色 34 44 蓝色 35 45 紫红色 36 46 青蓝色 37 47 白色 显示方式 意义 ------------------------- 0 终端默认设置 1 高亮显示 4 使用下划线 5 闪烁 7 反白显示 8 不可见 例子： \\033[1;31;40m &lt;!--1-高亮显示 31-前景色红色 40-背景色黑色--&gt; \\033[0m &lt;!--采用终端默认设置，即取消颜色设置--&gt; 下面演示一下输出结果带颜色的例子： name = input('name:') age = int(input('age:')) info = ''' ------------- Info -------------- Name:\\033[31;1m%s\\033[0m #输出结果为红色 age:\\033[32;1m%s\\033[0m #输出结果为绿色 ------------- Over -------------- '''%(name,age) print(info) 输出结果： 第三种格式化输出方式在字符串中插入形参（形参用大括号标记{形参}），最后在结尾给形参赋值。 name = input('name:') age = int(input('age:')) info = ''' ------------- Info -------------- Name:{_name} age:{_age} ------------- Over -------------- '''.format(_name=name,_age=age) print(info) 输出结果： 第四种格式化输出方式形参用数字表示，在结尾直接按照顺序给形参赋值。 name = input('name:') age = int(input('age:')) info = ''' ------------- Info -------------- Name:{0} age:{1} ------------- Over -------------- '''.format(name,age) print(info) 输出结果： &nbsp; 输入变成密文需要引入getpass模块。 import getpass password = getpass.getpass(\"password:\") print(password) 但是这个getpass()这个函数在pycharm中不好使，在其他工具中好使。 ## 六、条件判断语句 格式： if 条件1 and 条件2 or 条件3: pass # 注意这里一定要有缩进 elif 条件4 and 条件5: pass else: pass 例子： _username = 'rev' _password = 'rev123' username = input('username:') password = input('password:') if _username == username and _password == password: print('Welcome user {name} login...'.format(name = username))# 注意这里一定要有缩进 elif _username == username and _password != password: print('password error!') else: print('login fail..')# 注意这里一定要有缩进 七、循环语句循环语句之whilePython中的while还有else处理。 例子： while True: print('this is loop...') break else: print('如果while循环条件不符合了，则执行这里的代码') 循环语句之for格式1： for i in range(10): print('loop ',i) > 这里的range代表循环次数，i 从0来是循环 输出结果： ![](http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905151712335-219987765.png) **格式2：** for i in range(0,10,2): print('loop ',i) > range中的第一个参数代表从几开始，第二个参数代表到几结束（不包括10），第三个参数2代表隔一个执行一次 **格式3：** for i in \"fasdfasd\": print('loop ',i) > Python中的for循环还可以循环字符串、列表、元组等。 &nbsp;输出结果： ![](http://images2017.cnblogs.com/blog/1204715/201709/1204715-20170905152420554-1608007279.png) ## 八、模块讲解 ### 模块之sys print(sys.path) # 打印环境变量 print(sys.argv) # 打印当前脚本的路径，在pycharm中打印绝对路径，在命令行中打印相对路径（本来打印的就是相对路径） one = sys.argv[1] #用来在外部调用的时候传参, 1代表传入的第一个参数, two = sys.argv[2] #2代表传入的第二个参数, 这样外部调用的时候就可以传多个参数了 模块之os print(os.system('dir')) # system函数就是命令行 cmd = os.system('dir') print(cmd) # 这里输出的是 0 因为，system是直接把输出到屏幕上，并不是返回，如果输出成功则返回0 cmd = os.popen('dir').read() #popen()方法返回的是该对象的地址，read()方法是将地址中的内容读出来 print(cmd) # 创建目录函数 os.mkdir('new_dir') 九、三元运算 //result = 值1 if 条件 else 值2 a,b,c = 1,3,5 d = a if a&gt;b else c print(d) # d = c = 5 # 如果条件为真：result = 值1 # 如果条件为假：result = 值2 十、字符串和二进制的相互转化 msg = '我爱大延边日不落帝国' print(msg) # 字符串输出 print(msg.encode(encoding='utf-8')) # 将字符串转换成二进制 print(msg.encode(encoding='utf-8').decode(encoding='utf-8')) # 将二进制转换成字符串 # 如果encode和decode不写参数，默认就是utf-8 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://imzry.github.io/tags/Python/"}]},{"title":"thinkphp简洁、美观、靠谱的分页类","slug":"thinkphp简洁、美观、靠谱的分页类","date":"2017-09-04T10:02:00.000Z","updated":"2019-07-27T08:19:20.577Z","comments":true,"path":"2017/09/04/thinkphp简洁、美观、靠谱的分页类/","link":"","permalink":"https://imzry.github.io/2017/09/04/thinkphp简洁、美观、靠谱的分页类/","excerpt":"","text":"废话不多说先上图预览下；即本博客的分页； 这个分页类是在thinkphp框架内置的分页类的基础上修改而来； 原分页类的一些设计，在实际运用中感觉不是很方便； 1：只有一页内容时不显示分页； 2：原分页类在当前页是第一页和最后一页的时候，不显示第一页和最后一页的按钮； 3：分页数比较少时不显示首页和末页按钮； 4：包裹分页内容的父级div没有class； &nbsp; 针对以上问题逐一进行了修改成如下； 1：如果没有数据不显示分页，如果有一页及以上内容即显示分页； 2：默认就显示第一页和最后一页按钮，但是在当前页是第一页和最后一页的时候按钮点击无效果； 3：默认就显示首页和末页按钮； 4：为包裹分页内容的父级div添加名为page的class； 5：显示总共查出的内容条数； &nbsp; 示例环境：thinkphp3.2.3； 分页类目录：/Thinkphp/Library/Org/Bjy/Page.class.PHP 分页类代码如下： &lt;?php // +---------------------------------------------------------------------- // | ThinkPHP [ WE CAN DO IT JUST THINK IT ] // +---------------------------------------------------------------------- // | Copyright (c) 2006-2014 http://thinkphp.cn All rights reserved. // +---------------------------------------------------------------------- // | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 ) // +---------------------------------------------------------------------- // | Author: 麦当苗儿 &lt;zuojiazi@vip.qq.com&gt; &lt;http://www.zjzit.cn&gt; // +---------------------------------------------------------------------- /* * PHP分页类 * 修改者：白俊遥 * 日 期：2015.5.10 * 邮 箱：baijunyao@baijunyao.com * 博 客：http://baijunyao.com */ namespace Org\\Bjy; class Page{ public $firstRow; // 起始行数 public $listRows; // 列表每页显示行数 public $parameter; // 分页跳转时要带的参数 public $totalRows; // 总行数 public $totalPages; // 分页总页面数 public $rollPage = 5;// 分页栏每页显示的页数 public $lastSuffix = true; // 最后一页是否显示总页数 private $p = 'p'; //分页参数名 private $url = ''; //当前链接URL private $nowPage = 1; // 分页显示定制 private $config = array( 'header' =&gt; '&lt;span class=\"rows\"&gt;共 %TOTAL_ROW% 条记录&lt;/span&gt;', 'first' =&gt; '首页', 'prev' =&gt; '上一页', 'next' =&gt; '下一页', 'last' =&gt; '末页', 'theme' =&gt; '%FIRST% %UP_PAGE% %LINK_PAGE% %DOWN_PAGE% %END% %HEADER%', ); /** * 架构函数 * @param array $totalRows 总的记录数 * @param array $listRows 每页显示记录数 * @param array $parameter 分页跳转的参数 */ public function __construct($totalRows, $listRows=20, $parameter = array()) { C('VAR_PAGE') &amp;&amp; $this-&gt;p = C('VAR_PAGE'); //设置分页参数名称 /* 基础设置 */ $this-&gt;totalRows = $totalRows; //设置总记录数 $this-&gt;listRows = $listRows; //设置每页显示行数 $this-&gt;parameter = empty($parameter) ? $_GET : $parameter; $this-&gt;nowPage = empty($_GET[$this-&gt;p]) ? 1 : intval($_GET[$this-&gt;p]); $this-&gt;nowPage = $this-&gt;nowPage&gt;0 ? $this-&gt;nowPage : 1; $this-&gt;firstRow = $this-&gt;listRows * ($this-&gt;nowPage - 1); } /** * 定制分页链接设置 * @param string $name 设置名称 * @param string $value 设置值 */ public function setConfig($name,$value) { if(isset($this-&gt;config[$name])) { $this-&gt;config[$name] = $value; } } /** * 生成链接URL * @param integer $page 页码 * @return string */ private function url($page){ return str_replace(urlencode('[PAGE]'), $page, $this-&gt;url); } /** * 组装分页链接 * @return string */ public function show() { if(0 == $this-&gt;totalRows) return ''; /* 生成URL */ $this-&gt;parameter[$this-&gt;p] = '[PAGE]'; $this-&gt;url = U(MODULE_NAME.'/'.CONTROLLER_NAME.'/'.ACTION_NAME, $this-&gt;parameter); /* 计算分页信息 */ $this-&gt;totalPages = ceil($this-&gt;totalRows / $this-&gt;listRows); //总页数 if(!empty($this-&gt;totalPages) &amp;&amp; $this-&gt;nowPage &gt; $this-&gt;totalPages) { $this-&gt;nowPage = $this-&gt;totalPages; } /* 计算分页零时变量 */ $now_cool_page = $this-&gt;rollPage/2; $now_cool_page_ceil = ceil($now_cool_page); //上一页 $up_row = $this-&gt;nowPage - 1; $up_page = $up_row &gt; 0 ? '&lt;a class=\"prev\" href=\"' . $this-&gt;url($up_row) . '\"&gt;' . $this-&gt;config['prev'] . '&lt;/a&gt;' : '&lt;a class=\"prev not-allowed\" href=\"javascript:;\"&gt;' . $this-&gt;config['prev'] . '&lt;/a&gt;'; //下一页 $down_row = $this-&gt;nowPage + 1; $down_page = ($down_row &lt;= $this-&gt;totalPages) ? '&lt;a class=\"next\" href=\"' . $this-&gt;url($down_row) . '\"&gt;' . $this-&gt;config['next'] . '&lt;/a&gt;' : '&lt;a class=\"next not-allowed\" href=\"javascript:;\"&gt;' . $this-&gt;config['next'] . '&lt;/a&gt;'; //第一页 $the_first = '&lt;a class=\"first\" href=\"' . $this-&gt;url(1) . '\"&gt;' . $this-&gt;config['first'] . '&lt;/a&gt;'; //最后一页 $the_end = '&lt;a class=\"end\" href=\"' . $this-&gt;url($this-&gt;totalPages) . '\"&gt;' . $this-&gt;config['last'] . '&lt;/a&gt;'; //数字连接 $link_page = \"\"; for($i = 1; $i &lt;= $this-&gt;rollPage; $i++){ if(($this-&gt;nowPage - $now_cool_page) &lt;= 0 ){ $page = $i; }elseif(($this-&gt;nowPage + $now_cool_page - 1) &gt;= $this-&gt;totalPages){ $page = $this-&gt;totalPages - $this-&gt;rollPage + $i; }else{ $page = $this-&gt;nowPage - $now_cool_page_ceil + $i; } if ($page&gt;0) { if($page != $this-&gt;nowPage){ if($page &lt;= $this-&gt;totalPages){ $link_page .= '&lt;a class=\"num\" href=\"' . $this-&gt;url($page) . '\"&gt;' . $page . '&lt;/a&gt;'; }else{ break; } }else{ $link_page .= '&lt;span class=\"current\"&gt;' . $page . '&lt;/span&gt;'; } } } //替换分页内容 $page_str = str_replace( array('%HEADER%', '%NOW_PAGE%', '%UP_PAGE%', '%DOWN_PAGE%', '%FIRST%', '%LINK_PAGE%', '%END%', '%TOTAL_ROW%', '%TOTAL_PAGE%'), array($this-&gt;config['header'], $this-&gt;nowPage, $up_page, $down_page, $the_first, $link_page, $the_end, $this-&gt;totalRows, $this-&gt;totalPages), $this-&gt;config['theme']); return '&lt;div class=\"page\"&gt;'.$page_str.'&lt;/div&gt;'; } } 分页类调用： $count=$this-&gt;where($where)-&gt;count(); $page=new \\Org\\Bjy\\Page($count,$limit); $list=$this-&gt;where($where)-&gt;order('addtime desc')-&gt;limit($page-&gt;firstRow.','.$page-&gt;listRows)-&gt;select(); $show=$page-&gt;show(); 分页类css .b-page { background: #fff; box-shadow: 0px 1px 2px 0px #E2E2E2; } .page { width: 100%; padding: 30px 15px; background: #FFF; text-align: center; overflow: hidden; } .page .first, .page .prev, .page .current, .page .num, .page .current, .page .next, .page .end { padding: 8px 16px; margin: 0px 5px; display: inline-block; color: #008CBA; border: 1px solid #F2F2F2; border-radius: 5px; } .page .first:hover, .page .prev:hover, .page .current:hover, .page .num:hover, .page .current:hover, .page .next:hover, .page .end:hover { text-decoration: none; background: #F8F5F5; } .page .current { background-color: #008CBA; color: #FFF; border-radius: 5px; border: 1px solid #008CBA; } .page .current:hover { text-decoration: none; background: #008CBA; } .page .not-allowed { cursor: not-allowed; } 分页类的使用方法和原thinkphp相同。 本文为白俊遥原创文章 , 原文来自白俊遥博客http://baijunyao.com &nbsp; &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"},{"name":"thinkphp","slug":"thinkphp","permalink":"https://imzry.github.io/tags/thinkphp/"}]},{"title":"PHPCMS v9表单向导中怎么加入验证码","slug":"PHPCMS-v9表单向导中怎么加入验证码","date":"2017-09-04T09:58:00.000Z","updated":"2019-07-27T08:18:11.250Z","comments":true,"path":"2017/09/04/PHPCMS-v9表单向导中怎么加入验证码/","link":"","permalink":"https://imzry.github.io/2017/09/04/PHPCMS-v9表单向导中怎么加入验证码/","excerpt":"","text":"表单想到比较简单，所以没有加入验证码的功能。网上的类似教程又大多数不准确。所以亲自测试了一下，发现下面的方法是可用的。希望对有需求的朋友们有所帮助。 1.首先是调用表单的页面加入验证码。表单js调用模版默认的是 \\phpcms\\templates\\default\\formguide\\show_js.html. 在该文件里面找到这行代码，大概在23行 &lt;tr&gt; &lt;th width=\"80\"&gt;{if $info['star']} &lt;font color=\"red\"&gt;*&lt;/font&gt;{/if} {$info['name']} &lt;/th&gt; &lt;td&gt;{$info['form']} {$info['tips']}&lt;/td&gt; &lt;/tr&gt; {/loop} 在下面加入一行代码。 &lt;tr&gt; &lt;td style=\"text-align:right;\"&gt;验证码&lt;/td&gt; &lt;td colspan=\"2\"&gt; &lt;span title=\"点击更换验证码\" style=\" cursor:pointer;\"&gt; &lt;input type=\"text\" id=\"code\" name=\"code\" size=\"8\" class=\"input-text\"&gt; 请输入图片中的验证码 &lt;/td&gt; &lt;/tr&gt; 2.找到这个文件 \\phpcms\\modules\\formguide\\index.PHP 这个需要修改两处 1）在第三行找到这行代码。 defined('IN_PHPCMS') or exit('No permission resources.'); define('CACHE_MODEL_PATH',PHPCMS_PATH.'caches'.DIRECTORY_SEPARATOR.'caches_model'.DIRECTORY_SEPARATOR.'caches_data'.DIRECTORY_SEPARATOR); 然后在后面加入下面两行代码 $session_storage = 'session_'.pc_base::load_config('system','session_storage'); pc_base::load_sys_class($session_storage); 2）找到下面这行代码 if (isset($_POST['dosubmit'])) { $tablename = 'form_'.$r['tablename']; $this-&gt;m_db-&gt;change_table($tablename); 然后在下面加入下面这段代码 if(!empty($_SESSION['code'])) { //判断验证码 $code = isset($_POST['code']) &amp;&amp; trim($_POST['code']) ? trim($_POST['code']) : showmessage(L('input_code'), HTTP_REFERER); if ($_SESSION['code'] != strtolower($code)) { showmessage(L('code_error'), HTTP_REFERER); } } &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"},{"name":"PHPCMS","slug":"PHPCMS","permalink":"https://imzry.github.io/tags/PHPCMS/"}]},{"title":"C语言函数调用约定","slug":"C语言函数调用约定","date":"2017-09-04T09:54:00.000Z","updated":"2019-07-27T08:24:16.157Z","comments":true,"path":"2017/09/04/C语言函数调用约定/","link":"","permalink":"https://imzry.github.io/2017/09/04/C语言函数调用约定/","excerpt":"","text":"在C语言中，假设我们有这样的一个函数： int function(int a,int b) 调用时只要用result = function(1,2)这样的方式就可以使用这个函数。但是，当高级语言被编译成计算机可以识别的机器码时，有一个问题就凸现出来：在CPU中，计算机没有办法知道一个函数调用需要多少个、什么样的参数，也没有硬件可以保存这些参数。也就是说，计算机不知道怎么给这个函数传递参数，传递参数的工作必须由函数调用者和函数本身来协调。为此，计算机提供了一种被称为栈的数据结构来支持参数传递。 栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入数据，这个操作被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修改。用户也可以从堆栈中取走栈顶，称为弹出栈(pop)，弹出栈后，栈顶下的一个元素变成栈顶，栈顶指针随之修改。 函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈恢复原装。 在参数传递中，有两个很重要的问题必须得到明确说明： 当参数个数多于一个时，按照什么顺序把参数压入堆栈。函数调用后，由谁来把堆栈恢复原装。在高级语言中，通过函数调用约定来说明这两个问题。常见的调用约定有： stdcallcdeclfastcallthiscallnaked callstdcall调用约定stdcall很多时候被称为pascal调用约定，因为pascal是早期很常见的一种教学用计算机程序设计语言，其语法严谨，使用的函数调用约定就是stdcall。在Microsoft C++系列的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。 stdcall调用约定声明的语法为(以前文的那个函数为例）： int __stdcall function(int a,int b) stdcall的调用约定意味着：1）参数从右向左压入堆栈，2）函数自身修改堆栈 3)函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸。 以上述这个函数为例，参数b首先被压栈，然后是参数a，函数调用function(1,2)调用处翻译成汇编语言将变成： push 2 第二个参数入栈push 1 第一个参数入栈call function 调用参数，注意此时自动把cs:eip入栈 而对于函数自身，则可以翻译为： push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复mov ebp,esp 保存堆栈指针mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向aadd eax,[ebp + 0CH] 堆栈中ebp + 12处保存了bmov esp,ebp 恢复esppop ebpret 8 而在编译时，这个函数的名字被翻译成_function@8 注意不同编译器会插入自己的汇编代码以提供编译的通用性，但是大体代码如此。其中在函数开始处保留esp到ebp中，在函数结束恢复是编译器常用的方法。 从函数调用看，2和1依次被push进堆栈，而在函数中又通过相对于ebp(即刚进函数时的堆栈指针）的偏移量存取参数。函数结束后，ret 8表示清理8个字节的堆栈，函数自己恢复了堆栈。 cdecl调用约定cdecl调用约定又称为C调用约定，是C语言缺省的调用约定，它的定义语法是：12int function (int a ,int b) //不加修饰就是C调用约定int __cdecl function(int a,int b)//明确指出C调用约定 在写本文时，出乎我的意料，发现cdecl调用约定的参数压栈顺序是和stdcall是一样的，参数首先由有向左压入堆栈。所不同的是，函数本身不清理堆栈，调用者负责清理堆栈。由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。对于前面的function函数，使用cdecl后的汇编码变成： 调用处push 1push 2call functionadd esp,8 注意：这里调用者在恢复堆栈被调用函数_function处push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复mov ebp,esp 保存堆栈指针mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向aadd eax,[ebp + 0CH] 堆栈中ebp + 12处保存了bmov esp,ebp 恢复esppop ebpret 注意，这里没有修改堆栈 MSDN中说，该修饰自动在函数名前加前导的下划线，因此函数名在符号表中被记录为_function，但是我在编译时似乎没有看到这种变化。 由于参数按照从右向左顺序压栈，因此最开始的参数在最接近栈顶的位置，因此当采用不定个数参数时，第一个参数在栈中的位置肯定能知道，只要不定的参数个数能够根据第一个后者后续的明确的参数确定下来，就可以使用不定参数，例如对于CRT中的sprintf函数，定义为： int sprintf(char* buffer,const char* format,...) 由于所有的不定参数都可以通过format确定，因此使用不定个数的参数是没有问题的。 fastcallfastcall调用约定和stdcall类似，它意味着： 函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈被调用函数清理堆栈函数名修改规则同stdcall其声明语法为：int fastcall function(int a,int b) thiscallthiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着： 参数从右向左入栈如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈。 为了说明这个调用约定，定义如下类和使用代码： 1234567891011121314151617181920212223242526272829class A&#123; public: int function1(int a,int b); int function2(int a,...);&#125;;int A::function1 (int a,int b)&#123; return a+b;&#125;#includeint A::function2(int a,...)&#123; va_list ap; va_start(ap,a); int i; int result = 0; for(i = 0 i &amp;lt; a i ++) &#123; result += va_arg(ap,int); &#125; return result;&#125;void callee()&#123; A a; a.function1 (1,2); a.function2(3,1,2,3);&#125; callee函数被翻译成汇编后就变成：1234567891011121314//函数function1调用0401C1D push 200401C1F push 100401C21 lea ecx,[ebp-8]00401C24 call function1 注意，这里this没有被入栈//函数function2调用00401C29 push 300401C2B push 200401C2D push 100401C2F push 300401C31 lea eax,[ebp-8] 这里引入this指针00401C34 push eax00401C35 call function200401C3A add esp,14h 可见，对于参数个数固定情况下，它类似于stdcall，不定时则类似cdecl naked call这是一个很少见的调用约定，一般程序设计者建议不要使用。编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果。这一般用于实模式驱动程序设计，假设定义一个求和的加法程序，可以定义为： 123456__declspec(naked) int add(int a,int b)&#123; __asm mov eax,a __asm add eax,b __asm ret&#125; 注意，这个函数没有显式的return返回值，返回通过修改eax寄存器实现，而且连退出函数的ret指令都必须显式插入。上面代码被翻译成汇编以后变成： 123mov eax,[ebp+8]add eax,[ebp+12]ret 8 注意这个修饰是和__stdcall及cdecl结合使用的，前面是它和cdecl结合使用的代码，对于和stdcall结合的代码，则变成： 123456__declspec(naked) int __stdcall function(int a,int b)&#123; __asm mov eax,a __asm add eax,b __asm ret 8 //注意后面的8&#125; 至于这种函数被调用，则和普通的cdecl及stdcall调用函数一致。 函数调用约定导致的常见问题如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题，下面是两种常见的问题： 函数原型声明和函数体定义不一致DLL导入函数时声明了不同的函数约定以后者为例，假设我们在dll种声明了一种函数为： 1__declspec(dllexport) int func(int a,int b);//注意，这里没有stdcall，使用的是cdecl 使用时代码为： 1234typedef int (*WINAPI DLLFUNC)func(int a,int b);hLib = LoadLibrary(...);DLLFUNC func = (DLLFUNC)GetProcAddress(...)//这里修改了调用约定result = func(1,2);//导致错误 由于调用者没有理解WINAPI的含义错误的增加了这个修饰，上述代码必然导致堆栈被破坏，MFC在编译时插入的checkesp函数将告诉你，堆栈被破坏了。","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://imzry.github.io/tags/C语言/"}]},{"title":"scanf格式控制符的完整格式","slug":"scanf格式控制符的完整格式","date":"2017-09-04T09:51:00.000Z","updated":"2019-07-27T08:19:05.783Z","comments":true,"path":"2017/09/04/scanf格式控制符的完整格式/","link":"","permalink":"https://imzry.github.io/2017/09/04/scanf格式控制符的完整格式/","excerpt":"","text":"scanf格式控制的完整格式： %&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; m&nbsp;&nbsp;&nbsp;&nbsp; l或h&nbsp;&nbsp;&nbsp;&nbsp; 格式字符 ①格式字符与printf函数中的使用方式相同，以%d、%o、%x、%c、%s、%f、%e，无%u格式、%g格式。 ②可以指定输入数据所占列宽，系统自动按它截取所需数据。如: scanf( “%3d%3d”, &amp;a, &amp;b); 输入：123456 系统自动将123赋给a,456赋给b。 ③%后的&ldquo;&rdquo; 附加说明符，用来表示跳过它相应的数据。例如： scanf( “%2d%*3d%2d”, &amp;a, &amp;b); 如果输入如下信息：1234567。将&ldquo;12 &rdquo;赋给a，&ldquo;67 &rdquo;赋给b。第二个数据&ldquo;345&rdquo;被跳过不赋给任何变量。 ④输入数据时不能规定精度，例如： scanf( “%7.2f”, &amp;a); 是不合法的，不能企图输入：12345.67而使a的值为12345.67。&lt;/span&gt; 附加格式说明字符: ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说明&nbsp; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于输入长整型数据(可用%ld,%lo,%lx)以及double型数据(用%lf或%le) &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于输入短整型数据(可用%hd, %ho, %hx)&nbsp; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 域宽&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定输入数据所占宽度(列数),域宽应为正整数&nbsp; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 表示本输入项在读入后不赋绐相应的变量 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━－－－－－－－－－－－－－－－－－－相关－－－－－－－－－－－－－－－－－－－输入数据流分隔 ①根据格式字符的含义从输入流中取得数据，当输入流中数据类型与格式字符要求不符时，就认为这一项结束。例如： scanf( “%d%c%f”, &amp;a, &amp;b, &amp;c); 如果输入如下信息： 1234r1234.567 则scanf函数在接收数据时发现&ldquo;r&rdquo;类型不匹配，于是把&ldquo;1234&rdquo;转换成整型赋值给a，把&ldquo;r&rdquo;赋给变量b，最后把&ldquo;1234.567&rdquo;转换成实型数据赋给c。 ②根据格式项中指定的域宽分隔出数据项。如语句： scanf( “%2d%3f%4f”, &amp;a, &amp;b, &amp;c); 如果输入如下信息： 123456789012345 则scanf函数在接收数据时根据域宽把12赋值给a,345赋值给b，6789赋值给c。 ③隐示分隔符。空格、跳格符（’\\t’）、换行符（’\\n’）都是C语言认定的数据分隔符。 ④显示分隔符。在scanf函数的两个格式说明项间有一个或多个普通字符，那么在输入数据时，在两个数据之间也必须以这一个或多个字符分隔。如语句： scanf( “a=%d,b=%f,c=%f”, &amp;a, &amp;b, &amp;c); 则输入数据应该为： a=1234,b=67.8,c=98.123 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－关于scanf函数的进一步说明： ①scanf函数中的&ldquo;格式控制&rdquo;后面应当是变量地址，而不应是变量名。例如，如果a、b为整型变量，则 scanf( “%d,%d”, a, b); 是不对的，应将&ldquo;a, b&rdquo;改为 &ldquo;&amp;a, &amp;b&rdquo;。 ②如果在&ldquo;格式控制&rdquo;字符串中除了格式说明以外还有其它字符，则在输入数据时应输入与这些字符相同的字符。例如： scanf( “%d,%d”, &amp;a, &amp;b); 输入时应输入：3，4。3与4之间的逗号应与scanf函数中的&ldquo;格式控制&rdquo;中的逗号相对应，输入其它符号是不对的。 ③在用&ldquo;%c&rdquo;格式输入字符时，空格字符和转义字符都作为有效字符输入。 scanf( “%c%c%c”, &amp;c1, &amp;c2, &amp;c3); 如输入：a b c 。字符 ‘a’ 赋给c1,字符（空格）’&nbsp;&nbsp;&nbsp;&nbsp; ‘ 赋给c2,字符 ‘b’&nbsp;&nbsp;&nbsp;&nbsp; 赋给c3。 ④ scanf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中不使用U说明符.对unsigned型数据用d、o、x说明符输入.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 补充： 对于 const char p = “12232114687ABC12356”; scanf( “%[123]”, buf); // 就把是’1’或’2’或’3’的字读读到buf中，直到遇到一个不是’1’且不是’2’且不是’3’的字符，于是执行后buf应该是”1223211”; %[123]等同于%[231]，等同于%[321]&hellip;&hellip;，列表中的顺序是无所谓的； %[123]也等同于%[1-3]或%[3-1],也就是&ldquo;1至3&rdquo;，对于连续的字符列表这样写就很简单，比如%[a-z]等同%[abc&hellip;省略&hellip;z]； 想想看，%[3-14]应该等同于什么？是&ldquo;3至14&rdquo;吗？当然不是，因为[]中的是字符，而不是数字，所以%[3-14]应该等同于%[3214]，等同于%[1234]； 同理，想只取字母，那就可以写成%[A-Za-z]； 如果列表的第一个字母是^，那么正好相反，比如%A-Za-z的意思就是取字母之外的所有字符。 对于字符串”abDEc123”如果想按照字母和数字读到两个字符串中就应该是 “%[a-zA-Z]%[0-9]”,buf1,buf2 ； 假如我想取一行字符，该怎么办？”%s”是不行的，因为%s遇到空白字符（空格、制表符、\\r、\\n）就结束了，所以可以写成&nbsp;“%\\n%c”，%\\n的作用刚才讲过了，就是读\\n之外的所有字符，也就是说读到\\n为止，%c的作用就是把\\n去掉，否则再次读的时候一直遇到的都是\\n； 所有对%s起作用的控制，都可以用于%[]，比如”%\\n%*c”就表示跳过一行，”%-20\\n“就表示读取\\n前20个字符。&nbsp;&lt;/span&gt;&lt;/span&gt;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://imzry.github.io/tags/C语言/"}]},{"title":"Java学习个人备忘录之线程间的通信","slug":"Java学习个人备忘录之线程间的通信","date":"2017-09-04T09:50:00.000Z","updated":"2019-07-27T08:17:32.731Z","comments":true,"path":"2017/09/04/Java学习个人备忘录之线程间的通信/","link":"","permalink":"https://imzry.github.io/2017/09/04/Java学习个人备忘录之线程间的通信/","excerpt":"","text":"线程间通讯多个线程在处理同一资源,但是任务却不同.&nbsp; class Resource { String name; String sex; } //输入 class Input implements Runnable { Resource r; Input(Resource r) { this.r = r; } public void run() { int i = 0; while(true) { synchronized(r) //保证两个线程用同一个锁 { if (i==0) { r.name = \"mike\"; r.sex = \"nan\"; } else { r.name = \"丽丽\"; r.name = \"女女女女女女女女女\"; } x = (x+1)%2; } } } } //输出 class Output implements Runnable { Resource r; Output(Resource r) { this.r = r; } public void run() { while(true) { synchronized(r) //保证两个线程用同一个锁 { System.out.println(r.name+\".....\"+r.sex); } } } } class ResourceDemo { public static void main(String[] args) { //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); } } 但是这样会造成大量的才重复, 没有交替性。 &nbsp; 等待唤醒机制 涉及的方法:1. wait(): 让线程处于冻结状态, 被wait的线程会被存储到线程池中.2. notify(): 唤醒线程池中一个线程(任意)3. notifyAll(): 唤醒线程池中的所有线程. 这些方法都必须定义在同步中,因为这些方法都是用于操做线程状态的方法.必须要明确到底操做的是哪个锁上的线程. 为什么操做线程的方法wait notify notifyAll定义在了Object类中. 因为这些方法时监视器的方法, 坚持其其实就是锁.锁可以是任意的对象,任意的对象调用的方式一定定义在Object类中的.&nbsp; class Resource { String name; String sex; boolean flag = false; } //输入 class Input implements Runnable { Resource r; Input(Resource r) { this.r = r; } public void run() { int i = 0; while(true) { synchronized(r) //保证两个线程用同一个锁 { if (r.flag) { r.wait(); } if (i==0) { r.name = \"mike\"; r.sex = \"nan\"; } else { r.name = \"丽丽\"; r.name = \"女女女女女女女女女\"; } r.flag = true; r.notify(); //唤醒对方 x = (x+1)%2; } } } } //输出 class Output implements Runnable { Resource r; Output(Resource r) { this.r = r; } public void run() { while(true) { synchronized(r) //保证两个线程用同一个锁 { if (!r.flag) { r.wait(); } System.out.println(r.name+\".....\"+r.sex); r.flag = false; r.notify(); //唤醒对方 } } } } class ResourceDemo2 { public static void main(String[] args) { //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); } } 上面代码的优化 class Resource { private String name; //这里要私有化 private String sex; boolean flag = false; public synchronized void set(String name,String sex) //对数据要可控化 { if (this.flag) try{this.wait();}catch(InterruptedException e){} this.name = name; this.sex = sex; flag = true; this.notify(); } public synchronized void out() { if (this.flag) try{this.wait();}catch(InterruptedException e){} System.out.println(name+\".....\"+sex); flag = false; this.notify(); } } //输入 class Input implements Runnable { Resource r; Input(Resource r) { this.r = r; } public void run() { int i = 0; while(true) { if (i==0) { r.set(\"mike\",\"nan\"); } else { r.set\"丽丽\",\"女女女女女女女女女\"); } x = (x+1)%2; } } } //输出 class Output implements Runnable { Resource r; Output(Resource r) { this.r = r; } public void run() { while(true) { r.out(); } } } class ResourceDemo3 { public static void main(String[] args) { //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); } } &nbsp; 多生产者多消费者问题 class Resource { private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name) { if (flag) try{this.wait();}catch(InterruptedException e){} this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+\".....生产者.....\"+this.name); flag = true; notify(); } public synchronized void out() { if (!flag) try{this.wait();}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\".....消费者.....\"+this.name); flag = false; notify(); } } class Producer implements Runnable { private Resource r; Producer(Resource r) { this.r = r; } public void run() { while (true) { r.set(\"烤鸭\"); } } } class Consumer implements Runnable { private Resource r; Consumer(Resource r) { this.r = r; } public void run() { while(true) { r.out(); } } } class ProducerConsumerDemo { public static void main(String[] args) { Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } 但是这样会出现安全隐患, 从这4个线程上看, 一共分了两组, t0和t1一组, t2和t3一组, 当t1 t2 t3 睡眠时, t0出来后再次唤醒t1, 这时t1是不用判断的if条件的,直接向下继续执行. 这样就又进行了”生产烤鸭”, 所以出现了安全隐患. 解决办法: 将两个if 换成 while, 这样在t1醒来的时候会继续判断flag是否为真. 但是这样又会出现死锁现象, 因为t1判断flag时, flag为真, 这时t1会再次等待,这时4个线程都进入等待状态—-死锁!! &nbsp; 解决办法1将notify换成notifyAll, 这样就一定会唤醒对方的线程,同时自己方的线程因为while循环出不去.&nbsp; class Resource { private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name) { while (flag) try{this.wait();}catch(InterruptedException e){} this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+\".....生产者.....\"+this.name); flag = true; notifyAll(); } public synchronized void out() { while (!flag) try{this.wait();}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\".....消费者.....\"+this.name); flag = false; notifyAll(); } } class Producer implements Runnable { private Resource r; Producer(Resource r) { this.r = r; } public void run() { while (true) { r.set(\"烤鸭\"); } } } class Consumer implements Runnable { private Resource r; Consumer(Resource r) { this.r = r; } public void run() { while(true) { r.out(); } } } class ProducerConsumerDemo { public static void main(String[] args) { Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } > if判断标记只有一次, 会导致不该运行的线程运行了, 出现了数据错误的情况.&nbsp;while判断标记, 解决了线程获取执行权后, 是否要运行。 > notify: 只能唤醒一个线程, 如果本方唤醒了本方, 就没有意义, 而且while判断标记notify会导致死锁.&nbsp;notifyAll解决了, 本方线程一定会唤醒对方线程.&nbsp; **解决办法2:** JDK1.5新特征的解决办法--Lock 可以看出来, 上面的解决方法会造成多次无用的判断, 这会降低效率,可以用这面的方法解决.&nbsp; Lock l = new ReentrantLock(); void show() { l.lock(); //获取锁 code... l.unlock(); //释放锁 } jdk1.5以后将同步和锁封装成了对象.并将操作锁的隐式方法定义到了该对象中,将隐式动作变成了显示动作. 但是如果执行的代码抛出了异常, 这样代码就会一直持有锁,不释放,所以要如下 Lock l = new ReentrantLock(); void show() { l.lock(); //获取锁 try { code... } finally { l.unlock(); //释放锁 } } &nbsp; import java.util.concurrent.locks.* class Resource { private String name; private int count = 1; private boolean flag = false; Lock l = new ReentrantLock();//因为Lock是java.util.concurrent.locks包中的类, 所以要先导入包. public void set(String name) //这里的同步就可以去掉了 { l.lock(); //在这里加上锁 try { while (flag) try{this.wait();}catch(InterruptedException e){} this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+\".....生产者.....\"+this.name); flag = true; notifyAll(); } finally { l.unlock(); } } public void out() { l.lock(); try { while (!flag) try{this.wait();}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\".....消费者.....\"+this.name); flag = false; notifyAll(); } finally { l.unlock(); } } } class Producer implements Runnable { private Resource r; Producer(Resource r) { this.r = r; } public void run() { while (true) { r.set(\"烤鸭\"); } } } class Consumer implements Runnable { private Resource r; Consumer(Resource r) { this.r = r; } public void run() { while(true) { r.out(); } } } class ProducerConsumerDemo { public static void main(String[] args) { Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } 解决办法3:JDK1.5新特征的解决办法—Condition Condition在底层上是这样实现的:interface Condition{ await(); signal(); signalAll();} 所以要这样实现, 如下:Lock l = new ReectrantLock(); Condition c1 = l.newCondition(); Condition c2 = l.newCondition(); import java.util.concurrent.locks.* class Resource { private String name; private int count = 1; private boolean flag = false; //创建一个锁对象. Lock l = new ReentrantLock();//因为Lock是java.util.concurrent.locks包中的类, 所以要先导入包. //通过已有的锁获取该锁上的监视器对象. Condition con = l.newCondition(); public void set(String name) //这里的同步就可以去掉了 { l.lock(); //在这里加上锁 try { while (flag) // try{this.wait();}catch(InterruptedException e){} //这里用con.await()替换 try{con.await();}catch(InterruptedException e){} this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+\".....生产者.....\"+this.name); flag = true; // notifyAll(); //这里用con.signalAll() 替换 con.signalAll(); } finally { l.unlock(); } } public void out() { l.lock(); try { while (!flag) // try{this.wait();}catch(InterruptedException e){} //这里用con.await()替换 try{con.await();}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\".....消费者.....\"+this.name); flag = false; // notifyAll(); //这里用con.signalAll() 替换 con.signalAll(); } finally { l.unlock(); } } } class Producer implements Runnable { private Resource r; Producer(Resource r) { this.r = r; } public void run() { while (true) { r.set(\"烤鸭\"); } } } class Consumer implements Runnable { private Resource r; Consumer(Resource r) { this.r = r; } public void run() { while(true) { r.out(); } } } class ProducerConsumerDemo2 { public static void main(String[] args) { Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } 其实解决办法3和解决办法2没有太大的区别.并没有真的运用了1.5的新特征。 解决办法4这个解决办法才真正的运用到了1.5的新特征。 import java.util.concurrent.locks.* class Resource { private String name; private int count = 1; private boolean flag = false; //创建一个锁对象. Lock l = new ReentrantLock();//因为Lock是java.util.concurrent.locks包中的类, 所以要先导入包. //通过已有的锁获取该锁上的监视器对象. // Condition con = l.newCondition(); //通过已有的锁获取两组监视器, 一组监视生产者, 一组监视消费者. Condition producer_con = l.newCondition(); Condition consumer_con = l.newCondition(); public void set(String name) //这里的同步就可以去掉了 { l.lock(); //在这里加上锁 try { while (flag) try{producer_con.await();}catch(InterruptedException e){} //这里只让生产者等待 this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+\".....生产者.....\"+this.name); flag = true; consumer_con.signal(); //这里直接唤醒消费者 } finally { l.unlock(); } } public void out() { l.lock(); try { while (!flag) try{consumer_con.await();}catch(InterruptedException e){} //这里只让消费者等待 System.out.println(Thread.currentThread().getName()+\".....消费者.....\"+this.name); flag = false; producer_con.signalAll(); //这里只唤醒生产者 } finally { l.unlock(); } } } class Producer implements Runnable { private Resource r; Producer(Resource r) { this.r = r; } public void run() { while (true) { r.set(\"烤鸭\"); } } } class Consumer implements Runnable { private Resource r; Consumer(Resource r) { this.r = r; } public void run() { while(true) { r.out(); } } } class ProducerConsumerDemo2 { public static void main(String[] args) { Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t0 = new Thread(pro); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); Thread t3 = new Thread(con); t0.start(); t1.start(); t2.start(); t3.start(); } } &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之多线程","slug":"Java学习个人备忘录之多线程","date":"2017-09-04T09:42:00.000Z","updated":"2019-07-27T08:16:29.381Z","comments":true,"path":"2017/09/04/Java学习个人备忘录之多线程/","link":"","permalink":"https://imzry.github.io/2017/09/04/Java学习个人备忘录之多线程/","excerpt":"","text":"进程：正在进行中的程序(直译)。 线程：就是进程中一个负责程序执行的控制单元(执行路径)一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程。 开启多个线程是为了同时运行多部分代码。 每一个线程都有自己运行的内容。这个内容可以称为线程要执行的任务。 多线程的好处：解决了多部分同时运行的问题。 多线程的弊端：线程太多回到效率的降低。 其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。 jvm启动时就启动了多个线程，至少有两个线程可以分析的出来。 1。执行main函数的线程 该线程的任务代码都定义在main函数中2。负责垃圾回收的线程. class Demo extends Object { public void finalize() //用来回收 { System.out.println(\"demo ok\"); } } class ThreadDemo { public static void main(String[] args) { new Demo(); new Demo(); new Demo(); System.gc(); System.out.println(\"Hello World!\"); } } &nbsp; 多线程的创建方式—继承Thread类 步骤：1。定义一个类继承Thread类2。覆盖Thread类中的run方法3。直接创建Thread的子类对象创建线程4。调用start方法开启线程并调用线程的任务run方法执行。 可以通过Thread的getName获取线程的名称Thread-编号(从0开始) 主线程的名字就是main. class Demo extends Thread { private String name; Demo(String name) { super(name);//自定义线程的名称 this.name = name; } public void run() { show(); } public void show() { // System.out.println(name+\"........x=\"+x+\".......name=\"+getName()); System.out.println(name+\"........x=\"+x+\".......name=\"+Thread.currentThread().getName());//当前运行线程的名称。 } } class ThreadDemo2 { public static void main(String[] args) { /* 创建线程的母的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行。 而运行的指定代码就是这个执行路径的任务。 jvm创建的主线程的任务都定义在了主函数中。 而自定义的线程它的任务在哪儿呢? Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述。 这个任务就是通过Thread类中的run方法来体现。也就是说，run方法就是封装自定义线程运行任务的函数。 run方法中定义就是线程要运行的任务代码。 开启线程是为了运行指定代码，所以只有继承Thread类，并复写run方法。 将运行的代码定义在run方法中即可。 */ Demo d1 = new Demo(\"旺财\"); Demo d2 = new Demo(\"xiaoqiang\"); //d1.run(); //d2.run(); d1.start(); //开启线程，调用run方法 d2.start(); System.out.println(\"over.....\"+Thread.currentThread().getName()); } } &nbsp; 创建多线程的第二种方式—实现Runnable接口 1。定义类实现Runnable接口2。覆盖接口中的run方法，将线程的任务代码封装到run方法中。3。通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 为什么? 因为线程的任务都封装在Runnable接口子类对象的run方法中 所以要在线程对象创建时就必须明确要运行的任务。4。调用线程对象的start方法开启线程. class Demo implements Runnable { public void run() //Runnable里只有一个run方法 { show(); } public void show() { for (int x=0; x&lt;20 ; x++ ) { System.out.println(Thread.currentThread().getName()+\".....\"+x); } } } class TreadDemo { public static void main(String[] args) { Demo d = new Demo(); Thread t1 = new Thread(d); //将d传进去 Thread t2 = new Thread(d); t1.start(); t2.start(); } } &nbsp; 实现Runnable接口的好处：1。将线程的任务从线程的子类中分离出来，进行了单独的封装。 按照面向对象的思想将任务的封装成对象。2。避免了java单继承的局限性。 所以，创建线程的第二种方式较为常用. &nbsp; 例子：卖票。四个人一起卖100张票 第一种方法 class Ticket extends Thread { private static int num = 100; //这个变量要共享，所以要加静态 public void run() { sale(); } public void sale() { while(true) { if (num&gt;0) { System.out.println(num--); } } } } class TicketDemo { public static void main(String[] args) { Ticket t1 = new Ticket(); Ticket t2 = new Ticket(); Ticket t3 = new Ticket(); Ticket t4 = new Ticket(); t1.start(); t2.start(); t3.start(); t4.start(); } } &nbsp; 第二种方法 class Ticket implements Runnable { private int num = 100; public void run() { sale(); } public void sale() { while(true) { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\".....\"+num--); } } } } class TicketDemo { public static void main(String[] args) { Ticket t = new Ticket(); //因为只创建了一个对象，但是下面开启了4个进程，所以就等于4个人卖共同卖100张票 Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); } } &nbsp; &lt;/div&gt; **线程安全问题产生的原因**： 1。多个线程在操作共享数据。 2。操作共享数据的线程代码有多条。 当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算， 就会导致线程安全问题的产生。 解决思路： 就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候， 其他线程是不可以参与运算的。 必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。 在java中用，同步代码块就可以解决这个问题. &nbsp; **同步代码块** 格式： synchronized(对象) { 需要被同步的代码 } &nbsp; class Ticket implements Runnable { private int num = 100; Object obj = new Object(); public void run() { sale(); } public void sale() { //Object obj = new Object(); //它在这是错误的，这样每开启一个线程，就创建一把锁，一同是4个线程4个锁 while(true) { synchronized(obj) //同步代码块 { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\".....\"+num--); } } } } } class TicketDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); } } 同步的好处：解决了线程的安全问题。同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。同步的前提：必须有多个线程并使用同一锁. &lt;/div&gt; &nbsp; 实例：储户，两个，每个都到银行存钱，每次存100，共存三次。 class Bank { private int sum; // private Object obj = new Object(); public synchronized void add(int num) //也可以用同步函数 { // synchronized(obj) // { sum = sum + num; System.out.println(\"sum=\"+sum); // } } } class Cus implements Runnable { private Bank b = new Bank(); public void run() { for (int x=0; x&lt;3 ; x++ ) { b.add(100); } } } class BankDemo { public static void main(String[] args) { Cus c = new Cus(); Thread t1 = new Thread(c); Thread t2 = new Thread(c); t1.start(); t2.start(); } } &nbsp; &lt;/div&gt; **验证同步函数的锁** class Ticket implements Runnable { private int num = 100; Object obj = new Object(); boolean flag = true; public void run() { // Object obj = new Object(); //它在这是错误的，这样每开启一个线程，就创建一把锁，一同是4个线程4个锁 if (flag) { while(true) { synchronized(this) //同步代码块 { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\"...obj...\"+num--); } } } } else while(true) show(); } public synchronized void show() //但是可以这样用，把需要同步的代码封装起来。 { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\"...function...\"+num--); } } } class SynFunctionLockDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try{Thread.sleep(10);}catch(InterruptedException e){} t.flag = false; t2.start(); } } &nbsp; 同步函数使用的锁是this。 同步函数和同步代码块的区别： 同步函数的锁是固定的this。 同步代码块的锁是任意对象。 建议使用同步代码块. &lt;/div&gt; &nbsp; **验证静态同步函数的锁** class Ticket implements Runnable { private static int num = 100; Object obj = new Object(); boolean flag = true; public void run() { //Object obj = new Object(); //它在这是错误的，这样每开启一个线程，就创建一把锁，一同是4个线程4个锁 if (flag) { while(true) { synchronized(this) //同步代码块 { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\"...obj...\"+num--); } } } } else while(true) this.show(); } public static synchronized void show(Ticket.class) //但是可以这样用，把需要同步的代码封装起来。 { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\"...function...\"+num--); } } } class SynFunctionLockDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try{Thread.sleep(10);}catch(InterruptedException e){} t.flag = false; t2.start(); } } 静态的同步函数使用的锁是该函数所属字节码文件对象可以用getClass方法获取，也可以用当前 类名.class 表示. &lt;/div&gt; &nbsp; **多线程下的单例** **饿汉式** class Single { private static final Single s = new Single(); private Single(){} public static Single getInstance() { return s; } }//这个方法没有安全隐患 &nbsp; 懒汉式 class Single { private static Single s = null; private Single(){} public static synchronized Single getInstance() { if (s==null) //--&gt;0 --&gt;1 //懒汉式本身有安全隐患，所以要加同步 synchronized s = new Single(); return s; } }//虽然这样解决的安全隐患，但是每次获取数据s时都要判断锁，这样效率不高，解决如下： class Single { private static final Single s = null; private Single(){} public static Single getInstance() { if (s==null) { synchronized(Single.class) { if (s==null) { s = new Single(); } } } return s; } }//可以用这种双重判断的方式解决懒汉式的安全隐患。 &nbsp; &lt;/div&gt; **死锁示例** 死锁：常见情景之一：同步的嵌套。 class Ticket implements Runnable { private static int num = 100; Object obj = new Object(); boolean flag = true; public void run() { if (flag) { while(true) { synchronized(obj) //同步代码块里面嵌套着同步函数 { show(); //同步函数 } } } else while(true) this.show(); } public static synchronized void show() //同步函数里面嵌套着同步代码块 { synchronized(obj) //同步代码块 { if (num&gt;0) { try{Thread.sleep(10);}catch(InterruptedException e){} System.out.println(Thread.currentThread().getName()+\"...sale...\"+num--); } } } } class SynFunctionLockDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try{Thread.sleep(10);}catch(InterruptedException e){} t.flag = false; t2.start(); } } &nbsp; &lt;/div&gt; **一种死锁示例** class Test implements Runnable { private boolean flag; Test(boolean flag) { this.flag = flag; } public void run() { if (flag) { while(true) { synchronized(MyLock.locka) { System.out.println(Thread.currentThread().getName()+\"...if locka......\"); synchronized(MyLock.lockb) { System.out.println(Thread.currentThread().getName()+\"...if lockb.....\"); } } } } else { while(true) { synchronized(MyLock.lockb) { System.out.println(Thread.currentThread().getName()+\"...else lockb......\"); synchronized(MyLock.locka) { System.out.println(Thread.currentThread().getName()+\"...else locka......\"); } } } } } } class MyLock { public static final Object locka = new Object(); public static final Object lockb = new Object(); } class DeadLockTest { public static void main(String[] args) { Test a = new Test(true); Test b = new Test(false); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); } } &nbsp; &lt;/div&gt; &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之异常","slug":"Java学习个人备忘录之异常","date":"2017-09-04T09:03:00.000Z","updated":"2019-07-27T08:17:36.387Z","comments":true,"path":"2017/09/04/Java学习个人备忘录之异常/","link":"","permalink":"https://imzry.github.io/2017/09/04/Java学习个人备忘录之异常/","excerpt":"","text":"概述 异常：是在运行时期发生的不正常情况。 在java中用类的形式对不正常情况进行了描述和封装对象。 描述不正常的情况的类，就称为异常类。 以前正常流程代码和问题处理代码相结合，现在将正常流程代码和问题处理代码分离，提高阅读性。 其实异常就是java通过面向对象的思想将问题封装成了对象。 用异常类对其进行描述。不同的问题用不同的类进行具体的描述。 问题很多，意味着描述的类也很多。将其共性进行向上抽取，形成了异常体系。 最终问题(不正常情况)就分成了两大类Throwable：无论是error，还是异常，问题发生就应该可以抛出，让调用者知道并处理。 //该体系的特点就在于Throwable及其所有的子类都具有可抛性。 可抛性到底指的是什么呢? 怎么体现可抛性呢? 其实是通过两个关键字来体现的。 throws throw，凡是可以被这两个关键字所操作的类和对象都具备可抛性。 |—1。一般不可处理的。 一般用Error表示 特点:是由jvm抛出的严重性的问题。 这种问题发生一般不针对性处理.直接修改程序。 |—2。可以处理的，一般用Exception表示 。 该体系的特点： 子类的后缀名都是用其父类名作为后缀，阅读性很强。 class ExceptionDemo { public static void main(String[] args) { int[] arr = new int[3]; System.out.println(arr[3]);//编译通过，运行不通过 sleep(-5); } public static void sleep(int time) { if (time&lt;0) { //抛出 new FuTime();//就代码的时间为负的情况，这个对象中会包含着问题的名称，信息，位置等信息。 } System.out.println(\"我睡...\"+time); } } class FuTime { } &nbsp; 异常对象的抛出throw &nbsp; class Demo { public int method(int[] arr，int index) { if (arr==null) { throw new NullPointerException(\"数组的引用不能为空!\"); } if (index&gt;=arr.length) { throw new ArrayIndexOutOfBoundsException(\"数组的角标越界了 \"+index);//这里就抛出了自定义的异常信息。 } if (index&lt;0) { throw new ArrayIndexOutOfBoundsException(\"数组的角标不能为负值 \"+index);//这里就抛出了自定义的异常信息。 } return arr[index]; } } class ExceptionDemo2 { public static void main(String[] args) { int[] arr = new int[3]; Demo d = new Demo(); int num = d.method(arr，30); System.out.println(\"num=\"+num); System.out.println(\"over\"); } } &nbsp; 自定义异常&amp;异常类的抛出throws 对于角标是正数不存在，可以用角标越界表示。对于角标为负数的情况，准备用负数角标异常来表示。 负数角标这种异常在java中并没有定义过。那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象。 这种自定义的问题描述称为自定义异常. class Demo { public int method(int[] arr，int index)throws FuShuIndexException //表示抛出了。 { if (arr==null) { throw new NullPointerException(\"数组的引用不能为空!\"); } if (index&gt;=arr.length) { throw new ArrayIndexOutOfBoundsException(\"数组的角标越界了 \"+index);//这里就抛出了自定义的异常信息。 } if (index&lt;0) { throw new FuShuIndexException(\"数组的角标不能为负值 \"+index); } return arr[index]; } } class ExceptionDemo3 { public static void main(String[] args)throws FuShuIndexException { int[] arr = new int[3]; Demo d = new Demo(); int num = d.method(null，30); System.out.println(\"num=\"+num); System.out.println(\"over\"); } } 注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性，才可以被两个关键字所操作，throw，throws。 class FuShuIndexException extends Exception { FuShuIndexException() {} FuShuIndexException(String msg) { super(msg); } } &nbsp; 异常的分类：1。编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。 这样的问题都可以针对性的处理。 2。编译时不检测异常(运行时异常)：就是Exception中的RuntimeException和其子类。 这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的而或者引发了内部状态的改变导致的。 那么这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止，让调用者对代码进行修正。 所以自定义异常时，要么继承Exception，要么继承RuntimeException。 throws和throw的区别 1。throws使用在函数上。 throw使用在函数内。2。throws抛出的是异常类，可以抛出多个，用逗号隔开。 throw抛出的是异常对象. &nbsp; 异常捕捉trycatch 异常处理的捕捉形式：这是可以对异常进行针对性处理的方式. 具体格式是： try { 需要被检测异常的代码。 } catch(异常类 变量) //该变量用于接收发生的异常对象。 { 处理异常的代码。 } finally { 一定会被执行的代码 } class Demo { public int method(int[] arr，int index)throws FuShuIndexException，NullPointerException //表示抛出了。 { if (arr==null) { throw new NullPointerException(\"没有任何数组实体\"); } if (index&lt;0) { throw new FuShuIndexException(\"数组的角标不能为负值 \"+index); } return arr[index]; } } class ExceptionDemo4 { public static void main(String[] args)throws FuShuIndexException { int[] arr = new int[3]; Demo d = new Demo(); try { int num = d.method(null，-30); System.out.println(\"num=\"+num); } catch (NullPointerException e) { System.out.println(e.toString()); } catch (FuShuIndexException e) { System.out.println(\"message:\"+e.getMessage()); //数组的角标不能为负值 System.out.println(\"string:\"+e.toString()); //FuShuIndexException：数组的角标不能为负值 e.printStackTrace();//jvm默认的异常处理机制就是调用异常对象的这个方法。 //System.out.println(\"负数角标异常!!!!\"); } System.out.println(\"over\"); } } class FuShuIndexException extends Exception { FuShuIndexException() {} FuShuIndexException(String msg) { super(msg); } } &nbsp; 异常处理的原则：1。函数内容如果抛出需要检测的异常，那么函数上必须要声明。 否则必须在函数内用trycatch捕捉，否则编译失败。2。如果调用了声明异常的函数，要么trycatch要么throws，否则编译失败。3。什么时候catch，什么时候throws呢? 功能内部可以解决，用catch。 解决不了，用throws告诉调用者，由调用者解决。4。一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。 内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch个. &nbsp; finally代码块 class Demo { public int show(int index) { if (index&lt;0) { throw new ArrayIndexOutOfBoundsException(\"角标越界了!!\"); } int[] arr = new int[3]; return arr[index]; } } class ExceptionDemo5 { public static void main(String[] args) { Demo d = new Demo(); try { int num = d.show(-3); System.out.println(\"num=\"+num); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(e.toString()); //开发的时候不要写输出语句。 } finally //通常用于关闭(释放)资源 { System.out.println(\"finally\"); } } } 例如：连接数据库查询。Exception关闭连接 try catch finally 代码块组合特点： 1。try catch finally 2。try catch(多个) 当没有必要资源需要释放时，可以不用定义finally。 3。try finally //必须用throws声明 void show()throws Exception { try { throw new Exception(); } finally { } } &nbsp; 异常的注意事项：1。子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类。 解释： class A extends Exception { } class B extends A { } class C extends Exception { } Exception |--A |--B |--C class Fu { void show()throws A {} } class Zi extends Fu { void show()throws A或B //这里抛出的必须是父类的异常或父类异常的子类，所以不能抛出C {} } 2。如果父类抛出多个异常，那么子类只能抛出父类异常的子集。解释：如果父类抛出A B C D ，那么子类要么抛出 A B，要么抛出 C D ，要么抛出 A B C ，也可以全抛出，总之就是不能抛出像A B C D E这样的。简单说：子类覆盖父类只能抛出父类的异常或者子类或者子集。注意：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try。 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之内部类","slug":"Java学习个人备忘录之内部类","date":"2017-09-03T11:48:00.000Z","updated":"2019-07-29T02:17:18.477Z","comments":true,"path":"2017/09/03/Java学习个人备忘录之内部类/","link":"","permalink":"https://imzry.github.io/2017/09/03/Java学习个人备忘录之内部类/","excerpt":"","text":"内部类: 将一个类定义在另一个类的里面,对里面那个类就称为内部类. &nbsp; 1234567891011121314151617181920212223242526class Outer &#123; private int num = 3; class Inner //它想访问Outer中的num, 如果在外面就需要创建一个对象,然后通过公开的接口访问,但是现在Outer内部, 就可以直接访问了.这样方便 &#123; void show() &#123; System.out.println(\"show run...\" + num); &#125; &#125; //如果现在想访问Inner就需要这样 public void method() &#123; Inner in = new Inner(); in.show(); &#125; //内部类由于在内部, 相当于定义在了成员的位置上, 所以可以用成员修饰符, 如: //private class Test&#123;&#125; static class Inner &#123; static void function() &#123; System.out.println(\"function run......\"+num); &#125; &#125; &#125; 内部类访问特点：1. 内部类可以直接访问外部类中的成员.2. 外部类要访问内部类, 必须建立内部类的对象. 一般用于类的设计。 分析事物时, 发现该事物描述中还有事物,而且这个事物还在访问被描述事物的内容。这时就把还有的事物定义成内部类来描述。 12345678910111213141516171819class InnerClassDemo &#123; public static void main(String[] args) &#123; Outer out = new Outer(); out.method(); //直接访问外部类中的内部类中的成员. Outer.Inner in = new Oouter().new Inner(); in.show(); //如果内部类是静态, 那就相当于一个外部类了. Outer.Inner in = new Outer.Inner(); in.show(); //如果内部类是静态的,成员是静态的. Outer.Inner.function(); //如果内部类中定义了静态成员,该内部类也必须是静态的. &#125; &#125; 细节 123456789101112131415161718192021222324252627class Outer &#123; int num = 3; class Inner &#123; int num = 4; void show() &#123; int num = 5; System.out.println(num);//5 System.out.println(this.num);//4 System.out.println(Outer.this.num);//3 &#125; &#125; void method() &#123; new Inner().show(); &#125; &#125; class InnerClassDemo2 &#123; public static void main(String[] args) &#123; new Outer().method(); &#125; &#125; 为什么内部类能直接访问外部类中成员呢?那是因为内部类持有了外部类的引用——-外部类名.this &nbsp; 内部类可以存放在局部位置上 12345678910111213141516171819202122232425class Outer &#123; int num = 3; Object method() &#123; final int x = 9; class Inner &#123; void show() &#123; System.out.println(\"show...\"+num); &#125; &#125; Object in = new Inner(); return in;//0x0045 &#125; &#125; class InnerClassDemo3 &#123; public static void main(String[] args) &#123; Outer out = new Outer(); Object obj = out.method();//0x0045 &#125; &#125; 内部类在局部位置上只能访问局部中被final修饰的局部变量。 匿名内部类, 就是内部类的简写格式.必须有前提: 内部类必须继承或者实现一个外部类或者接口. 匿名内部类: 其实就是一个匿名子类对象. 格式: new 父类or接口(){子类内容} 1234567891011121314151617181920212223242526abstract class Demo &#123; abstract void show(); &#125; class Outer &#123; int num = 4; class Inner extends Demo //这是正常情况 &#123; void show() &#123; System.out.println(\"show....\"+num); &#125; &#125; public void method() &#123; new Demo()//这个就叫匿名内部类 &#123; void show() &#123; System.out.println(\"show....\"+num); &#125; &#125; &#125; &#125; 匿名内部类的应用 123456789101112131415161718192021222324252627282930interface Inter &#123; void show1(); void show2(); &#125; class Outer &#123; public void method() &#123; new Inter() &#123; public void show1() &#123;&#125; public void show2() &#123;&#125; &#125;.show1(); //调用了show1的方法, 相当于 new Inner().show1(); //或者用下面的方法 Inter in = new Inter() &#123; public void show1() &#123;&#125; public void show2() &#123;&#125; &#125; in.show1(); in.show2(); &#125; &#125; 通常的使用场景之一:当函数参数是接口类型时,而且接口中的方法不超过三个.可以用匿名内部类作为实际参数进行传递. 123456789101112131415class InnerClassDemo5 &#123; public static void main(String[] args) &#123; show(new InterImpl()); &#125; public static void show(Inter in) &#123; in.show1(); in.show2(); &#125; &#125; class InterImpl implements Inter &#123;&#125; 对象的初始化过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Fu &#123; int num = 9; &#123; System.out.println(\"Fu\"); &#125; Fu() &#123; super(); //显示初始化 //构造代码块初始化 show(); &#125; void show() &#123; System.out.println(\"fu show...\"+num); //被覆盖,运行子类 &#125; &#125; class Zi extends Fu &#123; int num = 8; &#123; System.out.println(\"Zi\"); &#125; Zi() &#123; super(); //显示初始化 //构造代码块初始化 show(); &#125; void show() &#123; System.out.println(\"zi show...\"+num); &#125; &#125; class Inner &#123; public static void main(String[] args) &#123; new Zi(); &#125; &#125;/*Fuzi show...0Zizi show...8*/","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之多态","slug":"Java学习个人备忘录之多态","date":"2017-09-03T11:31:00.000Z","updated":"2019-07-27T08:16:24.806Z","comments":true,"path":"2017/09/03/Java学习个人备忘录之多态/","link":"","permalink":"https://imzry.github.io/2017/09/03/Java学习个人备忘录之多态/","excerpt":"","text":"对象的多态性 class 动物 {} class 猫 extends 动物 {} class 狗 extends 动物 {} 猫 x = new 猫(); //意思是建立本类的对象 new 猫()，并通过本类的引用指向本类的对象。 动物 x = new 猫();//所以也可以这样写 &nbsp;一个对象两种形态. //上面的代码表示，用猫类型创建对象，用动物类型指向. //它的表现就是 &nbsp;父类型的指向子对象 //这就是多种形态. 猫这类事物即具备着猫的形态，又具备着动物的形态。这就是对象的多态性。 简单说：就是一个对象对应着不同类型。 多态在代码中的体现：父类或者接口的引用指向其子类的对象。 abstract class Animal { abstract void eat(); } class Dog extends Animal { void eat() { System.out.println(\"啃骨头\"); } void lookHone() { System.out.println(\"看家\"); } } class Cat extends Animal { void eat() { System.out.println(\"吃鱼\"); } void catchMouse() { System.out.println(\"抓老鼠\"); } } class Pig extends Animal { void eat() { System.out.println(\"饲料\"); } void gongDi() { System.out.println(\"拱地\"); } } class DuoTaiDemo { public static void main(String[] args) { Cat c = new Cat(); //c.eat(); method(c); Dog d = new Dog(); method(d); Pig p = new Pig(); method(p); //改进后 Animal a = new Cat();//这叫自动类型提升,猫对象提升了动物类型. 但是特有功能无法访问. //作用就是限制对特有功能的访问. //专业讲：向上转型 a.eat(); //如果我还想用具体动物猫的特有功能. //你可以将该对象进行向下转型. Cat c = (Cat)a; //向下转型的目的是为了使用子类中特有方法. c.eat(); c.catchMouse(); //注意，对于转型,自始至终都是子类对象在做着类型的变化. } } &nbsp; public static void method(Pig p) { p.eat(); } public static void method(Cat c) { c.eat(); } public static void method(Dog d) { d.eat(); } 每加一个动物，就要再写一个函数，这样很麻烦.不如我直接让”动物们去吃饭”就可以了 public static void method(Animal a) { a.eat(); }//这样就行了.省了很多的代码 这就是多态的简单使用。 多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容. 多态的弊端：前期定义的内容不能使用(调用)后期子类的特有内容. 多态的前提：1. 必须有关系：继承，实现2. 要有覆盖. &nbsp; 类型判断 public static void method(Animal a) { a.eat(); if (a instanceof Cat)//instanceof：用于判断对象的具体类型,只能用于引用数据类型的判断. (也可以判断接口) { Cat c = (Cat)a; c.catchMouse(); } else if (a instanceof Dog) { Dog d = (Dog)a; d.lookHome(); } } 成员变量 多态时：成员的特点：1. 成员变量.编译时：参考引用型变量所属的类中的是否有调用的成员变量，有，编译通过，没有，编译失败.运行时：参考引用型变量所属的类中的是否有调用的成员变量，并运行该所属类型中的成员变量简单说：编译和运行都参考等号的左边. 2. 成员函数(非静态)：编译时：参考引用类型变量所属的类中的是否有调用的函数，有，编译通过.运行时：参考对象所属的类中是否调用的函数.简单说：编译看左边，运行看右边. 3. 静态函数：编译时：参考引用型变量所属的类中的是否有调用的静态方法.运行时：参考引用型变量所属的类中的是否有调用的静态方法.简单说，编译和运行都看左边. 其实对于静态方法，是不需要对象的，直接用类名调用即可。","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之接口","slug":"Java学习个人备忘录之接口","date":"2017-09-03T11:19:00.000Z","updated":"2019-07-27T08:16:47.461Z","comments":true,"path":"2017/09/03/Java学习个人备忘录之接口/","link":"","permalink":"https://imzry.github.io/2017/09/03/Java学习个人备忘录之接口/","excerpt":"","text":"abstract class AbsDemo { abstract void show1(); abstract void show2(); } 当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示——-接口 &nbsp;interface 定义接口使用的关键字不是class，是interface。 对于接口当中常见的成员：而且这些成员都有固定的修饰符1. 全局常量：public static final2. 抽象方法：public abstract 由此得出结论，接口中的成员都是公共的权限。 interface Demo { public static final int NUM = 4; public abstract void show1(); public abstract void show2(); } 如果接口中不写固定修饰符，如下： interface Demo { int NUM = 4; void show1(); void show2(); } 编译的时候就会自动给你加上，所以这样写也是可以的。但是不推荐这样写，影响阅读性。 实现implements interface Demo { public static final int NUM = 4; public abstract void show1(); public abstract void show2(); } 类与类之间是继承关系，类与接口之间是实现关系。 接口不可以实例化。只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类。 class DemoImpl implements /*实现*/ Demo { public void show1() {} public void show2() {} } class InterfaceDemo { public static void main(String[] args) { DemoImpl d = new DemoImpl(); System.out.println(d.NUM); System.out.println(DemoImpl.NUM); System.out.println(Demo.NUM); //这3中输出方法都可以 } } 多实现 在java中不直接支持多继承，因为会出现调用的不确定性。所以java将多继承机制进行改良，在java中变成了多实现。 一个类可以实现多个接口。 interface A { public abstract void show(); } interface Z { public abstract void show(); } class Test implements A，Z //多实现 { public void show()//把上面两个show方法都覆盖了. { } } 一类在继承另一个类的同时，还可以实现多个接口。 class Q { public void method() {} } class Test2 extends Q implements A，Z { } //接口的出现避免了单继承的局限性 class InterfaceDemo { public static void main(String[] args) { Test t = new Test(); t.show(); } } &nbsp; interface CC { void show(); } interface MM { void method(); } interface QQ extends CC，MM //接口与接口之间是继承关系，可以多继承，因为没有方法体 { } 笔记本电脑使用为了扩展笔记本的功能，但日后出现什么功能设备不知道。就定义一个规则，只要日后出现的设备都符合这个规则就可以了。规则在java中就是接口。 interface USB//暴漏的规则 { public void open(); public void close(); } class BookPC { public static void main(String[] args) { //useMouse(null); useUSB(new Upan()); //一年后 功能扩展 //接口类型的引用，用于接收(指向)接口的子类对象. useUSB(new UsbMouse()); } //使用规则 public static void useUSB(USB u) { u.open(); u.close(); } } //一年后，买了一个U盘 //实现规则 class Upan implements USB { public void open() { System.out.println(\"upan open\"); } public void close() { System.out.println(\"upan close\"); } } //这就是前期对外开放的接口，后期可以使用进来的设备 class UsbMouse implements USB { public void open() { System.out.println(\"UsbMouse open\"); } public void close() { System.out.println(\"UsbMouse close\"); } } &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之抽象类","slug":"Java学习个人备忘录之抽象类","date":"2017-09-03T11:08:00.000Z","updated":"2019-07-27T08:14:25.126Z","comments":true,"path":"2017/09/03/Java学习个人备忘录之抽象类/","link":"","permalink":"https://imzry.github.io/2017/09/03/Java学习个人备忘录之抽象类/","excerpt":"","text":"抽象类 特点：1. 方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰，抽象方法必须定义在抽象类中。该类必须也被abstract修饰2. 抽象类不可以被实例化. 为什么? &nbsp;因为调用抽象方法没意义。3. 抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化，否则，这个子类还是抽象类。 abstract class 犬科 { abstract/*抽象*/ void show(); }//抽象方法所在的类也必须的抽象的. class 狗 extends 犬科 { void 吼叫() { System.out.println(\"汪汪\"); } } class 狼 extends 犬科 { void 吼叫() { System.out.println(\"嗷嗷\"); } } class AbstractDemo { public static void main(String[] args) { } } 细节理解： 1. 抽象类中有构造函数吗?有，用于给子类对象进行初始化. 2. 抽象类可以不定义抽象方法吗?可以，但是很少见，目的就是不让该类创建对象. AWT的适配器对象就是这种类.通常这个类中的方法有方法体，但是却没有内容. abstract class Demo { void show1() {} void show2() {} } 3. 抽象关键字不可以和哪些关键字共存?private &nbsp;因为抽象方法要被覆盖static &nbsp;有它就不需要创建对象final 不能被继承 4. 抽象类和一般类的区别相同点：抽象类和一般类都是用来描述事物的，都在内部定了成员。不同点： 1. 一般类有足够的信息描述事物，抽象类描述事物的信息有可能不足。 2. 一般类中不能定义抽象方法，抽象类中可以定义抽象方法。 3. 一般类可以被实例化，抽象类不可以被实例化。 5. 抽象类一定是个父类吗?是的，因为需要子类覆盖其方法后才可以对子类实例化。 雇员示例：需求： 公司中程序员有姓名，工号，薪水，工作内容。项目经理除了有姓名，工号，薪水，还有奖金，工作内容。对给除需求进行数据建模。 分析：在这个问题领域中，先找出涉及的对象。通过名词提炼法。程序员：属性： 姓名，工号，薪水行为： 工作经理：属性： 姓名，工号，薪水，奖金行为： 工作 程序员和经理不存在着直接继承关系，但是程序员和经理却具有共性内容。可以进行抽取. 因为他们都是公司的雇员。 可以将程序员和经理进行抽取，建立体系。 描述雇员 abstract class Employee { private String name; private String id; private double pay; Employee(String name，String id，double pay) { this.name = name; this.id = id; this.pay = pay; } public abstract void work(); } 描述程序员 class Programmer extends Employee { Programmer(String name，String id，double pay) { super(name，id，pay); } public void work() { System.out.println(\"code....\"); } } 描述经理 class Manager extends Employee { private int bonus; Manager(String name，String id，double pay，int bonus) { super(name，id，pay); this.bonus = bonus; } public void work() { System.out.println(\"manage\"); } } &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之关键字final","slug":"Java学习个人备忘录之关键字final","date":"2017-09-02T06:51:00.000Z","updated":"2019-07-27T08:28:26.084Z","comments":true,"path":"2017/09/02/Java学习个人备忘录之关键字final/","link":"","permalink":"https://imzry.github.io/2017/09/02/Java学习个人备忘录之关键字final/","excerpt":"","text":"final关键字final可以修饰类，方法，变量。final修饰的类不可以被继承final修饰的方法不可以被覆盖final修饰的变量是一个常量。只能被赋值一次。内部类只能访问被final修饰的局部变量。 123456789101112131415class Fu&#123; void method() &#123; //调用了底层系统的资源 &#125;&#125;class Zi extends Fu&#123; void method() &#123; System.out.println(\"haha\"); &#125;&#125; 从上面可以看出继承是有弊端的，就是打破了封装性。这时我们就可以用final关键字，不让别人继承，如下： 12345678910111213141516final class Fu&#123; void method() &#123; //调用了底层系统的资源 &#125;&#125;class Zi extends Fu&#123; void method() &#123; System.out.println(\"haha\"); &#125;&#125;//这样在编译的时候就会报错。 final的初始化final的初始化并不是固定初始化，而是显式初始化。int x; 这样写后，x会被初始化为0。但是如果是final int x; &nbsp;这样编译就会报错。 因为它不支持固定初始化 通常情况下 有final就会有static修饰符static final int x = 8;因为加了final就意味着他会被共享。 为什么要用final修饰变量。 其实在程序中如果一个数据是固定的,那么直接使用这个数据就可以了，但是这样阅读性差，所以它给数据起个名字。而且这个变量名称的值不能变化，所以加上final固定。 写法规范：常量所有字母都大写，多个单词，中间用 _ 连接。","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之继承","slug":"Java学习个人备忘录之继承","date":"2017-09-02T06:42:00.000Z","updated":"2019-07-27T08:16:42.718Z","comments":true,"path":"2017/09/02/Java学习个人备忘录之继承/","link":"","permalink":"https://imzry.github.io/2017/09/02/Java学习个人备忘录之继承/","excerpt":"","text":"继承的好处1. 提高了代码的复用性。2. 让类与类之间产生了关系，给第三个特征多态提供了前提。 java中支持单继承，不直接支持多继承，但对C++中的多继承机制进行改良。java支持多层继承。 C继承B，B继承A，就会出现继承体系。 当要使用一个继承体系时：1. 查看该体系中的顶层类，了解该体系的基本功能。2. 创建体系中的最子类对象，完成共能的使用。 什么时候定义继承呢?当类与类之间存在着所属关系的时候，就定义继承，xxx是yyy中的一种，&nbsp; xxx extends yyy。 class Person { String name; int age; } class Student extends Person //继承 { // String name; // int age; void study() { System.out.println(name+\"...student study....\"+age); } } class Worker extends Person { // String name; // int age; void work() { System.out.println(\"worker work\"); } } class ExtendsDemo { public static void main(String[] args) { Student s = new Student(); s.name = \"zhangsan\"; s.age = 20; s.study(); } } 在子父类中，成员的特点体现1.成员变量2.成员函数3.构造函数 1. 成员变量当本类的成员和局部变量同名时，用this区分；当子父类中的成员变量同名时，用super区分父类。 this和super的用法很相似。 this：代表一个本类对象的引用。super：代表一个父类的空间，并不代表父类对象。 class Fu { int num = 4; } class Zi extends Fu { int num = 5; void show() { System.out.println(super.num+\"...\"+num); } } class ExtendsDemo2 { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } 2. 成员函数当子父类中出现成员函数一模一样的情况，会运行子类的函数。这种现象，称为覆盖操作，这时函数在子父类中的特性。函数两个特性：1.重载. 同一个类中，overload2.覆盖. 子类中，覆盖也称为重写，override 覆盖注意事项：1.子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限。2.静态只能覆盖静态，或被静态覆盖。 class Fu { void show() { System.out.println(\"fu show run\"); } } class Zi extends Fu { void show() { System.out.println(\"zi show run\"); } } class ExtendsDemo2 { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } 什么时候使用覆盖? 当对一个类进行子类的扩展时，子类需要保留父类的功能声明。但是要定义子类中该功能的特有内容时，就是用覆盖操作完成。 class Phone { void call() {} void show() { // System.out.println(\"pic\"); // System.out.println(\"name\"); System.out.println(\"number\"); } } &nbsp; 应用场景现在手机升级了，加了显示姓名和图片的功能。但是如果我直接在源代码上修改会增加修改成本，不好。这时候我们就可以用继承来解决。 class NewPhone extends Phone { void show() { System.out.println(\"pic\"); System.out.println(\"name\"); // System.out.println(\"number\"); super.show(); } } class PhoneDemo { public static void main(String[] args) { // Phone p = new Phone(); // p.show(); NewPhone p = new NewPhone(); p.show(); } } &nbsp; 子父类中构造函数的继承 在子类构造对象时，发现访问子类构造函数时，父类也运行了。为什么呢?原因是：在子类的构造函数中第一行有一个默认的隐式语句—-super(); 子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。 class Fu { Fu() { System.out.println(\"fu run\"); } } class Zi extends Fu { Zi() { //super(); //默认的隐式语句. 调用的就是父类中的空参数的构造函数. System.out.println(\"zi run\"); } } class ExtendsDemo4 { public static void main(String[] args) { new Zi(); /* 结果为: fu run zi run */ } } 还有一种情况 class Fu { Fu() { System.out.println(\"fu run\"); } Fu(int x) { System.out.println(\"fu run....\"+x); } } class Zi extends Fu { Zi() { //super(); //默认的隐式语句. 调用的就是父类中的空参数的构造函数. System.out.println(\"zi run...\"); } Zi(int x) { System.out.println(\"zi run....\"+x); } } class ExtendsDemo4 { public static void main(String[] args) { new Zi(4); /* 结果为: fu run zi run....4 */ } } 为什么子类实例化的时候要访问父类中的构造函数呢?那是因为子类继承了父类，获取到了父类中的内容(属性)，所以在使用父类内容之前，要先看父类是如何对自己的内容进行初始化的。 所以子类在构造对象时，必须访问父类中的构造函数。为什么完成这个必须的动作，就子啊子类的构造函数中加了super(). 语句。 如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中哪个构造函数。 同时子类构造函数中如果使用this调用了本类构造函数时，那么super就没有了，因为super和this都只能定义第一行.所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。 注意：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。 class Fu { Fu() { super(); show(); return; } void show() { System.out.println(\"fu show\"); } } class Zi extends Fu { int num = 8; Zi() { //super(); //默认的隐式语句. 调用的就是父类中的空参数的构造函数. //--&gt;通过super初始化父类内容时，子类的成员变量并未显示初始化. //等super()父类初始化完毕后，才进行子类的成员变量显示初始化. //也就是说要先忙完父类那边的事，然后才能忙自己的事. System.out.println(\"zi cons run...\"+num); } void show() { System.out.println(\"zi show ...\"+num); } } class ExtendsDemo5 { public static void main(String[] args) { Zi z = new Zi(); z.show(); /* 结果为: zi show...0 zi cons run...8 zi show...8 */ } } 一个对象实例化的过程：Person p = new Person();1. jvm会去读取指定路径下的Person.class文件，并加载进内存。并会先加载Person的父类(如果有直接的父类的情况下)。2. 在堆内存中的开辟空间，分配地址。3. 并在对象空间中，对对象中的属性进行默认初始化。4. 调用对应的构造函数进行初始化。5. 在构造函数中，第一行会先调用父类中的构造函数进行初始化。6. 父类初始化完毕后，再对子类的属性进行显示初始化。7. 在进行子类构造函数的特定初始化。8. 初始化完毕后，将地址赋值给引用变量。","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之文档注释","slug":"Java学习个人备忘录之文档注释","date":"2017-09-01T08:34:00.000Z","updated":"2019-07-27T08:17:26.988Z","comments":true,"path":"2017/09/01/Java学习个人备忘录之文档注释/","link":"","permalink":"https://imzry.github.io/2017/09/01/Java学习个人备忘录之文档注释/","excerpt":"","text":"文档注释单行注释用 // 多行注释有两种，第一种是 / 内容 /，第二种是/* 内容 /。 这两种多行注释的区别是/* 内容 /这种注释可以生成一个该文件的注释文档，下面是演示代码。 ArrayTool.java文件 /** 建立一个用于操作数组的工具类,其中包含着常见的对数组操作的函数,如: 最值,排序等. @author 纸人 @version v1.0 */ //ArrayTool.java文件 public class ArrayTool //加上public后,文件名和类名要一致 { private ArrayTool(){}; //该类中的方法都是静态的,所以该类是不需要创建对象的. //为了保证不让其他人创建对象,可以讲构造函数私有化. /** 获取整型数组的最大值 @param arr 接收一个元素为int类型的数组 @return 该数组的最大的元素值 */ public static int getMax(int[] arr) { int maxIndex = 0; for (int x=1; x&lt;arr.length ; x++ ) { if (arr[x]&gt;arr[maxIndex]) { maxIndex = x; } } return arr[maxIndex]; } /** 对数组进行选择排序 @param arr 接收一个元素为int类型的数组 */ public static void selectSort(int[] arr) { for (int x=0; x&lt;arr.length-1 ; x++ ) { for (int y=x+1; y&lt;arr.length ; y++ ) { if (arr[x]&gt;arr[y]) { swap(arr,x,y); } } } } /** 用于给数组进行元素的位置置换 @param arr 接收一个元素为int类型的数组 @param a @param b */ private static void swap(int [] arr,int a,int b) { int temp = arr[a]; arr[a] = arr[b]; arr[b] = arr[a]; } /** 获取指定的元素在指定数组中的索引. @param arr 接收一个元素为int类型的数组 @param key 要找的元素. @return 返回来元素第一次出现的位置, 如果不存在返回-1. */ public static int getIndex(int[] arr,int key) { for (int x=0; x&lt;arr.length ; x++ ) { if (arr[x]==key) { return x; } } return -1; } /** 将int数组转成字符串. 格式为: [e1,e2,e3,....] @param arr 接收一个元素为int类型的数组 @return 返回该数组的字符串表现形式. */ public static String arrayToString(int[] arr) { String str = \"[\"; for (int x=0; x&lt;arr.length ; x++ ) { if (x != arr.length-1) str = str + arr[x] + \", \"; else str = str + arr[x] + \"]\"; } return str; } } ArrayToolDemo.java文件 class ArrayToolDemo { public static void main(String[] args) { int[] arr = {4,8,2,9,7,6}; // ArrayTool tool = new ArrayTool(); int max = ArrayTool.tool.getMax(arr); System.out.println(\"max=\"+max); int index = ArrayTool.tool.getIndex(arr,10); System.out.println(\"index=\"+index); } } &nbsp; ArrayTool.java文件已经写好了，现在我们使用命令生成ArrayTool.java文件的注释文档。 用法：javadoc [选项] [软件包] [源文件] [@file] javadoc [参数可以是多个] [存放的路径] [源文件] [描述] 例：javadoc -d myhelp -author -version ArrayTool.java","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之数组工具类","slug":"Java学习个人备忘录之数组工具类","date":"2017-09-01T08:01:00.000Z","updated":"2019-07-27T08:17:24.486Z","comments":true,"path":"2017/09/01/Java学习个人备忘录之数组工具类/","link":"","permalink":"https://imzry.github.io/2017/09/01/Java学习个人备忘录之数组工具类/","excerpt":"","text":"下面主要讲解一个针对数组操作的工具类。 a.java — 工具类文件 //按理来说要先编译本文件， 然后再编译主函数 class ArrayTool { /* 获取整型数组的最大值 */ public int getMax(int[] arr) { int maxIndex = 0; for (int x=1; x&lt;arr.length ; x++ ) { if (arr[x]&gt;arr[maxIndex]) { maxIndex = x; } } return arr[maxIndex]; } /* 选择排序 */ public void selectSort(int[] arr) { for (int x=0; x&lt;arr.length-1 ; x++ ) { for (int y=x+1; y&lt;arr.length ; y++ ) { if (arr[x]&gt;arr[y]) { swap(arr，x，y); } } } } //交换两个单元的值 private void swap(int [] arr，int a，int b) { int temp = arr[a]; arr[a] = arr[b]; arr[b] = arr[a]; } /* 根据该单元的值，找到该单元的键 */ public int getIndex(int[] arr，int key) { for (int x=0; x&lt;arr.length ; x++ ) { if (arr[x]==key) { return x; } } return -1; } /* 将数组转成字符串 */ public String arrayToString(int[] arr) { String str = \"[\"; for (int x=0; x&lt;arr.length ; x++ ) { if (x != arr.length-1) str = str + arr[x] + \"， \"; else str = str + arr[x] + \"]\"; } return str; } } &nbsp; b.java — 主函数 //实际上直接编译主函数就可以，其他的有关文件就会被自动编译 class ArrayToolDemo { public static void main(String[] args) { int[] arr = {4，8，2，9，7，6}; ArrayTool tool = new ArrayTool(); int max = tool.getMax(arr); System.out.println(\"max=\"+max); int index = tool.getIndex(arr，10); System.out.println(\"index=\"+index); } } 工具类中的静态的使用 在类中没有访问到成员变量的方法，我们将它变为静态类。因为我们在调用方法时，需要先创建对象，如ArrayTool tool = new ArrayTool();&nbsp;但是我们所要调用的方法 如 getMax()，它并没有访问成员变量，如果我们还是要创建对象的话，那么就是在浪费空间。 优化后的代码如下： c.java class ArrayTool { private ArrayTool(){}; //该类中的方法都是静态的,所以该类是不需要创建对象的. //为了保证不让其他人创建对象,可以将构造函数私有化. /* 获取整型数组的最大值 */ public static int getMax(int[] arr) { int maxIndex = 0; for (int x=1; x&lt;arr.length ; x++ ) { if (arr[x]&gt;arr[maxIndex]) { maxIndex = x; } } return arr[maxIndex]; } /* 选择排序 */ public static void selectSort(int[] arr) { for (int x=0; x&lt;arr.length-1 ; x++ ) { for (int y=x+1; y&lt;arr.length ; y++ ) { if (arr[x]&gt;arr[y]) { swap(arr,x,y); } } } } //交换两个单元的值 private static void swap(int [] arr,int a,int b) { int temp = arr[a]; arr[a] = arr[b]; arr[b] = arr[a]; } /* 根据该单元的值,找到该单元的键 */ public static int getIndex(int[] arr,int key) { for (int x=0; x&lt;arr.length ; x++ ) { if (arr[x]==key) { return x; } } return -1; } /* 将数组转成字符串 */ public static String arrayToString(int[] arr) { String str = \"[\"; for (int x=0; x&lt;arr.length ; x++ ) { if (x != arr.length-1) str = str + arr[x] + \", \"; else str = str + arr[x] + \"]\"; } return str; } } b.java class ArrayToolDemo { public static void main(String[] args) { int[] arr = {4,8,2,9,7,6}; // ArrayTool tool = new ArrayTool(); // 因为是静态方法，所以省略了这一步 int max = ArrayTool.tool.getMax(arr); System.out.println(\"max=\"+max); int index = ArrayTool.tool.getIndex(arr,10); System.out.println(\"index=\"+index); } } &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之关键字static","slug":"Java学习个人备忘录之关键字static","date":"2017-09-01T03:21:00.000Z","updated":"2019-07-27T08:36:57.847Z","comments":true,"path":"2017/09/01/Java学习个人备忘录之关键字static/","link":"","permalink":"https://imzry.github.io/2017/09/01/Java学习个人备忘录之关键字static/","excerpt":"","text":"被static标记的东西会放在内存中被共享的，对象用到时，就会来取的。 12345678910111213141516171819class Person&#123; String name; //成员变量，实例变量 static String country = \"CN\"; //静态变量，类变量 public void show() &#123; System.out.println(country+\"：\"+name); &#125;&#125;class StaticDemo&#123; public static void main(String[] args) &#123; Person p = new Person(); System.out.println(p.country); System.out.println(Person.country); &#125;&#125; &nbsp; static的特点1. static是一个修饰符，用于修饰成员。2. static修饰的成员被所有的对象所共享。3. static优先于对象存在，因为static的成员随着类的加载就已经存在了。4. static修饰的成员多了一种调用方式，可以直接被类名所调用. &nbsp;类名.静态成员。5. static修饰的数据是共享数据，对象中的存储的特有数据。 成员变量和静态变量的区别?1. 两个变量的声明周期不同&nbsp; &nbsp; 成员变量随着对象的创建而存在，随着对象的被回收而释放。&nbsp; &nbsp; 静态变量随着类的加载而存在，随着类的消失而消失。2. 调用方式不同&nbsp; &nbsp; 成员变量只能被对象调用。&nbsp; &nbsp; 静态变量可以被对象调用，还可以被类名调用。3. 别名不同&nbsp; &nbsp; 成员变量也称为实例变量。&nbsp; &nbsp; 静态变量称为类变量。4. 数据存储位置不同&nbsp; &nbsp; 成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。&nbsp; &nbsp; 静态变量数据存储在方法区(共享数据区)的静态区,所以也叫对象的共享数据。 静态使用的注意事项1. 静态方法只能访问静态成员。(非静态既可以访问静态，又可以访问非静态)2. 静态方法中不可以定义this或者super关键字。3. 主函数是静态的。 123456789101112class StaticDemo&#123; int num = 4; public static void main(String[] args) &#123; new StaticDemo().show(); //在静态方法中调用非静态方法 &#125; public void show() &#123; System.out.println(num); &#125;&#125; main函数public static void main(String[] args) 主函数特殊之处：1.格式是固定的。2.被jvm所识别和调用。 public：因为权限必须是最大的。static：java虚拟机在调用时，是不需要对象的。void：主函数没有具体的返回值。main：函数名，不是关键字，只是一个jvm识别的固定的名字。String[] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型。 12345678910111213141516171819202122class MainDemo&#123; public static void main(String[] args) //new String[0] 创建时虚拟机传进去一个数组 &#123; System.out.println(args);//[Ljava.lang.String;@c17164 System.out.println(args.length); System.out.println(args[0]); /* 编译： java MainDemo haha hehe xixi # haha hehe xixi 是传进去的三个参数 输出： 3 haha */ //传进去的是数组，所以也可以这样写 for (int x=0; x&amp;lt;args.length ; x++ ) &#123; System.out.println(args[x]); &#125; &#125;&#125; 静态什么时候用?1. 静态变量&nbsp; &nbsp; 当分析对象中所具备的成员变量的值都是相同的。&nbsp; &nbsp; 这时这个成员就可以被静态修饰。&nbsp; &nbsp; 只要数据在对象中都是不同的,就是对象特有数据，必须存储在对象中,是非静态的。&nbsp; &nbsp; 如果是相同的数据，对象不需要做修改,只需要使用即可，不需要存储在对象中,定义成静态的。 2. 静态函数&nbsp; &nbsp; 函数是否用静态修饰，就参考一点，就是该函数功能是否访问到对象中的特有数据。&nbsp; &nbsp; 简单点说，从源代码看,该功能是否需要访问非静态的成员变量,如果需要,该功能就是非静态的。&nbsp; &nbsp; 如果不需要，就可以将该功能定义成静态的。 静态代码块随着类的加载而执行，而且只执行一次。 作用：&nbsp; &nbsp; 用于给类进行初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class StaticCode&#123; static //定义静态代码块 &#123; System.out.println(\"hahahah\"); &#125; void show() &#123; System.out.println(\"show run\"); &#125;&#125;class StaticDemo&#123; public static void main(String[] args) &#123; new StaticCode().show(); new StaticCode().show(); &#125;&#125;/*hahahahshow runshow run*/// 给类进行初始化class StaticCode&#123; static int num; static //定义静态代码块 &#123; num = 10; System.out.println(\"hahahah\"); &#125; static void show() &#123; System.out.println(\"show run\"); &#125;&#125;class StaticDemo&#123; public static void main(String[] args) &#123; StaticCode.show(); //这时候的初始化就不能用构造函数了，因为并没有创建对象. &#125;&#125;class Person&#123; private String name; &#123; //构造代码块 可以所有对象进行初始化 System.out.println(\"person run\"); cry(); //这样就不用在每个构造函数中都写了. &#125; Person() //构造函数是给对应的对象进行针对性的初始化 &#123; name = \"baby\"; //cry(); &#125; Person(String name) &#123; this.name = name; //cry(); &#125; public void cry() &#123; System.out.println(\"哇哇\"); &#125;&#125;class StaticDemo&#123; public static void main(String[] args) &#123; Person p = new Person(); //person run &#125;&#125;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之构造函数&this","slug":"Java学习个人备忘录之构造函数-this","date":"2017-08-31T12:18:00.000Z","updated":"2019-07-27T08:16:32.785Z","comments":true,"path":"2017/08/31/Java学习个人备忘录之构造函数-this/","link":"","permalink":"https://imzry.github.io/2017/08/31/Java学习个人备忘录之构造函数-this/","excerpt":"","text":"构造函数 概念：构建创造对象时调用的函数。 作用：可以给对象进行初始化，创建对象都必须要通过构造函数初始化。 一个类中如果没有定义过构造函数，那么该类中会有一个默认的空参数构造函数.如果在类中定义了指定的构造函数，那么类中默认构造函数就没有了. 构造函数可以直接调用一般函数，但是一般函数不能直接调用构造函数，如果想调用，就要new一下。 class Person { private String name; private int age; //定义一个Person类的构造函数 Person() //构造函数，而且是空参数的，构造函数的名和类名相同 { System.out.println(\"person run\"); } public void speak() { System.out.println(name+\":\"+age); } } class ConsDemo { public static void main(String[] args) { Person p = new Person(); //这里创建Person对象后，自动调用了Person()，所以这时会打印出person run } } &nbsp; this的应用 当成员变量和局部变量重名时，可以用关键字this来区分。 this：代表对象. 代表哪个对象呢? 当前对象。&nbsp; &nbsp; &nbsp; &nbsp; this就是所在函数所属对象的引用。&nbsp; &nbsp; &nbsp; &nbsp; 简单说：哪个对象调用了this所在的函数，this就代表哪个对象。 class Person { private String name; private int age; Person(String name) { this.name = name; //当局部变量和成员变量重名时，成员变量要加上this. } public void speak() { System.out.println(name); } } class Demo { Person p = new Person(\"哈哈\"); p.speak(); //打印出 -- 哈哈 } this的第二个用法构造函数中调用构造函数。注意：只能定义在构造函数的第一行，因为初始化动作要先执行。 class Person { private String name; private int age; Person(String name) { this.name = name; } Person(String name，int age) { this(name); //调用上面那个构造函数，给name赋值 this.age = age; } public void speak() { System.out.println(name+\":\"+age); } } class ThisDemo { public static void main(String[] args) { Person p = new Person(\"旺财\"，30); p.speak(); Person p1 = new Person(\"小强\"); p1.speak(); } } this关键字的应用实例 class Person { private String name; private int age; Person(String name) { this.name = name; } Person(String name，int age) { this(name); //调用上面那个构造函数，给name赋值 this.age = age; } public void speak() { System.out.println(name+\":\"+age); } //判断是否是同龄人 public boolean compare(Person p) { /* if(this.age==p.age) return true; else return false; */ return this.age==p.age; } } class ThisDemo { public static void main(String[] args) { Person p1 = new Person(\"aa\"，30); Person p2 = new Person(\"zz\"，12); p1.compare(p2); } } &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之面向对象概念","slug":"Java学习个人备忘录之面向对象概念","date":"2017-08-31T11:44:00.000Z","updated":"2019-07-27T08:16:50.461Z","comments":true,"path":"2017/08/31/Java学习个人备忘录之面向对象概念/","link":"","permalink":"https://imzry.github.io/2017/08/31/Java学习个人备忘录之面向对象概念/","excerpt":"","text":"对象，其实就是该类事物实实在在存在的个体。 类与对象之间的关系?类：一类事物的描述。对象：该类事物的实例。在java中通过new来创建的。举例来说，类就是汽车说明书，类只能在理论上造一辆汽车，并且这个说明书非常明确的写了汽车有哪些部件、可以干什么等等信息，我们可以通过这个说明书（类）得知这辆车全方位的信息；对象就是按照这个说明书造出来的一辆汽车实体，是真实存在的，可以开走的。 下面我们用类描述一辆小汽车： 分析：1，属性轮胎数.颜色.2，行为运行. 定义类其实就是在定义类中的成员成员：成员变量就是属性，成员函数就是行为。 class Car { int num; //成员变量，汽车的属性 String color;//成员变量 void run() //成员函数汽车的功能 { System.out.println(num + \"...\" + color); } } class CarDemo { public static void main(String[] arge) { //在计算机中创建一个car的实例，通过new关键字 Car c = new Car(); //就是一个类类型的引用变量，指向了该类的对象 c.num = 4; c.color = \"red\"; c.run(); } } &nbsp; &nbsp; 成员变量和局部变量的区别 1，成员变量定义在类中，整个类中都可以访问；局部变量定义在函数、语句、局部代码块中，只在所属的区域有效。 2，成员变量存在于堆内存的对象中；局部变量存在于栈内存的方法中。 3，成员变量随着对象的创建而存在，随着对象的消失而消失；局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。 4，成员变量都有默认初始化值；局部变量没有默认初始化值。 类类型参数 class CarDemo { public static void main(String[] args) { Car c1 = new Car(); Car c2 = new Car(); show(c1); show(c2); } //汽车改装厂 public static void show(Car c)//类类型的变量一定指向对象，要不就是null. { c.num = 3; c.color = \"black\"; System.out.println(c.num + \"...\" + c.color); } } &nbsp; 匿名对象new car(); &nbsp;//匿名对象，其实就是定义对象的简写格式new Car().run(); 没有将car对象赋值给某一变量。 1，当对象对方法仅进行一次调用的时候，就可以简化成匿名对象2，匿名对象可以作为实际参数进行传递 基本数据类型参数传递 class Demo { public static void main(String[] args) { int x = 3; show(x); System.out.println(\"x=\"+x); } public static void show(int x) { x = 4; return ; } } > 这道题的结果是3。 > 首先执行主函数，主函数进栈，然后执行int x = 3; 现在x的值为3。然后调用show函数，所以show 函数进栈，将x = 3 传进去，show函数将x赋值为4，show函数return，show函数出栈，这时，栈中只剩下了主函数中的x = 3 ，然后输出。所以结果为3。 &nbsp; **引用数据类型参数传递** class Demo { int x = 3; public static void main(String[] args) { Demo d = new Demo(); d.x = 9; show(d); System.out.println(d.x); } public static void show(Demo d) { d.x = 4; } } > 结果为4。 > 首先执行主函数，主函数进栈，然后执行Demo d = new Demo(); 这时就在堆中开辟一块空间，同时将它的地址赋值给栈中的d，它中的x赋值为3，执行 d.x = 9; 堆中的x就被赋值为9;执行show(d); &nbsp;show函数进栈，将对象d传入，堆中的x又被赋值为4;show函数执行完毕，show函数出栈;这时输出d.x。结果就为4。 &nbsp; **函数的封装** class Person { private int age; public void setAge(int a) { if (a &lt; 0) { System.out.println(\"年龄不能为负数\"); return; } age = a; speak(); } void speak() { System.out.println(\"age=\" + age); } } class Test { public static void main(String[] args) { Person p = new Person(); p.setAge(20); } }","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之数组","slug":"Java学习个人备忘录之数组","date":"2017-08-31T09:14:00.000Z","updated":"2019-07-27T08:17:02.559Z","comments":true,"path":"2017/08/31/Java学习个人备忘录之数组/","link":"","permalink":"https://imzry.github.io/2017/08/31/Java学习个人备忘录之数组/","excerpt":"","text":"数组 概念：同一种类型数据的集合,其实数组就是一个容器. 数组的好处：可以自动给数组中的元素从0开始编号,方便操作这些元素. 格式1：元素类型[] 数组名 = new 元素类型[元素个数]; 格式2：元素类型[] 数组名 = new 元素类型[]{元素1,元素2,元素3,….,元素N}; 内存的划分：1：寄存器2：本地方法区3：方法区4：栈内存 存储的都是局部变量 而且变量所属的作用域一旦结束,该变量就自动释放5： 堆内存存储的是数组和对象(其实数组就是对象) 凡是new 建立的都在堆中.特点：1.每一个实体都有首地址值2.堆内存中的每一个变量都有默认初始化值,根据类型的不同而不同. 12345678910111213class ArrayDemo&#123; public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr(3)); //ArrayIndexOutOfBoundsException //当访问到数组中不存在的角标时,就会发生该异常. arr = null; System.out.println(arr[0]);//NullpointerExeception //当引用变量没有任何实体指向时,还在用其操作实体,就会发生该异常. &#125;&#125; 对数组操作最基本的动作就是存和取。核心思想：就是对角标的操作。 常见数组应用算法数组遍历 12345int[] arr = &#123;89,34,280,15&#125;;for (int x = 0; x&amp;lt;arr.length ; x++ )&#123; System.out.println(arr[x]);&#125; 数组最值 12345678910111213141516171819202122232425262728public static int getMax(int[] arr)&#123; //定义变量记录较大的值 int max = arr[0]; for (int x=1; x&amp;lt;arr.length ; x++ ) &#123; if(arr[x]&amp;gt;max) &#123; max = arr[x]; &#125; &#125; return max;&#125;//第二种方法public static int getMax(int[] arr)&#123; //定义变量记录较大的值 int max = 0; for (int x=1; x&amp;lt;arr.length ; x++ ) &#123; if(arr[x]&amp;gt;arr[max]) &#123; max = x; &#125; &#125; return arr[max]; //这里返回的最大值的角标&#125; 选择排序 123456789101112131415public static void selectSort(int[] arr)&#123; for (int x=0; x&amp;lt;arr.length ; x++ ) &#123; for (int y=x+1; y&amp;lt;arr.length ; y++ ) &#123; if (arr[x]&amp;gt;arr[y]) &#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125;&#125; 冒泡排序 123456789101112131415161718192021222324252627282930/*内循环：-1： 为了避免角标越界-x： 为了让外循环增加一次,内循环参数与比较的元素个数递减.*/for (int x=0; x&amp;lt;arr.length ; x++ )&#123; for (int y=0; y&amp;lt;arr.length-1-x ; y++ ) &#123; if (arr[y]&amp;gt;arr[y+1]) &#123; int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; &#125; &#125;&#125;// 方法二：for (int x=arr.length-1; x&amp;gt;0 ; x-- )&#123; for (int y=0; y&amp;lt;x ; y++ ) &#123; if (arr[y]&amp;gt;arr[y+1]) &#123; int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; &#125; &#125;&#125; 查找：返回数组的角标 1234567891011public static getIndex(int[] arr,int value)&#123; for (int x=0; x&amp;lt;arr.length ; x++ ) &#123; if (arr[x] == key) &#123; return x; &#125; &#125; return -1;&#125; 进制转换 10-&gt;16 123456789101112public static void toHex(int num)&#123; for (int x=0; x&amp;lt;8 ; x++ ) &#123; int temp = num &amp;amp; 15; if (temp&amp;gt;9) System.out.print((char)(temp-10+'A')); else System.out.print(temp); num = num &amp;gt;&amp;gt;&amp;gt; 4; &#125;&#125; 什么时候使用数组呢?如果数据出现了对应关系，而且对应关系的一方是有序的数字编号，并作为角标使用。这时就必须要想到数组的使用。 就可以将这些数据存储到数组中，根据运算的结果作为角标直接去查数组中对应的元素即可。这种方式： 称为查表法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void toHex_1(int num)&#123; // 定义一个对应关系表 char[] chs = &#123;'0','1','2','3', '4','5','6','7', '8','9','A','B', 'C','D','E','F'&#125;; for(int x=0; x&amp;lt;8; x++) &#123; int temp = num &amp;amp; 15; System.out.println(chs[temp]); num = num &amp;gt;&amp;gt;&amp;gt; 4; &#125;&#125;//但是这个方法显示出来的写过是反着的public static void toHex_2(int num)&#123; if (num == 0) &#123; System.out.println(\"0\"); return; &#125; //定义一个对应关系表 char[] chs = &#123;'0','1','2','3', '4','5','6','7', '8','9','A','B', 'C','D','E','F'&#125;; /* 一会查表会查到比较多的数据 数据一多,就先存储起来,在进行操作. 所以定义一个数组---临时容器. */ char[] = arr = new char[8]; int pos = arr.length; while(num != 0) &#123; int temp = num &amp;amp; 15; arr[--pos] = chs[temp]; num = num &amp;gt;&amp;gt;&amp;gt; 4; &#125; System.out.println(\"pos=\" + pos); for (int x = pos; x&amp;lt;arr.length ; x++ ) &#123; System.out.println(arr[x] + \",\"); &#125;&#125; 二维数组定义的格式 12345678910111213141516171819202122232425262728293031323334353637383940414243class Array2Demo&#123; public static void main(String[] args) &#123; int[][] arr = new int[3][2]; //这就是二维数组的定义格式. //该数组中有3个大箱子，每个大箱子中有2个小箱子 System.out.println(arr); //[I@15db9742 @左边是实体的类型. @右边是实体的哈希值. System.out.println(arr);//直接打印二维数组 System.out.println(arr[0]); //直接打印二维数组中角标0下面的一维数组 /*********************************************************************/ int[][] arr = new int[3][]; arr[0] = new int[2]; arr[1] = new int[1]; arr[2] = new int[3]; //分别对二维数组中的每一个小数组进行初始化. /**********************************************************************/ int[][] arr = new int[3][2]; System.out.println(arr.length); //打印二维数组的长度,其实就是一维数组的个数 System.out.println(arr[1].length); /***********************************************************************/ //第二种定义方式 int[][] arr = &#123;&#123;8,3,6&#125;,&#123;7,4,9&#125;,&#123;3,0,7&#125;&#125;; int sum = 0; //遍历二维数组 for (int x=0; x&amp;lt;arr.length ; x++ ) &#123; for (int y=0; y&amp;lt;arr[x].length ; y++ ) &#123; System.out.println(arr[x][y]+\",\"); sum += arr[x][y]; &#125; &#125; System.out.println(\"sum=\"+sum); &#125;&#125;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"Java学习个人备忘录之入门基础","slug":"Java学习个人备忘录之入门基础","date":"2017-08-31T05:33:00.000Z","updated":"2019-07-27T08:27:34.247Z","comments":true,"path":"2017/08/31/Java学习个人备忘录之入门基础/","link":"","permalink":"https://imzry.github.io/2017/08/31/Java学习个人备忘录之入门基础/","excerpt":"","text":"临时配置环境方式:查看path下的环境变量 set path修改path下的环境变量 set path=haha删除path下的环境变量 set path=查看当前java的版本 javac -versionset path=路径;%path% =========================================================== 类文件路径配置:就是运行.class文件的路径set classpath=c:\\myclass查看是否配置过路径:set classpath =========================================================== 关键字: 1234567class Demo&#123; public static void main(String[] agrs) &#123; System.out.println(\"hello java\"); &#125;&#125; 蓝色的为关键字(main也是关键字) =========================================================== 标识符:在程序中自定义的一些名称.由26个英文字母大小写,数字:0-9 符号:_和$组成java中严格区分大小写 =========================================================== 注释:单行注释: //多行注释: / &nbsp;/ &nbsp;多行注释中不能嵌套多行注释 java特有的注释: /* &nbsp;文档注释 &nbsp;/它的好处是可以通过java中的一个工具进行提取工具是: &nbsp;javadoc.exe &nbsp;提取出来可以生成一个说明书, 形成一个html文件 =========================================================== 变量:数据类型 &nbsp;变量名 = 初始化值如: byte a = 3;&nbsp;&nbsp;* 必须有初始化值 =========================================================== 数据类型: 基本数据类型:数值型:整数类型:byte(一个字节 -128 — 127) -2^7 — +2^7-1&nbsp;short(两个字节 ) -2^15 — +2^15-1 &nbsp;因为两个字节是16位int(四个字节(默认)) -2^31 — +2^31-1long(八个字节) … &nbsp;(long类型定义的值后面要加 l )浮点类型:float(四个字节)&nbsp;double(八个字节(默认))字符型:char布尔型:boolean引用数据类型:类:class接口:interface数组:[] =========================================================== 类型转换byte b = 3;b = (byte)(b + 4);//强制类型转换, 将int型转换为byte型 =========================================================== 算术运算符 &nbsp;+ - / % &nbsp; &nbsp;+(连接符)任何数据和字符串相加都叫连接int x = 6370;x = x / 1000 1000;System.out.println(x); //6000原因:java是强类型语言,6370和1000都是整数,所以相除完后是6, 再乘以1000,就等于6000了. 任何数据和字符串相加都叫连接 如System.out.println(3+”2”);这样就得出字符串 32System.out.println(“5+5=”+5+5);//5+5=55System.out.println(“5+5=”+(5+5)); &nbsp;//5+5=10 =========================================================== byte 字节 = 8个二进制位 进制的转换:&nbsp;752= 710^2 + 510^1 + 2*10^0 111 = 7 1111 = 15 -1010-1110 010-101-110&nbsp;2 &nbsp; 5 &nbsp; 6 &nbsp; &nbsp;==&gt;0256 -1010-1110&nbsp; 10 &nbsp; 14 &nbsp; &nbsp; ==&gt; 0xAE 结论:八进制数,其实就是二进制中 3个二进制位为一个八进制位十六进制: 其实就是二进制中的4个二进制位为一个十六进制位. =========================================================== 负数的进制其实就是这个数的整数的二进制取反, 再加1 通常负数的二进制的最高位都是 1. =========================================================== &amp;: 与|: 或^: 异或&nbsp;true ^ true = falsetrue ^ false = truefalse ^ true = truefalse ^ false = false&amp;&amp;: 与(短路)||: 或(短路) =========================================================== 位运算符: 是用于二进制位运算的符号&lt;&lt; &nbsp;左移&gt;&gt; &nbsp;右移num &gt;&gt; 4 &nbsp;右移4位&gt;&gt;&gt; 无符号右移数据进行右移时,高位出现的空位,无论原高位是什么,空位都用0补.&amp; &nbsp; 与运算| &nbsp; 或运算^ &nbsp; 异或运算~ &nbsp; 反码 =========================================================== 局部代码块可以定义局部变量的生命周期 1234&#123; int a = 3; System.out.println(a+3);&#125; 之后a就不用了,变量a在{}结束后,就会自动释放内存这样就会节省内存空间","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"java","slug":"java","permalink":"https://imzry.github.io/tags/java/"}]},{"title":"PHP设置时区","slug":"PHP设置时区","date":"2017-08-31T05:27:00.000Z","updated":"2019-07-27T08:17:49.905Z","comments":true,"path":"2017/08/31/PHP设置时区/","link":"","permalink":"https://imzry.github.io/2017/08/31/PHP设置时区/","excerpt":"","text":"php时间函数出错及解决方法 php date_default_timezone_set()函数用法date.timezone时间区 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHP时间函数出错及解决方法：php&nbsp;date_default_timezone_set()函数date.timezone时间区这些因素都是影响php时间的，最主要的问题是默认php时间函数用的是格林威治标准时间和我们的时间（北京时间）差了正好8个小时，这也是php时间函数出错解决的人口。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以前碰到一个问题问题，就是echo date(\"y-m-dh:i:s\",time())回来的时间总是与实际时间对不上，今天终于在网上找到了原因和解决方法，分享如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从php5.1.0开始，php.ini里加入了date.timezone时间区这个选项，默认情况下是关闭的也就是显示的时间（无论用什么php命令）都是格林威治标准时间和我们的时间（北京时间）差了正好8个小时，有以下3中方法可以恢复正常的时间。 1，最简单的方法就是不要用php5.1以上的版本 2，如果一定要用，而且不能修改php.ini，则需要在关于时间的初始化的语句的 上面加上 date_default_timezone_set (XXX); 3，一劳永逸，仅限能修改php.ini。打开php.ini查找date.timezone时间区去掉前面的分号 =后面加XXX，重启http服务（如apache2或iis等）即可。如果php.ini找不到date.timezone时间区这行，是不是就没办法了呢，当然不是啦，哈哈没有的话就自己加嘛，自己动手丰衣足食。我加了这样一句date.timezone= \"PRC\"，问题就搞定了，高兴一下. 关于XXX，大陆内地可用的值是：Asia/Chongqing ，Asia/Shanghai ，Asia/Urumqi（依次为重庆，上海，乌鲁木齐） 港台地区可用：Asia/Macao ，Asia/Hong_Kong ，Asia/Taipei （依次为澳门，香港，台北） 还有新加坡：Asia/Singapore 老外好像把北京漏调了 其他可用的值是：Etc/GMT-8 ，Singapore ，Hongkong ，PRC PRC是什么？PRC是中华人民共和国啊-_- --------------------------------------------------------------------------------------------------------------------- 解决方式: 在页头使用date_default_timezone_set()函数设置我的默认时区为北京时间 date_default_timezone_set('PRC'); echo date('Y-m-d H:i:s'); 时间和服务器当前时间一样了!!祝贺之 附date_default_timezone_set()函数用法如下 -------------------------------- date_default_timezone_set() (PHP 5 &gt;= 5.1.0RC1) date_default_timezone_set ()-- 设定用于一个脚本中所有日期时间函数的默认时区 说明 bool date_default_timezone_set ( string timezone_identifier ) date_default_timezone_set() 设定用于所有日期时间函数的默认时区。 &nbsp;&nbsp;&nbsp;&nbsp;注: 自 PHP5.1.0 起（此版本日期时间函数被重写了），如果时区不合法则每个对日期时间函数的调用都会产生一条 E_NOTICE级别的错误信息。 参数 timezone_identifier &nbsp;&nbsp;&nbsp;&nbsp;时区标识符，例如UTC 或 Europe/Lisbon 返回值 本函数永远返回 TRUE（即使 timezone_identifier 参数不合法）。 ------------------------------------------------------------------------------------------ 再附上时区标识符: CET CST6CDT Cuba EET Egypt Eire EST EST5EDT Etc/GMT Etc/GMT+0 Etc/GMT+1 Etc/GMT+10 Etc/GMT+11 Etc/GMT+12 Etc/GMT+2 Etc/GMT+3 Etc/GMT+4 Etc/GMT+5 Etc/GMT+6 Etc/GMT+7 Etc/GMT+8 Etc/GMT+9 Etc/GMT-0 Etc/GMT-1 Etc/GMT-10 Etc/GMT-11 Etc/GMT-12 Etc/GMT-13 Etc/GMT-14 Etc/GMT-2 Etc/GMT-3 Etc/GMT-4 Etc/GMT-5 Etc/GMT-6 Etc/GMT-7 Etc/GMT-8 Etc/GMT-9 Etc/GMT0 Etc/Greenwich Etc/UCT Etc/Universal Etc/UTC Etc/Zulu Factory GB GB-Eire GMT GMT+0 GMT-0 GMT0 Greenwich Hongkong HST Iceland Iran Israel Jamaica Japan Kwajalein Libya MET MST MST7MDT Navajo NZ NZ-CHAT Poland Portugal PRC PST8PDT ROC ROK Singapore Turkey UCT Universal UTC W-SU WET 还可以用 ini_set() 来设置时区 可以在文件开头加入 ini_set('date.timezone','Asia/Shanghai'); &nbsp; //'Asia/Shanghai' 为上海时区","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"}]},{"title":"PHPCMS v9的表单向导实现问答咨询功能的方法","slug":"PHPCMS-v9的表单向导实现问答咨询功能的方法","date":"2017-08-31T05:25:00.000Z","updated":"2019-07-27T08:18:14.116Z","comments":true,"path":"2017/08/31/PHPCMS-v9的表单向导实现问答咨询功能的方法/","link":"","permalink":"https://imzry.github.io/2017/08/31/PHPCMS-v9的表单向导实现问答咨询功能的方法/","excerpt":"","text":"本文主要介绍了在phpcms v9的表单向导里实现问答咨询功能的方法 phpcms v9内容管理系统本身是没有问答模块的，只有表单向导，但表单向导有很大的局限性，通过表单向导，我们只能查看用户提交的信息，不能对用户提交的信息进行回复。例如一些机构的网站需要一个接收用户的提问，并对提问进行回复的功能，仅仅利用表单向导是满足不了这种需求的，但通过下面的方法对表单向导模块进行一些改动就可以实现咨询问答功能了。在phpcms v9后台新建一表单向导&ldquo;在线问答&rdquo;，表名为&ldquo;online_ask&rdquo;，表名自己定，如下图。 ![\\](http://files.jb51.net/file_images/article/201205/2012052110162212.png) 对&ldquo;在线问答&rdquo;添加字段，如下图的例子，添加什么字段是根据需求定的。 ![\\](http://files.jb51.net/file_images/article/201205/2012052110162213.png) 下图是该表单的预览效果。 ![\\](http://files.jb51.net/file_images/article/201205/2012052110162214.png) 这样用户就可以通过该表单提交问题了，但在后台，网站编辑只能通过表单向导模块对问题进行查看，不能对其进行回答并将问题和回答展示在网站前台，如下图。 ![\\](http://files.jb51.net/file_images/article/201205/2012052110162215.png)&nbsp; 为了实现网站编辑在查看问题的同时还能对问题进行回答，需要对表单模块做如下的改动： 打开文件phpcms/modules/formguide/templates/formguide_info_view.tpl.php ，在第28行下面添加如下内容： &lt;tr&gt; &lt;td&gt;回&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;答：&lt;/td&gt; &lt;td&gt; &lt;textarea id=\"answer\" cols=\"80\" rows=\"10\"&gt; &lt;?php echo $answer; ?&gt; &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp;&lt;/td&gt; &lt;td&gt;&lt;input id=\"tijiaohuida\" type=\"button\" value=\"提交回答\" /&gt;&lt;/td&gt; &lt;/tr&gt; 上面的变量$answer哪来的继续往下看就知道了 在第30行下面添加如下内容： &lt;script type=\"text/javascript\"&gt; $(document).ready(function(){ var canshuStr=window.location.search; var pos=canshuStr.indexOf(\"&amp;did\"); var posend=canshuStr.indexOf(\"&amp;\",pos+4); var did_c=canshuStr.substring(pos+5,posend); var answer_c=\"\"; $(\"#tijiaohuida\").click(function(){ answer_c= $(\"#answer\").val(); $.post('index.php?m=formguide&amp;c=formguide_info&amp;a=public_answer', { did: did_c, answer: answer_c }, function(json) { if(json==1){ alert(\"回答成功\"); } }); }); }); &lt;/script&gt; 然后打开文件phpcms/modules/formguide/formguide_info.php ，在56行加如下代码：&nbsp;answer=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;info[&lsquo;answer&rsquo;]; 在最后添加一个方法，代码如下：&lt;/span&gt;&lt;/span&gt; public function public_answer() { $did = $_POST['did']; $answer = $_POST['answer']; $re= $this-&gt;db-&gt;query(\"update kc_form_online_ask set answer='\".$answer.\"',mark='已回答' where dataid=\".$did); echo $re; } 然后我们在数据库找到存储改表单的数据表，并添加两个字段mark和answer，mark用来标记改问题是否已作答，answer用来存储回答。 以上是所有的改动。 这样我们查看用户提交的问题的时候界面就变成下图这个样子了。填入回答后点击提交，就可以将答案数据存储在该表单的数据表内了，在网站前台，我们可以将用户的问题和网站编辑的回答展示出来，如下图：这样我们就利用表单向导模块实现了一个简单的在线咨询的功能。网站www.eduche.com的在线咨询功能就是通过上面的方法实现的，大家可以去看具体效果。 &nbsp; &lt;/div&gt;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"},{"name":"PHPCMS","slug":"PHPCMS","permalink":"https://imzry.github.io/tags/PHPCMS/"}]},{"title":"PHPCMS调取当前栏目的描述、文章位置导航、当前栏目链接、当前栏目名称","slug":"PHPCMS调取当前栏目的描述、文章位置导航、当前栏目链接、当前栏目名称","date":"2017-08-31T05:19:00.000Z","updated":"2019-07-27T08:18:17.378Z","comments":true,"path":"2017/08/31/PHPCMS调取当前栏目的描述、文章位置导航、当前栏目链接、当前栏目名称/","link":"","permalink":"https://imzry.github.io/2017/08/31/PHPCMS调取当前栏目的描述、文章位置导航、当前栏目链接、当前栏目名称/","excerpt":"","text":"当我们填写了栏目描述，怎么调用出来。 使用 &nbsp;&nbsp;&nbsp;{$CATEGORYS[$catid][description]} 就可以把栏目的描述调用出来 下面三个也比较常用 {catpos($catid)} 显示文章位置导航 {$CATEGORYS[$catid][url]} 显示当前栏目链接 {$CATEGORYS[$catid][catname]} 显示当前栏目名称","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"},{"name":"PHPCMS","slug":"PHPCMS","permalink":"https://imzry.github.io/tags/PHPCMS/"}]},{"title":"Phpcms V9导航循环下拉菜单的调用技巧","slug":"Phpcms-V9导航循环下拉菜单的调用技巧","date":"2017-08-31T05:05:00.000Z","updated":"2019-07-27T08:18:07.436Z","comments":true,"path":"2017/08/31/Phpcms-V9导航循环下拉菜单的调用技巧/","link":"","permalink":"https://imzry.github.io/2017/08/31/Phpcms-V9导航循环下拉菜单的调用技巧/","excerpt":"","text":"这个方法基于PC V9官方模版中的调用方法，然后利用后台的&ldquo;Phpcms V9菜单是否显示设置&rdquo;控制菜单是否显示出来。 先看看最后的效果： 调用方法： &lt;div id=\"navbar\"&gt; &lt;div id=\"navbarcontent\"&gt; &lt;div id=\"menu\"&gt; &lt;ul id=\"menuul\"&gt; {pc:content action=\"category\" catid=\"0\" num=\"25\" siteid=\"$siteid\" order=\"listorder ASC\"} &lt;li&gt;&lt;div&gt;&lt;a href=\"{siteurl($siteid)}/\"&gt;&lt;span&gt;网站首页&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;img width=\"1\" height=\"45\" src=\"{siteurl($siteid)}/style/images/navline.gif\"&gt;&lt;/li&gt; {loop $data $k $v} &lt;li&gt; &lt;div&gt; &lt;a href=\"{$v[url]}\"&gt;&lt;span&gt;{$v[catname]}&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"sub_mune_ul\" style=\"display: none; \"&gt; {pc:content action=\"category\" catid=\"$k\" num=\"10\" siteid=\"$siteid\" order=\"listorder ASC\"} {loop $data $r} &lt;li&gt;&lt;a href=\"{$r[url]}\"&gt;{$r[catname]}&lt;/a&gt;&lt;/li&gt; {/loop} {/pc} &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt; {if $v[catid]==5}{else} &lt;li&gt; &lt;img width=\"1\" height=\"45\" src=\"{siteurl($siteid)}/style/images/navline.gif\"&gt; &lt;/li&gt; {/if} {/loop} {/pc} {php echo runhook('glogal_header')} &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 在这个代码里边，我把外部的的DIV标签页带上了，这是完整的代码，为了更好的定义CSS，如果只是调用数据，那么只要{pc}语句中间的部分就好了。 大家可以看到&lt;li&gt;标签里边，我还设置了一个div，这个div里边的循环就是下拉菜单的子栏目。 控制不显示的栏目菜单方法： 后台菜单：内容 &gt; 内容相关设置 &gt; 管理栏目 &gt;，设置如下： 在这里，调用代码中的{php echo runhook(‘glogal_header’)}作用巨大，后台设置&ldquo;是否在导航显示&rdquo;选择&ldquo;否&rdquo;，那么就在导航菜单循环中不显示，这句代码把后台的设置响应到具体调用了，起到了这个作用。 上面说的具体只是数据调用的方法，要做到下拉导航菜单，还需要CSS和JS的配合。 大家可以找一个静态html的下拉菜单，然后用上面的调用方法，定义到现有的下拉菜单中。 &nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"},{"name":"PHPCMS","slug":"PHPCMS","permalink":"https://imzry.github.io/tags/PHPCMS/"}]},{"title":"html+css基础 - 个人备忘录","slug":"html-css基础-个人备忘录","date":"2017-08-31T04:54:00.000Z","updated":"2019-07-27T08:13:55.127Z","comments":true,"path":"2017/08/31/html-css基础-个人备忘录/","link":"","permalink":"https://imzry.github.io/2017/08/31/html-css基础-个人备忘录/","excerpt":"","text":"//======================html部分===================// 表现内容&lt;meta http-equiv=”Content-Type” content=”text/html;charset=utf-8”&gt; 创建一个css链接&lt;link rel=”stylesheet” type=”text/css” href=”css/css.css” /&gt; 图片标签&lt;img src=”img.png” alt=”图片名” title=”鼠标放上去 他就显示” /&gt;//图片是内联元素,同时是 内联替换元素,替换元素是能设置宽高的//可用display转换成块状元素 来消除图片间距. 最外面的div&lt;div id=”container”&gt;&lt;/div&gt; 背景图片&lt;body background=”你的背景图片地址”&gt;&lt;/body&gt; 注释语法&lt;!—注释的内容—&gt; 滚动标签&lt;marquee&gt; &lt;/marquee&gt; direction 表示滚动的方向，值可以是left，right，up，down，默认为left behavior 表示滚动的方式，值可以是scroll（连续滚动）slide（滑动一次）alternate（来回滚动） loop 表示循环的次数，值是正整数，默认为无限循环 scrollamount 表示运动速度，值是正整数，默认为6 scrolldelay 表示停顿时间，值是正整数，默认为0，单位是毫秒 valign 表示元素的垂直对齐方式，值可以是top，middle，bottom，默认为middle align 表示元素的水平对齐方式，值可以是left，center，right，默认为left bgcolor 表示运动区域的背景色，值是16进制的RGB颜色，默认为白色 height、width 表示运动区域的高度和宽度，值是正整数（单位是像素）或百分数，默认width=100% height为标签内元素的高度 hspace、vspace 表示元素到区域边界的水平距离和垂直距离，值是正整数，单位是像素。 onmouseover=this.stop() onmouseout=this.start() 表示当鼠标移上区域的时候滚动停止，当鼠标移开的时候又继续滚动。 输入框&lt;input type=”text” name=”pin” maxlength=”25” style = “width:400px,height:200px”/&gt;&lt;/p&gt; 在图片上添加文字第一种方法：添加一个DIV，采用绝对定位，图片所属DIV为基准&lt;div style=”position:relative;width:100px;height:100px;”&gt;&nbsp; &nbsp;&lt;img src=”” alt=”注释” /&gt;&nbsp; &nbsp;&lt;div style=”position:absolute;width:100px;height:100px;z-indent:2;left:0;top:0;”&gt;&nbsp; &nbsp; &nbsp; &nbsp;文字&nbsp; &nbsp;&lt;/div&gt;&lt;/div&gt;第二种方法：图片作为背景图片&lt;div style=”background:url(abc.jpg) no-repeat left top;”&gt;&nbsp; &nbsp;wenzi&lt;/div&gt; Html插入视频&lt;embed src=”url” quality=”high” width=”480” height=”400” align=”middle” allowScriptAccess=”always” allowFullScreen=”true” mode=”transparent” type=”application/x-shockwave-flash”&gt;&lt;/embed&gt; 简单的下拉列表&lt;select name=”cars”&gt;&lt;option value=”volvo”&gt;选项1&lt;/option&gt;&lt;option value=”saab” &nbsp;selected=”selected” (用来调默认)&gt;选项2&lt;/option&gt;&lt;option value=”fiat”&gt;选项3&lt;/option&gt;&lt;option value=”audi”&gt;选项4&lt;/option&gt;&lt;/select&gt; 表单&lt;form action=”信息发送的地址” &nbsp;method=”post” (隐藏提交信息)&gt;&lt;input type=”text” name=”username” value=”默认” /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;用户名&lt;input type=”password” name=”password” /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;密码&lt;input type=”radio” name=”xingbie” value=”男” checked=”checked” (用来调默认) /&gt; 单选框//value 是值 给后台看的&lt;input type=”checkbox” name=”aihao” value=”排球” /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 复选框&lt;input type=”file” name=”touxiang” /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上传文件&lt;input type=”hidden” name=”yincangIP” value=”192.168.1.1” /&gt; &nbsp; &nbsp; &nbsp;隐藏域//这个例子是隐藏了IP地址&lt;input type=”submit” name=”tijiao” /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;提交&lt;/form &gt;//name 的作用是让后台区分数据 大文本框&lt;textarea name=”intro”&gt;文本(默认值)&lt;/textarea&gt;overflow : visible | auto | hidden | scrollvisible : 默认值。不剪切内容也不添加滚动条。假如显式声明此默认值， 对象将以包含对象的 window 或 frame 的尺寸裁切。并且 clip 属性设置将失效&nbsp;auto : &nbsp; 在必需时对象内容才会被裁切或显示滚动条&nbsp;hidden : 不显示超过对象尺寸的内容&nbsp;scroll : 总是显示滚动条 表格&lt;table&gt;&lt;tr&gt; //行&lt;td&gt;1&lt;/td&gt; &nbsp;//列&lt;/tr&gt;&lt;tr colspan=”4”&gt;//colspan 合并列&lt;td rowspan=”3”&gt;2&lt;/td&gt;//rowspan 合并行&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 内联元素&lt;span class=&rdquo; &rdquo;&gt;行内元素 只在行内发挥作用 不像div是块状元素&lt;/span&gt; html图片按钮&lt;input name=”imgbtn” type=”image” src=”login_08.gif” width=”50” height=”35” border=”0”&gt; head部分 &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt;&lt;meta http-equiv=”Content-Type” content=”text/html; charset=utf-8” /&gt;&lt;meta http-equiv=”Content-Language” content=”zh-CN” /&gt;&lt;meta name=”Author” content=”网页作者” /&gt;&nbsp;&lt;meta name=”Copyright” content=”网站版权” /&gt;&nbsp;&lt;meta name=”keywords” content=”网站关键字” /&gt;&lt;meta name=”description” content=”网站描述” /&gt;&lt;link rel=”Shortcut Icon” href=”网站.ico图标路径” /&gt;&lt;link type=”text/css” rel=”stylesheet” href=”CSS文件路径” /&gt;&lt;script type=”text/javascript” src=”JS文件路径”&gt;&lt;/script&gt; 框架集需要先将规范改为框架型 frameset&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;&amp;nbsp;然后将body去掉后, 写上下面的&lt;frameset rows=”200px , “&gt; &nbsp; &nbsp; (rows=”200px , “ 表示将整个页面分成2部分 第一部分200px高,剩下的都给第二部分. &nbsp;* &nbsp;表示剩下的都给另一部;rows表示行(指行高) )&nbsp; &lt;frame src=”a.html”&gt;名字&lt;/frame&gt;&gt; 这里是第一部分 引入了a.html页面 &lt;frameset cols=”30% , *”&gt; &nbsp; &nbsp; &nbsp; (cols表示列)&nbsp; \\&lt;frame src=”b.html” name=”zuo”&gt;&lt;/frame&gt;} 这里是第二部分&lt;frame src=”c.html” name=”you”&gt;&lt;/frame&gt;&nbsp; /&lt;/frameset&gt; &nbsp;/ &lt;/frameset&gt; ————————————-b.html页面中————————————————————————-| &lt;a href=” “ target=”you” &gt;链接到c.html,并在右侧显示出来&lt;/a&gt; |标题标签&lt;h1&gt;title1&lt;/h1&gt;&lt;h2&gt;title2&lt;/h2&gt;&lt;h3&gt;title3&lt;/h3&gt;&lt;h4&gt;title4&lt;/h4&gt;&lt;h5&gt;title5&lt;/h5&gt;&lt;h6&gt;title6&lt;/h6&gt;//标题标签h1-6系列,表示1-6号标题 段落标签&lt;p&gt;段落标签&lt;/p&gt; &nbsp; 无序列表 ul&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 有序列表 ol&lt;ol&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ol&gt; 链接a标签&lt;a href=”地址” target=”_blank” title=”鼠标放上来显示”&gt;&lt;/a&gt;[target=”_blank” 在新网页中打开]a标签去掉下划线a{text-decoration:none;}或者把这个属性分别加到a标签下，a:link{text-decoration:none;}a:visited{text-decoration:none;}a:hover{text-decoration:none;}a:active{text-decoration:none;}锚点&lt;a href=”index.html#名字”&gt;锚点&lt;/a&gt;&lt;a name=”名字”&gt;&lt;/a&gt;[一般用法: index.html#名字 ] label标签&lt;label&gt;&lt;input type=”checkbox” /&gt;点这里也可以 &lt;/label&gt; //======================CSS部分=====================//&lt;style&gt;背景颜色background: red &nbsp;orange &nbsp; yellow &nbsp; green &nbsp;indigo &nbsp;blue &nbsp;purple &nbsp;pink &nbsp;violet &nbsp; black &nbsp;white &nbsp; gray &nbsp; &nbsp;transparent赤 &nbsp; &nbsp;橙 &nbsp; &nbsp; &nbsp;黄 &nbsp; &nbsp; &nbsp; &nbsp;绿 &nbsp; &nbsp; 青 &nbsp; &nbsp; 蓝 &nbsp; &nbsp; 紫 &nbsp; &nbsp; 粉 &nbsp; 紫罗兰 &nbsp; &nbsp; 黑 &nbsp; &nbsp;白 &nbsp; &nbsp; 灰色 &nbsp; &nbsp; &nbsp; &nbsp;透明 背景颜色body{ } 背景图片body{background-image:url(img.png);background-repeat:repeat-x;在 x 轴上铺开background-repeat:repeat-y;在 y 轴上铺开background-repeat:no-repeat;不重复} 大图片做背景{Width:50px; &nbsp;} div的宽{Height:50px;}div的高background-position：X值 Y值&nbsp;以左上角为原点 分别 向右 和向下 X Y值为正, 反之像素则为负{background-position:100px 200px;}{padding: 10px;}//用一句做背景{background:transparent url(img.png) no-repeat 100px 200px;} 浮动float:left/right; 定位position: relative; &nbsp; 相对定位//是指在其正常的位置上,偏移某些像素.top:0px; &nbsp;right:0px; &nbsp;//想怎么移动就写哪个方向bottom:10px;left:10px; position:absolute; &nbsp; 绝对定位//是指在其父元素的位置上,偏移某些像素.top:0px;right:0px; &nbsp;//想怎么移动就写哪个方向bottom:10px;left:10px;//用绝对定位时,父元素要有 position:relative; 属性才行,否则将依据父的父的父的父的父的…..body.绝对定位相当于漂浮在父元素上面的,遮挡住了父元素的一部分.如果再来一个子元素,就会遮挡住原来的子元素,这时可以调节高度来决定谁遮挡住谁. z-index:1000; &nbsp; &nbsp; &nbsp;高度 &nbsp; (没有单位) CSS距离margin:10px 20px 30px 40px;4个值是 &nbsp; 是指上 &nbsp;右 &nbsp;下 &nbsp;左 &nbsp;4个方向的距离margin:0 auto；2个值是 &nbsp; 是指 （上下） &nbsp; &nbsp;（左右) &nbsp; 一起控制 &nbsp;那么 &nbsp;margin:0 auto；的意思 &nbsp;就是 上下距离是0 &nbsp; 左右距离自动 &nbsp; 也就是说 &nbsp;是居中的意思！ 文字居中text-align: center; 清除浮动clear: left/right/both.clr{width: 0px;height:0px;clear: both;} 边距外边距 margin-top/right/bottom/left://上右下左内边距 padding: 边框border: 20px solid/dashed/dotted green;//边框宽 &nbsp;20px &nbsp; &nbsp;实线/虚线/点线/..等 可以查手册 &nbsp; green &nbsp;还可以设置单条边的边框 去掉点:li{list-style:none}; 控制段落段落缩进: &nbsp;text-indent:20px;文字方向: &nbsp;text-align: center;//居中文字装饰线: &nbsp;text-decoration:underline;//下划线 overline;//上划线 line-through;//删除线字母间距: &nbsp;letter-spacing:10px; 文字控制颜色控制: &nbsp;{color:blue;}字型: &nbsp;{font-style:italic;}//斜体文字粗细: &nbsp;{font-weight:bold;}//粗体文字大小: &nbsp;{font-size:15px;}行高: &nbsp;{line-height:20px;}字体: &nbsp;{font-family:”SimHei”;}//黑体 font-family:’微软雅黑’,’黑体’,sans-serif;(如果用一行写,必须按照下面的顺序写属性)font-family:’New Times’,’新宋’,’宋体’,serif;用一行写: &nbsp;{font:blue italic bold 15px/20px “SimHei”;} 表格控制table{border: 1px solid blue;border-collapse: collapse;//破裂融合 &nbsp;消除表格间距border-collapse: separate;//独立(默认)border-spacing: 20px;//设置边框间距} css伪类a:link {color: #FF0000} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / 未访问的链接 /a:visited {color: #00FF00} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ 已访问的链接 /a:hover {color: #FF00FF} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ 鼠标移动到链接上 /a:active {color: #0000FF} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / 选定的链接 /必须按照以上顺序: LVHAa:link 可以简写为 a CSS画圆角{border-radius:5px;} &nbsp;(数字为圆的半径) 内联与块状的转化{display:block;}//内联转块状 可用于消除图片之间的距离{display:inline;}//块状转内联{display:none;}//隐藏元素 利用行高使字体竖直居中{line-height:10px;}//行高 溢出处理{overflow:visible;}//默认溢出{overflow:hidden;}//隐藏 它还可以解决IE的一个BUG,在IE下控制小的元素不好,然后就用hidden把多余的隐藏起来.{overflow:scroll;}//滚动框{overflow:auto;}//内容多了再加滚动条 阴影文字: {text-shadow:5px 5px 0px rgba(0,0,0,0.5);}div: {box-shadow:5px 5px 0px rgba(0,0,0,0.5);} 透明度{opacity:0.3} &nbsp; &lt;/style&gt;//=========================注意事项=================================// margin重叠现象研究相邻的普通元素,上下边距,并非简单的相加,而是取其中较大的边距值. IE BUG&nbsp;双倍margin bug &nbsp; 解决方案 在CSS中添加样式 &nbsp; _display:inline; 尺寸的表示ex (x-height，字母 “x” 的高度)cm (厘米，1厘米=10毫米)mm (毫米)pt (点，1点=1/72英寸)pc (帕，1帕=12点)% &nbsp;还可以百分比来表示em 是相对大小,是指其父元素中的一个’M’大小,可以理解为是父元素字体大小的em倍 字符实体一般格式: &amp; + 实体名 + ;空格 &amp;nbsp; &amp;#160;&nbsp;&lt; 小于号 &amp;lt; &amp;#60;&nbsp;&gt; 大于号 &amp;gt; &amp;#62;&nbsp;&amp; 和号 &amp;amp; &amp;#38;&nbsp;“ 引号 &amp;quot; &amp;#34;&nbsp;‘ 撇号 &nbsp;&amp;apos; (IE不支持) &amp;#39;&nbsp;￠ 分 &amp;cent; &amp;#162;&nbsp;&pound; 镑 &amp;pound; &amp;#163;&nbsp;&yen; 日圆 &amp;yen; &amp;#165;&nbsp;&sect; 节 &amp;sect; &amp;#167;&nbsp;&copy; 版权 &amp;copy; &amp;#169;&nbsp;&reg; 注册商标 &amp;reg; &amp;#174;&nbsp;&times; 乘号 &amp;times; &amp;#215;&nbsp; &divide; 除号 &amp;divide; &amp;#247;&nbsp;","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"html","slug":"html","permalink":"https://imzry.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://imzry.github.io/tags/css/"}]},{"title":"新人学PHP，认为手动搭建环境而苦恼吗？这篇文章告诉你多简单！","slug":"新人学PHP，认为手动搭建环境而苦恼吗？这篇文章告诉你多简单！","date":"2017-08-31T04:48:00.000Z","updated":"2019-07-27T08:11:23.420Z","comments":true,"path":"2017/08/31/新人学PHP，认为手动搭建环境而苦恼吗？这篇文章告诉你多简单！/","link":"","permalink":"https://imzry.github.io/2017/08/31/新人学PHP，认为手动搭建环境而苦恼吗？这篇文章告诉你多简单！/","excerpt":"","text":"本教程适用于初学PHP，想了解手动搭建PHP环境的童鞋。 一键环境和高手勿喷。 本教程以下列版本软件为例： 所需软件目录 我在这里的目录结构是(个人习惯) 安装与配置 apache双击安装Apache 这里我们选择第一个，然后点击 Next。 这里随便填一个域名，随便填一个 email 就可以了。 然后选择 默认占用 80 端口就 OK 了点击 Next。 点击 Next。 这里选择安装路径 然后点击intall 正在安装中 安装完成 右下角这里是绿色的表示成功了！ 这时我们在地址栏里输入 localhost 就会显示 It works！ 到此Apache就安装完了。 这里我可以介绍一下Apache的安装目录 APACHE2.2 目录 ├─bin —&gt; binary,二进制文件,是 apache 的主程序及控制台等可执行程序的目录 ├─cgi-bin —&gt; 公共网关接口方式存放程序的目录 ├─conf ——&gt;config 的缩写,配置文件目录 │ ├─extra —-&gt; 辅配置文件 │ ├─original—-&gt; 原始的配置文件,可以在修改失败后来恢复用 │ └─httpd.conf —&gt;主配置文件,引入 extra 里面的各子配置文件 ├─error —-&gt;存入一些请求错误时,所给客户回应的信息. ├─htdocs —-&gt; 网页的主目录 ├─icons —-&gt;一些小图标 ├─logs —-&gt; 日志信息,其中 error.log 是错误日志信息,对我们调试很有帮助. ├─manual —&gt; 手册,帮助文档 └─modules —&gt; 模块目录,放置各种功能模块 下面介绍一下如何修改默认主页新安装的 apache 它的默认主页是 index.html 首先我们来到Apache2.2conf目录下面，找到 httpd.conf 文件 我们随便用一个文编编辑器打开它 然后我们搜索 index.html 在大约 241 行找到 如果你只指定了一个目录，没有指定访问的网页，它就会默认访问指定目录下的index.html 文件， 这个文件是可以设置多个的，并且优先级是从前到后。 这里我们可以将它设置为 index.html index.php 这样服务器默认先访问 index.html，如果没有，则默认访问 index.php 注意：我们改完了 apache 配置文件后要重启一下才会生效。 我们可以用命令行重启它(这里我们要用管理模式启动命令行)： 先输入net stop apache2.2 再输入net start apache2.2 或者在计算机管理里面重启 Apache服务 还可以用 Apache自带的管理器重启 如何修改服务器根目录在 httpd.conf 文件里搜索 DocumentRoot 在大约 179 行 我们来修改它的根路径 然后再下面大约 206 行处也要修改一下，注意要和上面修改的一样 如何修改 Apache 的监听端口我们接着在 httpd.conf 文件里搜索 80 在大约46行找到 Listen。 Listen 是听的意思，也就是说它在监听 80 端口如果我们将它更改为 81 ，然后重启 Apache 这时我们再次访问 localhost 这是因为浏览器请求 http 协议的时候默认访问的是 80 端口，也就是说如果只写localhost，那它实际访问的是 localhost：80，但是我们现在把监听的端口改成了 81，那么我们输入网址时就应该这样写 localhost：81。 当然我们也可以让它监听多个端口，如下图： 安装与配置 PHP 解释器现在我们在根目录新建一个a.php 文件，然后输入 &lt;?php echo ‘hello world’; ?&gt; 然后我们用浏览器打开它将显示如下图内容 貌似不太对劲啊！？可以看出来 php 文件并没有被解析，而是原样输出了… 这是为什么呢? 因为Apache是一个服务器，它只能响应一些静态的东西，如html、图片等等。 但是像这样的程序，它就不能解析了这时我们就要请出PHP的解释器 解压 PHP，并配置 php.ini 我们将它解压到文件夹 PHP5.3.2 中然后配置 php.ini 我们发现在目录中找不到 php.ini 但是我们能找到这两个文件 我们现在是处于学习阶段，所以我们用development这个文件我们将php.ini-development文件复制一份并重命名为 php.ini 这里我们有两个地方需要配置，其中一个是我们将 php 解压到如下图的目录中了 PHP 和 Apache 一样都有很多个扩展模块，放在ext这个目录中了。 Ext 是 extension 的简写，所以我们要明确的告诉 php 它的 extension_dir 在哪个位置。 我们在 php.ini 中搜索 extension_dir 在大约807 行中找到extension_dir = “./“ 我们看到在 extension_dir 的前面有一个分号&ldquo;;&rdquo;，这个是注释的意思，就是说extension_dir 被注释掉了，现在我们将分号去掉 ，并将路径更改为D：ampPHP5.3.2ext（你实际的PHP目录） 这是第一个要配置的地方。 第二个要配置的地方，我们搜索timezone在大约996行找到 Timezone是用来调时区用的，因为 php 有一些函数用来显示时间的，我们所在的时区是东八区，所以让 timezone= PRC 同时还是将前面的分号去掉。 现在我们配置完了 php 解释器，接下来我们要把php解释器和Apache整合起来。 整合 php 解释器和 Apache让Apache引入php模块，或者说引入php解释引擎。 我们在 Apache 的配置文件httpd.conf中随便找个地方告诉 Apache，php 的配置目录在哪，也就是php.ini在哪。 在文件中随便找个地方输入PHPIniDir “D：/amp/PHP5.3.2” （这里填写你的PHP的实际目录） 这样就告诉 Apache 服务器 php.ini 的路径了。 然后我们看 php 的目录下有一个php5apache2_2.dll的文件，php 和 Apache 的连接全靠它。 然后我们在httpd.conf文件中搜索 .so，然后再 .so 的最后面加上 php5apache2_2.dll 的路径， 输入LoadModule php5_module “D：/amp/PHP5.3.2/php5apache2_2.dll” 最后我们告诉 Apache 如果遇到以.php 结尾的文件，就调用 php 解释引擎解析。 我们搜索Addtype，在大约 383 行找到， 然后再下面加上 AddType application/x-httpd-php .php .phtml 意思是如果碰到了以.php 结尾或者.phtml 结尾的文件就调用 php 解释器来解析。 现在我们重启一下Apache，这次我们再次打开 a.php 文件就会正常解析了。 接下来开启php的功能模块 在php.ini中搜索extension=php我们找到如下 我们将需要的功能模块开启就 OK 了。 我暂时就需要以上这些模块，通常新手也就用到这些然后我们重启Apache。 在开启某些模块后，重启Apache的时候会报错，这是因为兼容性的问题为了解决这个问题我们还要在 http.conf 文件中引入两个文件 LoadFile “D：/amp/PHP5.3.2/libeay32.dll” LoadFile “D：/amp/PHP5.3.2/ssleay32.dll” 这样就解决了。 这时我们在 a.php 中输入&lt;?php phpinfo(); ?&gt; 就可以看到 php 的信息了。 如果在最后重启的时候失败了，我们就用命令行进行重启试一下，如果报了如下错误 这是因为系统上没有安装相应的 VC 编译器的库文件和头文件，安装后就会解决此问题。 安装与配置 Mysql双击打开MySQL 点击 Next 我们将它设置完后，点击 Next 继续安装。 正在安装中… 现在开始配置 mysql，点击 Next继续。 我们在这里选择细节配置，然后点击 Next。 选择第一个，然后点击 Next。 这里我们可以将innoDB库也放在data下面。 点击 Next Next！1234![新人学PHP，认为手动搭建环境而苦恼吗？这篇文章告诉你多简单](https://p3.pstatp.com/large/32010000ed0fb18cb5c0)Next！ NNNNNNext！！！！！ 这里根据自己的需求是否可以远程登录，反正我是没有允许，然后点击next。 最后一步 点击 Execute 就可以了 经过漫长的等待….. 终于！！ 哈哈！！ OK！！ 最后点击 Finish，就此安装完毕我们打开命令行试一下。 输入 mysql &ndash;uroot &ndash;p 密码 如果显示如下内容就说明安装成功了 ! 安装phpMyAdmin这一步应该是最简单的。 Phpmyadmin 是一个B/S软件，是一个可视化管理 Mysql 的软件，我们直接将它解压到，根目录中就可以了。 然后我们直接在浏览器中打开它 如果正常显示登录页面就代表成功了。 如果出现下面这种情况 出现这个问题，是因为 PHP 的 mbstring 扩展没有打开，或者说 PHP 扩展路径没有被正确指定，请打开 php.ini，将 ;extension=php_mbstring.dll 前面的分号（;）去掉，在php.ini 中 增 加 一 句 extension_dir=”D：ampPHP5.3.2ext”; 其 中D：ampPHP5.3.2ext 是指 php_mbstring.dll 文件存放的目录，也就是PHP 扩展目录（PHP 目录下的 ext 目录），请修改此目录路径为你的实际路径。 修改完后重新启动服务器即可。 phpMyAdmin安装到此就结束了。 本教程适合想了解手动搭建PHP环境的新童鞋，不喜勿喷，谢谢！ 本教程到此结束。","categories":[{"name":"闲扯","slug":"闲扯","permalink":"https://imzry.github.io/categories/闲扯/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://imzry.github.io/tags/PHP/"},{"name":"搭建环境","slug":"搭建环境","permalink":"https://imzry.github.io/tags/搭建环境/"}]}]}